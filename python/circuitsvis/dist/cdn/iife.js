"use strict";var CircuitsVis=(()=>{var JX=Object.create;var dg=Object.defineProperty,t9=Object.defineProperties,e9=Object.getOwnPropertyDescriptor,r9=Object.getOwnPropertyDescriptors,n9=Object.getOwnPropertyNames,D0=Object.getOwnPropertySymbols,o9=Object.getPrototypeOf,rN=Object.prototype.hasOwnProperty,g$=Object.prototype.propertyIsEnumerable;var nN=Math.pow,eN=(e,t,r)=>t in e?dg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,ae=(e,t)=>{for(var r in t||(t={}))rN.call(t,r)&&eN(e,r,t[r]);if(D0)for(var r of D0(t))g$.call(t,r)&&eN(e,r,t[r]);return e},R0=(e,t)=>t9(e,r9(t));var Vl=(e,t)=>{var r={};for(var n in e)rN.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(e!=null&&D0)for(var n of D0(e))t.indexOf(n)<0&&g$.call(e,n)&&(r[n]=e[n]);return r};var Ut=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Zn=(e,t)=>{for(var r in t)dg(e,r,{get:t[r],enumerable:!0})},x$=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of n9(t))!rN.call(e,o)&&o!==r&&dg(e,o,{get:()=>t[o],enumerable:!(n=e9(t,o))||n.enumerable});return e};var Yt=(e,t,r)=>(r=e!=null?JX(o9(e)):{},x$(t||!e||!e.__esModule?dg(r,"default",{value:e,enumerable:!0}):r,e)),s9=e=>x$(dg({},"__esModule",{value:!0}),e);var Ne=(e,t,r)=>(eN(e,typeof t!="symbol"?t+"":t,r),r);var H=(e,t,r)=>new Promise((n,o)=>{var s=l=>{try{a(r.next(l))}catch(u){o(u)}},i=l=>{try{a(r.throw(l))}catch(u){o(u)}},a=l=>l.done?n(l.value):Promise.resolve(l.value).then(s,i);a((r=r.apply(e,t)).next())});var E$=Ut(te=>{"use strict";var hg=Symbol.for("react.element"),i9=Symbol.for("react.portal"),a9=Symbol.for("react.fragment"),l9=Symbol.for("react.strict_mode"),u9=Symbol.for("react.profiler"),c9=Symbol.for("react.provider"),p9=Symbol.for("react.context"),f9=Symbol.for("react.forward_ref"),m9=Symbol.for("react.suspense"),d9=Symbol.for("react.memo"),h9=Symbol.for("react.lazy"),y$=Symbol.iterator;function g9(e){return e===null||typeof e!="object"?null:(e=y$&&e[y$]||e["@@iterator"],typeof e=="function"?e:null)}var w$={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$=Object.assign,S$={};function Pf(e,t,r){this.props=e,this.context=t,this.refs=S$,this.updater=r||w$}Pf.prototype.isReactComponent={};Pf.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};Pf.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function k$(){}k$.prototype=Pf.prototype;function sN(e,t,r){this.props=e,this.context=t,this.refs=S$,this.updater=r||w$}var iN=sN.prototype=new k$;iN.constructor=sN;C$(iN,Pf.prototype);iN.isPureReactComponent=!0;var b$=Array.isArray,T$=Object.prototype.hasOwnProperty,aN={current:null},N$={key:!0,ref:!0,__self:!0,__source:!0};function I$(e,t,r){var n,o={},s=null,i=null;if(t!=null)for(n in t.ref!==void 0&&(i=t.ref),t.key!==void 0&&(s=""+t.key),t)T$.call(t,n)&&!N$.hasOwnProperty(n)&&(o[n]=t[n]);var a=arguments.length-2;if(a===1)o.children=r;else if(1<a){for(var l=Array(a),u=0;u<a;u++)l[u]=arguments[u+2];o.children=l}if(e&&e.defaultProps)for(n in a=e.defaultProps,a)o[n]===void 0&&(o[n]=a[n]);return{$$typeof:hg,type:e,key:s,ref:i,props:o,_owner:aN.current}}function x9(e,t){return{$$typeof:hg,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function lN(e){return typeof e=="object"&&e!==null&&e.$$typeof===hg}function y9(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(r){return t[r]})}var v$=/\/+/g;function oN(e,t){return typeof e=="object"&&e!==null&&e.key!=null?y9(""+e.key):t.toString(36)}function O0(e,t,r,n,o){var s=typeof e;(s==="undefined"||s==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(s){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case hg:case i9:i=!0}}if(i)return i=e,o=o(i),e=n===""?"."+oN(i,0):n,b$(o)?(r="",e!=null&&(r=e.replace(v$,"$&/")+"/"),O0(o,t,r,"",function(u){return u})):o!=null&&(lN(o)&&(o=x9(o,r+(!o.key||i&&i.key===o.key?"":(""+o.key).replace(v$,"$&/")+"/")+e)),t.push(o)),1;if(i=0,n=n===""?".":n+":",b$(e))for(var a=0;a<e.length;a++){s=e[a];var l=n+oN(s,a);i+=O0(s,t,r,l,o)}else if(l=g9(e),typeof l=="function")for(e=l.call(e),a=0;!(s=e.next()).done;)s=s.value,l=n+oN(s,a++),i+=O0(s,t,r,l,o);else if(s==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return i}function $0(e,t,r){if(e==null)return e;var n=[],o=0;return O0(e,n,"","",function(s){return t.call(r,s,o++)}),n}function b9(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(r){(e._status===0||e._status===-1)&&(e._status=1,e._result=r)},function(r){(e._status===0||e._status===-1)&&(e._status=2,e._result=r)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var Mn={current:null},F0={transition:null},v9={ReactCurrentDispatcher:Mn,ReactCurrentBatchConfig:F0,ReactCurrentOwner:aN};te.Children={map:$0,forEach:function(e,t,r){$0(e,function(){t.apply(this,arguments)},r)},count:function(e){var t=0;return $0(e,function(){t++}),t},toArray:function(e){return $0(e,function(t){return t})||[]},only:function(e){if(!lN(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};te.Component=Pf;te.Fragment=a9;te.Profiler=u9;te.PureComponent=sN;te.StrictMode=l9;te.Suspense=m9;te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=v9;te.cloneElement=function(e,t,r){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var n=C$({},e.props),o=e.key,s=e.ref,i=e._owner;if(t!=null){if(t.ref!==void 0&&(s=t.ref,i=aN.current),t.key!==void 0&&(o=""+t.key),e.type&&e.type.defaultProps)var a=e.type.defaultProps;for(l in t)T$.call(t,l)&&!N$.hasOwnProperty(l)&&(n[l]=t[l]===void 0&&a!==void 0?a[l]:t[l])}var l=arguments.length-2;if(l===1)n.children=r;else if(1<l){a=Array(l);for(var u=0;u<l;u++)a[u]=arguments[u+2];n.children=a}return{$$typeof:hg,type:e.type,key:o,ref:s,props:n,_owner:i}};te.createContext=function(e){return e={$$typeof:p9,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:c9,_context:e},e.Consumer=e};te.createElement=I$;te.createFactory=function(e){var t=I$.bind(null,e);return t.type=e,t};te.createRef=function(){return{current:null}};te.forwardRef=function(e){return{$$typeof:f9,render:e}};te.isValidElement=lN;te.lazy=function(e){return{$$typeof:h9,_payload:{_status:-1,_result:e},_init:b9}};te.memo=function(e,t){return{$$typeof:d9,type:e,compare:t===void 0?null:t}};te.startTransition=function(e){var t=F0.transition;F0.transition={};try{e()}finally{F0.transition=t}};te.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};te.useCallback=function(e,t){return Mn.current.useCallback(e,t)};te.useContext=function(e){return Mn.current.useContext(e)};te.useDebugValue=function(){};te.useDeferredValue=function(e){return Mn.current.useDeferredValue(e)};te.useEffect=function(e,t){return Mn.current.useEffect(e,t)};te.useId=function(){return Mn.current.useId()};te.useImperativeHandle=function(e,t,r){return Mn.current.useImperativeHandle(e,t,r)};te.useInsertionEffect=function(e,t){return Mn.current.useInsertionEffect(e,t)};te.useLayoutEffect=function(e,t){return Mn.current.useLayoutEffect(e,t)};te.useMemo=function(e,t){return Mn.current.useMemo(e,t)};te.useReducer=function(e,t,r){return Mn.current.useReducer(e,t,r)};te.useRef=function(e){return Mn.current.useRef(e)};te.useState=function(e){return Mn.current.useState(e)};te.useSyncExternalStore=function(e,t,r){return Mn.current.useSyncExternalStore(e,t,r)};te.useTransition=function(){return Mn.current.useTransition()};te.version="18.2.0"});var oe=Ut((Dbt,_$)=>{"use strict";_$.exports=E$()});var D$=Ut((Rbt,A$)=>{"use strict";var w9="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";A$.exports=w9});var F$=Ut(($bt,O$)=>{"use strict";var C9=D$();function R$(){}function $$(){}$$.resetWarningCache=R$;O$.exports=function(){function e(n,o,s,i,a,l){if(l!==C9){var u=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw u.name="Invariant Violation",u}}e.isRequired=e;function t(){return e}var r={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:$$,resetWarningCache:R$};return r.PropTypes=r,r}});var qi=Ut((Pbt,P$)=>{P$.exports=F$()();var Obt,Fbt});var Gc=Ut(Lf=>{"use strict";Object.defineProperty(Lf,"__esModule",{value:!0});Lf.setConfiguration=Lf.getConfiguration=void 0;var uN={breakpoints:[576,768,992,1200,1600,1920],containerWidths:[540,750,960,1140,1540,1810],gutterWidth:30,gridColumns:12,defaultScreenClass:"xxl",maxScreenClass:"xxl"},S9=()=>uN;Lf.getConfiguration=S9;var k9=e=>{uN=ae(ae({},uN),e)};Lf.setConfiguration=k9});var L$=Ut(P0=>{"use strict";Object.defineProperty(P0,"__esModule",{value:!0});P0.default=void 0;var T9="div";P0.default=T9});var M$=Ut(L0=>{"use strict";Object.defineProperty(L0,"__esModule",{value:!0});L0.default=void 0;var N9="span";L0.default=N9});var z$=Ut(M0=>{"use strict";Object.defineProperty(M0,"__esModule",{value:!0});M0.default=void 0;var I9=typeof window!="undefined"?window:void 0;M0.default=I9});var Mf=Ut(gg=>{"use strict";Object.defineProperty(gg,"__esModule",{value:!0});Object.defineProperty(gg,"Div",{enumerable:!0,get:function(){return E9.default}});Object.defineProperty(gg,"Span",{enumerable:!0,get:function(){return _9.default}});Object.defineProperty(gg,"Window",{enumerable:!0,get:function(){return A9.default}});var E9=cN(L$()),_9=cN(M$()),A9=cN(z$());function cN(e){return e&&e.__esModule?e:{default:e}}});var B0=Ut(zf=>{"use strict";Object.defineProperty(zf,"__esModule",{value:!0});zf.useScreenClass=zf.screenClasses=void 0;var B$=oe(),D9=Gc(),xg=Mf(),R9=e=>e&&e.current&&e.current.clientWidth?e.current.clientWidth:typeof xg.Window!="undefined"&&xg.Window.innerWidth?xg.Window.innerWidth:null,z0=["xs","sm","md","lg","xl","xxl","xxxl"];zf.screenClasses=z0;var $9=(e,t)=>{let r=()=>{let{breakpoints:s,defaultScreenClass:i,maxScreenClass:a}=(0,D9.getConfiguration)(),l=i,u=R9(e);u?(l="xs",s[0]&&u>=s[0]&&(l="sm"),s[1]&&u>=s[1]&&(l="md"),s[2]&&u>=s[2]&&(l="lg"),s[3]&&u>=s[3]&&(l="xl"),s[4]&&u>=s[4]&&(l="xxl"),s[5]&&u>=s[5]&&(l="xxxl")):t&&(l=t);let c=z0.indexOf(l),p=z0.indexOf(a);return p>=0&&c>p&&(l=z0[p]),l},[n,o]=(0,B$.useState)(()=>r());return(0,B$.useEffect)(()=>{let s=()=>o(r());return xg.Window.addEventListener("resize",s,!1),()=>{xg.Window.removeEventListener("resize",s,!1)}},[]),n};zf.useScreenClass=$9});var W$=Ut(W0=>{"use strict";Object.defineProperty(W0,"__esModule",{value:!0});W0.default=void 0;var V$=B0(),O9=e=>Object.keys(e).reduce((t,r)=>t||e[r],!1),V0=(e,t)=>{if(typeof e!="number")return;let r=Math.max(0,Math.min(t,e));return"".concat(100/t*r,"%")},F9=e=>{let{forceWidth:t=null,width:r={},offset:n={},pull:o={},push:s={},order:i={},debug:a,screenClass:l,gutterWidth:u,moreStyle:c,gridColumns:p}=e,f={boxSizing:"border-box",minHeight:1,position:"relative",paddingLeft:u/2,paddingRight:u/2,width:"100%"};return a&&(f.outline="1px solid silver",f.background="rgba(0,0,0,.05)",f.lineHeight="32px"),f.flexBasis="100%",f.flexGrow=0,f.flexShrink=0,f.maxWidth="100%",f.marginLeft="0%",f.right="auto",f.left="auto",V$.screenClasses.forEach((m,d)=>{if(V$.screenClasses.indexOf(l)>=d){let h=V0(r[m],p),x=r[m]==="content";f.flexBasis=x?"auto":h||f.flexBasis,f.width=f.flexBasis,f.maxWidth=h||f.maxWidth,f.marginLeft=V0(n[m],p)||f.marginLeft,f.right=V0(o[m],p)||f.right,f.left=V0(s[m],p)||f.left,i[m]&&(f.order=i[m])}}),O9(r)||(f.flexBasis=0,f.flexGrow=1),t&&(f.flexBasis="unset",f.flexGrow="unset",f.flexShrink="unset",f.width=t),ae(ae({},f),c)};W0.default=F9});var G$=Ut(G0=>{"use strict";Object.defineProperty(G0,"__esModule",{value:!0});G0.default=void 0;var P9=e=>{let{gutterWidth:t,align:r,justify:n,debug:o,moreStyle:s,direction:i,wrap:a}=e,l=r;r==="start"&&(l="flex-start"),r==="end"&&(l="flex-end");let u=n;n==="start"&&(u="flex-start"),n==="end"&&(u="flex-end"),n==="between"&&(u="space-between"),n==="around"&&(u="space-around"),n==="center"&&(u="center"),n==="initial"&&(u="initial"),n==="inherit"&&(u="inherit");let c=["column","row","column-reverse","row-reverse"].includes(i)?i:void 0,p=a;a==="nowrap"&&(p="nowrap"),a==="wrap"&&(p="wrap"),a==="reverse"&&(p="wrap-reverse");let f={marginLeft:-t/2,marginRight:-t/2,display:"flex",flexGrow:0,flexShrink:0,alignItems:l,justifyContent:u,flexDirection:c,flexWrap:p};return o&&(f.background="rgba(128,128,128,.05)"),ae(ae({},f),s)};G0.default=P9});var mN=Ut(Bf=>{"use strict";Object.defineProperty(Bf,"__esModule",{value:!0});Bf.default=Bf.GutterWidthContext=void 0;var U0=pN(oe()),ko=pN(qi()),L9=Gc(),M9=pN(G$()),z9=Mf();function pN(e){return e&&e.__esModule?e:{default:e}}var U$=U0.default.createContext(!1);Bf.GutterWidthContext=U$;var fN=U0.default.forwardRef((e,t)=>{let h=e,{children:r,style:n,align:o,justify:s,wrap:i,debug:a,nogutter:l,gutterWidth:u,component:c,direction:p}=h,f=Vl(h,["children","style","align","justify","wrap","debug","nogutter","gutterWidth","component","direction"]),m=(0,L9.getConfiguration)().gutterWidth;l&&(m=0),typeof u=="number"&&(m=u);let d=(0,M9.default)({gutterWidth:m,align:o,justify:s,debug:a,moreStyle:n,direction:p,wrap:i});return U0.default.createElement(c,ae({ref:t,style:d},f),U0.default.createElement(U$.Provider,{value:m},r))});fN.propTypes={children:ko.default.node.isRequired,align:ko.default.oneOf(["normal","start","center","end","stretch"]),justify:ko.default.oneOf(["start","center","end","between","around","initial","inherit"]),direction:ko.default.oneOf(["column","row","column-reverse","row-reverse"]),wrap:ko.default.oneOf(["nowrap","wrap","reverse"]),nogutter:ko.default.bool,gutterWidth:ko.default.number,style:ko.default.objectOf(ko.default.oneOfType([ko.default.number,ko.default.string])),debug:ko.default.bool,component:ko.default.elementType};fN.defaultProps={align:"normal",justify:"start",direction:"row",wrap:"wrap",nogutter:!1,gutterWidth:null,style:{},debug:!1,component:z9.Div};var B9=fN;Bf.default=B9});var gN=Ut(Gl=>{"use strict";Object.defineProperty(Gl,"__esModule",{value:!0});Gl.default=Gl.ScreenClassContext=Gl.NO_PROVIDER_FLAG=void 0;var Wl=H9(oe()),dN=U9(qi()),V9=B0(),W9=Gc(),G9=Mf();function U9(e){return e&&e.__esModule?e:{default:e}}function H$(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(H$=function(n){return n?r:t})(e)}function H9(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=H$(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}var q$="NO_PROVIDER_FLAG";Gl.NO_PROVIDER_FLAG=q$;var j$=Wl.default.createContext(q$);Gl.ScreenClassContext=j$;var hN=e=>{let{useOwnWidth:t,children:r,fallbackScreenClass:n}=e,o=(0,Wl.useRef)(),[s,i]=(0,Wl.useState)(!1),a=(0,V9.useScreenClass)(o,n),{defaultScreenClass:l}=(0,W9.getConfiguration)(),u=s?a:n||l;return(0,Wl.useEffect)(()=>i(!0),[]),Wl.default.createElement(j$.Provider,{value:u},t?Wl.default.createElement(G9.Div,{ref:t?o:null},r):Wl.default.createElement(Wl.default.Fragment,null,r))};hN.propTypes={children:dN.default.node.isRequired,useOwnWidth:dN.default.bool,fallbackScreenClass:dN.default.oneOf([null,"xs","sm","md","lg","xl","xxl","xxxl"])};hN.defaultProps={useOwnWidth:!1,fallbackScreenClass:null};var q9=hN;Gl.default=q9});var Vf=Ut(q0=>{"use strict";Object.defineProperty(q0,"__esModule",{value:!0});q0.default=void 0;var xN=X$(oe()),j9=X$(qi()),H0=K9(gN());function K$(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(K$=function(n){return n?r:t})(e)}function K9(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=K$(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}function X$(e){return e&&e.__esModule?e:{default:e}}var Y$=e=>{let{children:t}=e;return xN.default.createElement(H0.ScreenClassContext.Consumer,null,r=>r===H0.NO_PROVIDER_FLAG?xN.default.createElement(H0.default,null,xN.default.createElement(H0.ScreenClassContext.Consumer,null,n=>t(n))):t(r))};Y$.propTypes={children:j9.default.func.isRequired};var X9=Y$;q0.default=X9});var Z$=Ut(K0=>{"use strict";Object.defineProperty(K0,"__esModule",{value:!0});K0.default=void 0;var j0=e7(oe()),_t=yN(qi()),Y9=yN(W$()),Q9=Gc(),Z9=mN(),J9=yN(Vf()),t7=Mf();function yN(e){return e&&e.__esModule?e:{default:e}}function Q$(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(Q$=function(n){return n?r:t})(e)}function e7(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=Q$(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}var bN=j0.default.forwardRef((e,t)=>{let b=e,{children:r,xs:n,sm:o,md:s,lg:i,xl:a,xxl:l,xxxl:u,offset:c,pull:p,push:f,order:m,debug:d,style:h,component:x,width:g}=b,y=Vl(b,["children","xs","sm","md","lg","xl","xxl","xxxl","offset","pull","push","order","debug","style","component","width"]);return j0.default.createElement(J9.default,null,v=>j0.default.createElement(Z9.GutterWidthContext.Consumer,null,C=>{let S=(0,Y9.default)({forceWidth:g,width:{xs:n,sm:o,md:s,lg:i,xl:a,xxl:l,xxxl:u},offset:c,pull:p,push:f,order:m,debug:d,screenClass:v,gutterWidth:C,gridColumns:(0,Q9.getConfiguration)().gridColumns,moreStyle:h});return(0,j0.createElement)(x,R0(ae({ref:t,style:S},y),{children:r}))}))});bN.propTypes={children:_t.default.node,xs:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),sm:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),md:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),lg:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),xl:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),xxl:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),xxxl:_t.default.oneOfType([_t.default.number,_t.default.oneOf(["content"])]),width:_t.default.oneOfType([_t.default.number,_t.default.string]),offset:_t.default.shape({xs:_t.default.number,sm:_t.default.number,md:_t.default.number,lg:_t.default.number,xl:_t.default.number,xxl:_t.default.number,xxxl:_t.default.number}),push:_t.default.shape({xs:_t.default.number,sm:_t.default.number,md:_t.default.number,lg:_t.default.number,xl:_t.default.number,xxl:_t.default.number,xxxl:_t.default.number}),pull:_t.default.shape({xs:_t.default.number,sm:_t.default.number,md:_t.default.number,lg:_t.default.number,xl:_t.default.number,xxl:_t.default.number,xxxl:_t.default.number}),order:_t.default.shape({xs:_t.default.number,sm:_t.default.number,md:_t.default.number,lg:_t.default.number,xl:_t.default.number,xxl:_t.default.number,xxxl:_t.default.number}),style:_t.default.objectOf(_t.default.oneOfType([_t.default.number,_t.default.string])),debug:_t.default.bool,component:_t.default.elementType};bN.defaultProps={children:null,xs:null,sm:null,md:null,lg:null,xl:null,xxl:null,xxxl:null,width:null,offset:{},push:{},pull:{},style:{},order:{},debug:!1,component:t7.Div};var r7=bN;K0.default=r7});var J$=Ut(X0=>{"use strict";Object.defineProperty(X0,"__esModule",{value:!0});X0.default=void 0;var n7=e=>{let{fluid:t,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l,screenClass:u,containerWidths:c,gutterWidth:p,moreStyle:f}=e,m={boxSizing:"border-box",position:"relative",marginLeft:"auto",marginRight:"auto",paddingLeft:p/2,paddingRight:p/2};return t&&!r&&!n&&!o&&!s&&!i?ae(ae({},m),f):(u==="xs"&&c[0]&&!r&&(m.maxWidth=c[0]),u==="sm"&&c[0]&&!n&&(m.maxWidth=c[0]),u==="md"&&c[1]&&!o&&(m.maxWidth=c[1]),u==="lg"&&c[2]&&!s&&(m.maxWidth=c[2]),u==="xl"&&c[3]&&!i&&(m.maxWidth=c[3]),u==="xxl"&&c[4]&&!a&&(m.maxWidth=c[4]),u==="xxxl"&&c[5]&&!l&&(m.maxWidth=c[5]),ae(ae({},m),f))};X0.default=n7});var rO=Ut(Y0=>{"use strict";Object.defineProperty(Y0,"__esModule",{value:!0});Y0.default=void 0;var vN=a7(oe()),Jn=wN(qi()),o7=wN(J$()),tO=Gc(),s7=wN(Vf()),i7=Mf();function wN(e){return e&&e.__esModule?e:{default:e}}function eO(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(eO=function(n){return n?r:t})(e)}function a7(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=eO(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}var CN=vN.default.forwardRef((e,t)=>{let d=e,{children:r,fluid:n,xs:o,sm:s,md:i,lg:a,xl:l,xxl:u,xxxl:c,style:p,component:f}=d,m=Vl(d,["children","fluid","xs","sm","md","lg","xl","xxl","xxxl","style","component"]);return vN.default.createElement(s7.default,null,h=>(0,vN.createElement)(f,ae({ref:t,style:(0,o7.default)({fluid:n,xs:o,sm:s,md:i,lg:a,xl:l,xxl:u,xxxl:c,screenClass:h,containerWidths:(0,tO.getConfiguration)().containerWidths,gutterWidth:(0,tO.getConfiguration)().gutterWidth,moreStyle:p})},m),r))});CN.propTypes={children:Jn.default.node.isRequired,fluid:Jn.default.bool,xs:Jn.default.bool,sm:Jn.default.bool,md:Jn.default.bool,lg:Jn.default.bool,xl:Jn.default.bool,xxl:Jn.default.bool,xxxl:Jn.default.bool,style:Jn.default.objectOf(Jn.default.oneOfType([Jn.default.number,Jn.default.string])),component:Jn.default.elementType};CN.defaultProps={fluid:!1,xs:!1,sm:!1,md:!1,lg:!1,xl:!1,xxl:!1,xxxl:!1,style:{},component:i7.Div};var l7=CN;Y0.default=l7});var oO=Ut(Wf=>{"use strict";Object.defineProperty(Wf,"__esModule",{value:!0});Wf.hidden=Wf.default=void 0;var nO=e=>{let{screenClass:t,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l}=e;return t==="xxl"?a:t==="xxxl"?l:t==="xl"?i:t==="lg"?s:t==="md"?o:t==="sm"?n:r};Wf.hidden=nO;var u7=nO;Wf.default=u7});var iO=Ut(Q0=>{"use strict";Object.defineProperty(Q0,"__esModule",{value:!0});Q0.default=void 0;var c7=SN(oe()),Ul=SN(qi()),p7=m7(oO()),f7=SN(Vf());function sO(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(sO=function(n){return n?r:t})(e)}function m7(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=sO(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}function SN(e){return e&&e.__esModule?e:{default:e}}var kN=e=>{let{children:t,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l}=e;return c7.default.createElement(f7.default,null,u=>p7.hidden({screenClass:u,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l})?null:t)};kN.propTypes={children:Ul.default.node.isRequired,xs:Ul.default.bool,sm:Ul.default.bool,md:Ul.default.bool,lg:Ul.default.bool,xl:Ul.default.bool,xxl:Ul.default.bool,xxxl:Ul.default.bool};kN.defaultProps={xs:!1,sm:!1,md:!1,lg:!1,xl:!1,xxl:!1,xxxl:!1};var d7=kN;Q0.default=d7});var lO=Ut(Gf=>{"use strict";Object.defineProperty(Gf,"__esModule",{value:!0});Gf.visible=Gf.default=void 0;var aO=e=>{let{screenClass:t,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l}=e;return t==="xxl"?a:t==="xxxl"?l:t==="xl"?i:t==="lg"?s:t==="md"?o:t==="sm"?n:r};Gf.visible=aO;var h7=aO;Gf.default=h7});var cO=Ut(Z0=>{"use strict";Object.defineProperty(Z0,"__esModule",{value:!0});Z0.default=void 0;var g7=TN(oe()),Hl=TN(qi()),x7=b7(lO()),y7=TN(Vf());function uO(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(uO=function(n){return n?r:t})(e)}function b7(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=uO(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}function TN(e){return e&&e.__esModule?e:{default:e}}var NN=e=>{let{children:t,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l}=e;return g7.default.createElement(y7.default,null,u=>x7.visible({screenClass:u,xs:r,sm:n,md:o,lg:s,xl:i,xxl:a,xxxl:l})?t:null)};NN.propTypes={children:Hl.default.node.isRequired,xs:Hl.default.bool,sm:Hl.default.bool,md:Hl.default.bool,lg:Hl.default.bool,xl:Hl.default.bool,xxl:Hl.default.bool,xxxl:Hl.default.bool};NN.defaultProps={xs:!1,sm:!1,md:!1,lg:!1,xl:!1,xxl:!1,xxxl:!1};var v7=NN;Z0.default=v7});var fO=Ut(J0=>{"use strict";Object.defineProperty(J0,"__esModule",{value:!0});J0.default=void 0;var w7=IN(oe()),C7=IN(qi()),S7=IN(Vf());function IN(e){return e&&e.__esModule?e:{default:e}}var pO=e=>{let{render:t}=e;return w7.default.createElement(S7.default,null,r=>t(r))};pO.propTypes={render:C7.default.func.isRequired};var k7=pO;J0.default=k7});var Uc=Ut(Ho=>{"use strict";Object.defineProperty(Ho,"__esModule",{value:!0});Object.defineProperty(Ho,"Col",{enumerable:!0,get:function(){return T7.default}});Object.defineProperty(Ho,"Container",{enumerable:!0,get:function(){return N7.default}});Object.defineProperty(Ho,"Hidden",{enumerable:!0,get:function(){return E7.default}});Object.defineProperty(Ho,"Row",{enumerable:!0,get:function(){return I7.default}});Object.defineProperty(Ho,"ScreenClassContext",{enumerable:!0,get:function(){return mO.ScreenClassContext}});Object.defineProperty(Ho,"ScreenClassProvider",{enumerable:!0,get:function(){return mO.default}});Object.defineProperty(Ho,"ScreenClassRender",{enumerable:!0,get:function(){return A7.default}});Object.defineProperty(Ho,"Visible",{enumerable:!0,get:function(){return _7.default}});Object.defineProperty(Ho,"setConfiguration",{enumerable:!0,get:function(){return D7.setConfiguration}});Object.defineProperty(Ho,"useScreenClass",{enumerable:!0,get:function(){return R7.useScreenClass}});var T7=Uf(Z$()),N7=Uf(rO()),I7=Uf(mN()),E7=Uf(iO()),_7=Uf(cO()),A7=Uf(fO()),mO=$7(gN()),D7=Gc(),R7=B0();function dO(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(dO=function(n){return n?r:t})(e)}function $7(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=dO(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(s!=="default"&&Object.prototype.hasOwnProperty.call(e,s)){var i=o?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(n,s,i):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}function Uf(e){return e&&e.__esModule?e:{default:e}}});var CP=Ut((yvt,wP)=>{wP.exports=Be;var Yo=null;try{Yo=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function Be(e,t,r){this.low=e|0,this.high=t|0,this.unsigned=!!r}Be.prototype.__isLong__;Object.defineProperty(Be.prototype,"__isLong__",{value:!0});function ao(e){return(e&&e.__isLong__)===!0}Be.isLong=ao;var fP={},mP={};function dp(e,t){var r,n,o;return t?(e>>>=0,(o=0<=e&&e<256)&&(n=mP[e],n)?n:(r=Ve(e,(e|0)<0?-1:0,!0),o&&(mP[e]=r),r)):(e|=0,(o=-128<=e&&e<128)&&(n=fP[e],n)?n:(r=Ve(e,e<0?-1:0,!1),o&&(fP[e]=r),r))}Be.fromInt=dp;function Qo(e,t){if(isNaN(e))return t?mp:Zo;if(t){if(e<0)return mp;if(e>=xP)return vP}else{if(e<=-hP)return io;if(e+1>=hP)return bP}return e<0?Qo(-e,t).neg():Ve(e%ed|0,e/ed|0,t)}Be.fromNumber=Qo;function Ve(e,t,r){return new Be(e,t,r)}Be.fromBits=Ve;var Sw=Math.pow;function qI(e,t,r){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return Zo;if(typeof t=="number"?(r=t,t=!1):t=!!t,r=r||10,r<2||36<r)throw RangeError("radix");var n;if((n=e.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return qI(e.substring(1),t,r).neg();for(var o=Qo(Sw(r,8)),s=Zo,i=0;i<e.length;i+=8){var a=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+a),r);if(a<8){var u=Qo(Sw(r,a));s=s.mul(u).add(Qo(l))}else s=s.mul(o),s=s.add(Qo(l))}return s.unsigned=t,s}Be.fromString=qI;function Ps(e,t){return typeof e=="number"?Qo(e,t):typeof e=="string"?qI(e,t):Ve(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}Be.fromValue=Ps;var dP=1<<16,kJ=1<<24,ed=dP*dP,xP=ed*ed,hP=xP/2,gP=dp(kJ),Zo=dp(0);Be.ZERO=Zo;var mp=dp(0,!0);Be.UZERO=mp;var td=dp(1);Be.ONE=td;var yP=dp(1,!0);Be.UONE=yP;var HI=dp(-1);Be.NEG_ONE=HI;var bP=Ve(-1,2147483647,!1);Be.MAX_VALUE=bP;var vP=Ve(-1,-1,!0);Be.MAX_UNSIGNED_VALUE=vP;var io=Ve(0,-2147483648,!1);Be.MIN_VALUE=io;var gt=Be.prototype;gt.toInt=function(){return this.unsigned?this.low>>>0:this.low};gt.toNumber=function(){return this.unsigned?(this.high>>>0)*ed+(this.low>>>0):this.high*ed+(this.low>>>0)};gt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(io)){var r=Qo(t),n=this.div(r),o=n.mul(r).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=Qo(Sw(t,6),this.unsigned),i=this,a="";;){var l=i.div(s),u=i.sub(l.mul(s)).toInt()>>>0,c=u.toString(t);if(i=l,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};gt.getHighBits=function(){return this.high};gt.getHighBitsUnsigned=function(){return this.high>>>0};gt.getLowBits=function(){return this.low};gt.getLowBitsUnsigned=function(){return this.low>>>0};gt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(io)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,r=31;r>0&&(t&1<<r)==0;r--);return this.high!=0?r+33:r+1};gt.isZero=function(){return this.high===0&&this.low===0};gt.eqz=gt.isZero;gt.isNegative=function(){return!this.unsigned&&this.high<0};gt.isPositive=function(){return this.unsigned||this.high>=0};gt.isOdd=function(){return(this.low&1)===1};gt.isEven=function(){return(this.low&1)===0};gt.equals=function(t){return ao(t)||(t=Ps(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};gt.eq=gt.equals;gt.notEquals=function(t){return!this.eq(t)};gt.neq=gt.notEquals;gt.ne=gt.notEquals;gt.lessThan=function(t){return this.comp(t)<0};gt.lt=gt.lessThan;gt.lessThanOrEqual=function(t){return this.comp(t)<=0};gt.lte=gt.lessThanOrEqual;gt.le=gt.lessThanOrEqual;gt.greaterThan=function(t){return this.comp(t)>0};gt.gt=gt.greaterThan;gt.greaterThanOrEqual=function(t){return this.comp(t)>=0};gt.gte=gt.greaterThanOrEqual;gt.ge=gt.greaterThanOrEqual;gt.compare=function(t){if(ao(t)||(t=Ps(t)),this.eq(t))return 0;var r=this.isNegative(),n=t.isNegative();return r&&!n?-1:!r&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};gt.comp=gt.compare;gt.negate=function(){return!this.unsigned&&this.eq(io)?io:this.not().add(td)};gt.neg=gt.negate;gt.add=function(t){ao(t)||(t=Ps(t));var r=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,p=0,f=0,m=0;return m+=s+u,f+=m>>>16,m&=65535,f+=o+l,p+=f>>>16,f&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=r+i,c&=65535,Ve(f<<16|m,c<<16|p,this.unsigned)};gt.subtract=function(t){return ao(t)||(t=Ps(t)),this.add(t.neg())};gt.sub=gt.subtract;gt.multiply=function(t){if(this.isZero())return Zo;if(ao(t)||(t=Ps(t)),Yo){var r=Yo.mul(this.low,this.high,t.low,t.high);return Ve(r,Yo.get_high(),this.unsigned)}if(t.isZero())return Zo;if(this.eq(io))return t.isOdd()?io:Zo;if(t.eq(io))return this.isOdd()?io:Zo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(gP)&&t.lt(gP))return Qo(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,p=0,f=0,m=0,d=0;return d+=i*c,m+=d>>>16,d&=65535,m+=s*c,f+=m>>>16,m&=65535,m+=i*u,f+=m>>>16,m&=65535,f+=o*c,p+=f>>>16,f&=65535,f+=s*u,p+=f>>>16,f&=65535,f+=i*l,p+=f>>>16,f&=65535,p+=n*c+o*u+s*l+i*a,p&=65535,Ve(m<<16|d,p<<16|f,this.unsigned)};gt.mul=gt.multiply;gt.divide=function(t){if(ao(t)||(t=Ps(t)),t.isZero())throw Error("division by zero");if(Yo){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var r=(this.unsigned?Yo.div_u:Yo.div_s)(this.low,this.high,t.low,t.high);return Ve(r,Yo.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?mp:Zo;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return mp;if(t.gt(this.shru(1)))return yP;s=mp}else{if(this.eq(io)){if(t.eq(td)||t.eq(HI))return io;if(t.eq(io))return td;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(Zo)?t.isNegative()?td:HI:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(io))return this.unsigned?mp:Zo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=Zo}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:Sw(2,a-48),u=Qo(n),c=u.mul(t);c.isNegative()||c.gt(o);)n-=l,u=Qo(n,this.unsigned),c=u.mul(t);u.isZero()&&(u=td),s=s.add(u),o=o.sub(c)}return s};gt.div=gt.divide;gt.modulo=function(t){if(ao(t)||(t=Ps(t)),Yo){var r=(this.unsigned?Yo.rem_u:Yo.rem_s)(this.low,this.high,t.low,t.high);return Ve(r,Yo.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};gt.mod=gt.modulo;gt.rem=gt.modulo;gt.not=function(){return Ve(~this.low,~this.high,this.unsigned)};gt.and=function(t){return ao(t)||(t=Ps(t)),Ve(this.low&t.low,this.high&t.high,this.unsigned)};gt.or=function(t){return ao(t)||(t=Ps(t)),Ve(this.low|t.low,this.high|t.high,this.unsigned)};gt.xor=function(t){return ao(t)||(t=Ps(t)),Ve(this.low^t.low,this.high^t.high,this.unsigned)};gt.shiftLeft=function(t){return ao(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ve(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Ve(0,this.low<<t-32,this.unsigned)};gt.shl=gt.shiftLeft;gt.shiftRight=function(t){return ao(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ve(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Ve(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};gt.shr=gt.shiftRight;gt.shiftRightUnsigned=function(t){if(ao(t)&&(t=t.toInt()),t&=63,t===0)return this;var r=this.high;if(t<32){var n=this.low;return Ve(n>>>t|r<<32-t,r>>>t,this.unsigned)}else return t===32?Ve(r,0,this.unsigned):Ve(r>>>t-32,0,this.unsigned)};gt.shru=gt.shiftRightUnsigned;gt.shr_u=gt.shiftRightUnsigned;gt.toSigned=function(){return this.unsigned?Ve(this.low,this.high,!1):this};gt.toUnsigned=function(){return this.unsigned?this:Ve(this.low,this.high,!0)};gt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};gt.toBytesLE=function(){var t=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};gt.toBytesBE=function(){var t=this.high,r=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,r>>>24,r>>>16&255,r>>>8&255,r&255]};Be.fromBytes=function(t,r,n){return n?Be.fromBytesLE(t,r):Be.fromBytesBE(t,r)};Be.fromBytesLE=function(t,r){return new Be(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,r)};Be.fromBytesBE=function(t,r){return new Be(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],r)}});var rL=Ut(()=>{});var nL=Ut(()=>{});var KL=Ut((jL,e_)=>{(function(e,t,r){function n(a){var l=this,u=i();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(a),l.s0<0&&(l.s0+=1),l.s1-=u(a),l.s1<0&&(l.s1+=1),l.s2-=u(a),l.s2<0&&(l.s2+=1),u=null}function o(a,l){return l.c=a.c,l.s0=a.s0,l.s1=a.s1,l.s2=a.s2,l}function s(a,l){var u=new n(a),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,u),p.state=function(){return o(u,{})}),p}function i(){var a=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){a+=u.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.alea=s})(jL,typeof e_=="object"&&e_,typeof define=="function"&&define)});var YL=Ut((XL,r_)=>{(function(e,t,r){function n(i){var a=this,l="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var l=new n(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.xor128=s})(XL,typeof r_=="object"&&r_,typeof define=="function"&&define)});var ZL=Ut((QL,n_)=>{(function(e,t,r){function n(i){var a=this,l="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,u==l.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var l=new n(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.xorwow=s})(QL,typeof n_=="object"&&n_,typeof define=="function"&&define)});var tM=Ut((JL,o_)=>{(function(e,t,r){function n(i){var a=this;a.next=function(){var u=a.x,c=a.i,p,f,m;return p=u[c],p^=p>>>7,f=p^p<<24,p=u[c+1&7],f^=p^p>>>10,p=u[c+3&7],f^=p^p>>>3,p=u[c+4&7],f^=p^p<<7,p=u[c+7&7],p=p^p<<13,f^=p^p<<9,u[c]=f,a.i=c+1&7,f};function l(u,c){var p,f,m=[];if(c===(c|0))f=m[0]=c;else for(c=""+c,p=0;p<c.length;++p)m[p&7]=m[p&7]<<15^c.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&m[p]===0;++p);for(p==8?f=m[7]=-1:f=m[p],u.x=m,u.i=0,p=256;p>0;--p)u.next()}l(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var l=new n(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,u&&(u.x&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.xorshift7=s})(JL,typeof o_=="object"&&o_,typeof define=="function"&&define)});var rM=Ut((eM,s_)=>{(function(e,t,r){function n(i){var a=this;a.next=function(){var u=a.w,c=a.X,p=a.i,f,m;return a.w=u=u+1640531527|0,m=c[p+34&127],f=c[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=c[p]=m^f,a.i=p,m+(u^u>>>16)|0};function l(u,c){var p,f,m,d,h,x=[],g=128;for(c===(c|0)?(f=c,c=null):(c=c+"\0",f=0,g=Math.max(g,c.length)),m=0,d=-32;d<g;++d)c&&(f^=c.charCodeAt((d+32)%c.length)),d===0&&(h=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,d>=0&&(h=h+1640531527|0,p=x[d&127]^=f+h,m=p==0?m+1:0);for(m>=128&&(x[(c&&c.length||0)&127]=-1),m=127,d=4*128;d>0;--d)f=x[m+34&127],p=x[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,x[m]=f^p;u.w=h,u.X=x,u.i=m}l(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var l=new n(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,u&&(u.X&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.xor4096=s})(eM,typeof s_=="object"&&s_,typeof define=="function"&&define)});var oM=Ut((nM,i_)=>{(function(e,t,r){function n(i){var a=this,l="";a.next=function(){var c=a.b,p=a.c,f=a.d,m=a.a;return c=c<<25^c>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-f|0,a.d=f<<16^p>>>16^m,a.a=m-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):l+=i;for(var u=0;u<l.length+20;u++)a.b^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var l=new n(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:r&&r.amd?r(function(){return s}):this.tychei=s})(nM,typeof i_=="object"&&i_,typeof define=="function"&&define)});var sM=Ut(()=>{});var aM=Ut((iM,jw)=>{(function(e,t,r){var n=256,o=6,s=52,i="random",a=r.pow(n,o),l=r.pow(2,s),u=l*2,c=n-1,p;function f(b,v,C){var S=[];v=v==!0?{entropy:!0}:v||{};var k=x(h(v.entropy?[b,y(t)]:b==null?g():b,3),S),I=new m(S),D=function(){for(var R=I.g(o),M=a,U=0;R<l;)R=(R+U)*n,M*=n,U=I.g(1);for(;R>=u;)R/=2,M/=2,U>>>=1;return(R+U)/M};return D.int32=function(){return I.g(4)|0},D.quick=function(){return I.g(4)/4294967296},D.double=D,x(y(I.S),t),(v.pass||C||function(R,M,U,j){return j&&(j.S&&d(j,I),R.state=function(){return d(I,{})}),U?(r[i]=R,M):R})(D,k,"global"in v?v.global:this==r,v.state)}function m(b){var v,C=b.length,S=this,k=0,I=S.i=S.j=0,D=S.S=[];for(C||(b=[C++]);k<n;)D[k]=k++;for(k=0;k<n;k++)D[k]=D[I=c&I+b[k%C]+(v=D[k])],D[I]=v;(S.g=function(R){for(var M,U=0,j=S.i,K=S.j,W=S.S;R--;)M=W[j=c&j+1],U=U*n+W[c&(W[j]=W[K=c&K+M])+(W[K]=M)];return S.i=j,S.j=K,U})(n)}function d(b,v){return v.i=b.i,v.j=b.j,v.S=b.S.slice(),v}function h(b,v){var C=[],S=typeof b,k;if(v&&S=="object")for(k in b)try{C.push(h(b[k],v-1))}catch(I){}return C.length?C:S=="string"?b:b+"\0"}function x(b,v){for(var C=b+"",S,k=0;k<C.length;)v[c&k]=c&(S^=v[c&k]*19)+C.charCodeAt(k++);return y(v)}function g(){try{var b;return p&&(b=p.randomBytes)?b=b(n):(b=new Uint8Array(n),(e.crypto||e.msCrypto).getRandomValues(b)),y(b)}catch(S){var v=e.navigator,C=v&&v.plugins;return[+new Date,e,C,e.screen,y(t)]}}function y(b){return String.fromCharCode.apply(0,b)}if(x(r.random(),t),typeof jw=="object"&&jw.exports){jw.exports=f;try{p=sM()}catch(b){}}else typeof define=="function"&&define.amd?define(function(){return f}):r["seed"+i]=f})(typeof self!="undefined"?self:iM,[],Math)});var wx=Ut((nOt,lM)=>{var ont=KL(),snt=YL(),int=ZL(),ant=tM(),lnt=rM(),unt=oM(),Rp=aM();Rp.alea=ont;Rp.xor128=snt;Rp.xorwow=int;Rp.xorshift7=ant;Rp.xor4096=lnt;Rp.tychei=unt;lM.exports=Rp});var $B=Ut(()=>{});var EA=Ut((Lje,Ck)=>{(function(e){var t=/^\s+/,r=/\s+$/,n=0,o=e.round,s=e.min,i=e.max,a=e.random;function l($,G){if($=$||"",G=G||{},$ instanceof l)return $;if(!(this instanceof l))return new l($,G);var P=u($);this._originalInput=$,this._r=P.r,this._g=P.g,this._b=P.b,this._a=P.a,this._roundA=o(100*this._a)/100,this._format=G.format||P.format,this._gradientType=G.gradientType,this._r<1&&(this._r=o(this._r)),this._g<1&&(this._g=o(this._g)),this._b<1&&(this._b=o(this._b)),this._ok=P.ok,this._tc_id=n++}l.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var $=this.toRgb();return($.r*299+$.g*587+$.b*114)/1e3},getLuminance:function(){var $=this.toRgb(),G,P,ot,ct,pt,Ft;return G=$.r/255,P=$.g/255,ot=$.b/255,G<=.03928?ct=G/12.92:ct=e.pow((G+.055)/1.055,2.4),P<=.03928?pt=P/12.92:pt=e.pow((P+.055)/1.055,2.4),ot<=.03928?Ft=ot/12.92:Ft=e.pow((ot+.055)/1.055,2.4),.2126*ct+.7152*pt+.0722*Ft},setAlpha:function($){return this._a=Q($),this._roundA=o(100*this._a)/100,this},toHsv:function(){var $=m(this._r,this._g,this._b);return{h:$.h*360,s:$.s,v:$.v,a:this._a}},toHsvString:function(){var $=m(this._r,this._g,this._b),G=o($.h*360),P=o($.s*100),ot=o($.v*100);return this._a==1?"hsv("+G+", "+P+"%, "+ot+"%)":"hsva("+G+", "+P+"%, "+ot+"%, "+this._roundA+")"},toHsl:function(){var $=p(this._r,this._g,this._b);return{h:$.h*360,s:$.s,l:$.l,a:this._a}},toHslString:function(){var $=p(this._r,this._g,this._b),G=o($.h*360),P=o($.s*100),ot=o($.l*100);return this._a==1?"hsl("+G+", "+P+"%, "+ot+"%)":"hsla("+G+", "+P+"%, "+ot+"%, "+this._roundA+")"},toHex:function($){return h(this._r,this._g,this._b,$)},toHexString:function($){return"#"+this.toHex($)},toHex8:function($){return x(this._r,this._g,this._b,this._a,$)},toHex8String:function($){return"#"+this.toHex8($)},toRgb:function(){return{r:o(this._r),g:o(this._g),b:o(this._b),a:this._a}},toRgbString:function(){return this._a==1?"rgb("+o(this._r)+", "+o(this._g)+", "+o(this._b)+")":"rgba("+o(this._r)+", "+o(this._g)+", "+o(this._b)+", "+this._roundA+")"},toPercentageRgb:function(){return{r:o(Y(this._r,255)*100)+"%",g:o(Y(this._g,255)*100)+"%",b:o(Y(this._b,255)*100)+"%",a:this._a}},toPercentageRgbString:function(){return this._a==1?"rgb("+o(Y(this._r,255)*100)+"%, "+o(Y(this._g,255)*100)+"%, "+o(Y(this._b,255)*100)+"%)":"rgba("+o(Y(this._r,255)*100)+"%, "+o(Y(this._g,255)*100)+"%, "+o(Y(this._b,255)*100)+"%, "+this._roundA+")"},toName:function(){return this._a===0?"transparent":this._a<1?!1:q[h(this._r,this._g,this._b,!0)]||!1},toFilter:function($){var G="#"+g(this._r,this._g,this._b,this._a),P=G,ot=this._gradientType?"GradientType = 1, ":"";if($){var ct=l($);P="#"+g(ct._r,ct._g,ct._b,ct._a)}return"progid:DXImageTransform.Microsoft.gradient("+ot+"startColorstr="+G+",endColorstr="+P+")"},toString:function($){var G=!!$;$=$||this._format;var P=!1,ot=this._a<1&&this._a>=0,ct=!G&&ot&&($==="hex"||$==="hex6"||$==="hex3"||$==="hex4"||$==="hex8"||$==="name");return ct?$==="name"&&this._a===0?this.toName():this.toRgbString():($==="rgb"&&(P=this.toRgbString()),$==="prgb"&&(P=this.toPercentageRgbString()),($==="hex"||$==="hex6")&&(P=this.toHexString()),$==="hex3"&&(P=this.toHexString(!0)),$==="hex4"&&(P=this.toHex8String(!0)),$==="hex8"&&(P=this.toHex8String()),$==="name"&&(P=this.toName()),$==="hsl"&&(P=this.toHslString()),$==="hsv"&&(P=this.toHsvString()),P||this.toHexString())},clone:function(){return l(this.toString())},_applyModification:function($,G){var P=$.apply(null,[this].concat([].slice.call(G)));return this._r=P._r,this._g=P._g,this._b=P._b,this.setAlpha(P._a),this},lighten:function(){return this._applyModification(C,arguments)},brighten:function(){return this._applyModification(S,arguments)},darken:function(){return this._applyModification(k,arguments)},desaturate:function(){return this._applyModification(y,arguments)},saturate:function(){return this._applyModification(b,arguments)},greyscale:function(){return this._applyModification(v,arguments)},spin:function(){return this._applyModification(I,arguments)},_applyCombination:function($,G){return $.apply(null,[this].concat([].slice.call(G)))},analogous:function(){return this._applyCombination(j,arguments)},complement:function(){return this._applyCombination(D,arguments)},monochromatic:function(){return this._applyCombination(K,arguments)},splitcomplement:function(){return this._applyCombination(U,arguments)},triad:function(){return this._applyCombination(R,arguments)},tetrad:function(){return this._applyCombination(M,arguments)}},l.fromRatio=function($,G){if(typeof $=="object"){var P={};for(var ot in $)$.hasOwnProperty(ot)&&(ot==="a"?P[ot]=$[ot]:P[ot]=it($[ot]));$=P}return l($,G)};function u($){var G={r:0,g:0,b:0},P=1,ot=null,ct=null,pt=null,Ft=!1,ne=!1;return typeof $=="string"&&($=Wt($)),typeof $=="object"&&(St($.r)&&St($.g)&&St($.b)?(G=c($.r,$.g,$.b),Ft=!0,ne=String($.r).substr(-1)==="%"?"prgb":"rgb"):St($.h)&&St($.s)&&St($.v)?(ot=it($.s),ct=it($.v),G=d($.h,ot,ct),Ft=!0,ne="hsv"):St($.h)&&St($.s)&&St($.l)&&(ot=it($.s),pt=it($.l),G=f($.h,ot,pt),Ft=!0,ne="hsl"),$.hasOwnProperty("a")&&(P=$.a)),P=Q(P),{ok:Ft,format:$.format||ne,r:s(255,i(G.r,0)),g:s(255,i(G.g,0)),b:s(255,i(G.b,0)),a:P}}function c($,G,P){return{r:Y($,255)*255,g:Y(G,255)*255,b:Y(P,255)*255}}function p($,G,P){$=Y($,255),G=Y(G,255),P=Y(P,255);var ot=i($,G,P),ct=s($,G,P),pt,Ft,ne=(ot+ct)/2;if(ot==ct)pt=Ft=0;else{var Bt=ot-ct;switch(Ft=ne>.5?Bt/(2-ot-ct):Bt/(ot+ct),ot){case $:pt=(G-P)/Bt+(G<P?6:0);break;case G:pt=(P-$)/Bt+2;break;case P:pt=($-G)/Bt+4;break}pt/=6}return{h:pt,s:Ft,l:ne}}function f($,G,P){var ot,ct,pt;$=Y($,360),G=Y(G,100),P=Y(P,100);function Ft(Me,fr,mr){return mr<0&&(mr+=1),mr>1&&(mr-=1),mr<1/6?Me+(fr-Me)*6*mr:mr<1/2?fr:mr<2/3?Me+(fr-Me)*(2/3-mr)*6:Me}if(G===0)ot=ct=pt=P;else{var ne=P<.5?P*(1+G):P+G-P*G,Bt=2*P-ne;ot=Ft(Bt,ne,$+1/3),ct=Ft(Bt,ne,$),pt=Ft(Bt,ne,$-1/3)}return{r:ot*255,g:ct*255,b:pt*255}}function m($,G,P){$=Y($,255),G=Y(G,255),P=Y(P,255);var ot=i($,G,P),ct=s($,G,P),pt,Ft,ne=ot,Bt=ot-ct;if(Ft=ot===0?0:Bt/ot,ot==ct)pt=0;else{switch(ot){case $:pt=(G-P)/Bt+(G<P?6:0);break;case G:pt=(P-$)/Bt+2;break;case P:pt=($-G)/Bt+4;break}pt/=6}return{h:pt,s:Ft,v:ne}}function d($,G,P){$=Y($,360)*6,G=Y(G,100),P=Y(P,100);var ot=e.floor($),ct=$-ot,pt=P*(1-G),Ft=P*(1-ct*G),ne=P*(1-(1-ct)*G),Bt=ot%6,Me=[P,Ft,pt,pt,ne,P][Bt],fr=[ne,P,P,Ft,pt,pt][Bt],mr=[pt,pt,ne,P,P,Ft][Bt];return{r:Me*255,g:fr*255,b:mr*255}}function h($,G,P,ot){var ct=[ut(o($).toString(16)),ut(o(G).toString(16)),ut(o(P).toString(16))];return ot&&ct[0].charAt(0)==ct[0].charAt(1)&&ct[1].charAt(0)==ct[1].charAt(1)&&ct[2].charAt(0)==ct[2].charAt(1)?ct[0].charAt(0)+ct[1].charAt(0)+ct[2].charAt(0):ct.join("")}function x($,G,P,ot,ct){var pt=[ut(o($).toString(16)),ut(o(G).toString(16)),ut(o(P).toString(16)),ut(dt(ot))];return ct&&pt[0].charAt(0)==pt[0].charAt(1)&&pt[1].charAt(0)==pt[1].charAt(1)&&pt[2].charAt(0)==pt[2].charAt(1)&&pt[3].charAt(0)==pt[3].charAt(1)?pt[0].charAt(0)+pt[1].charAt(0)+pt[2].charAt(0)+pt[3].charAt(0):pt.join("")}function g($,G,P,ot){var ct=[ut(dt(ot)),ut(o($).toString(16)),ut(o(G).toString(16)),ut(o(P).toString(16))];return ct.join("")}l.equals=function($,G){return!$||!G?!1:l($).toRgbString()==l(G).toRgbString()},l.random=function(){return l.fromRatio({r:a(),g:a(),b:a()})};function y($,G){G=G===0?0:G||10;var P=l($).toHsl();return P.s-=G/100,P.s=nt(P.s),l(P)}function b($,G){G=G===0?0:G||10;var P=l($).toHsl();return P.s+=G/100,P.s=nt(P.s),l(P)}function v($){return l($).desaturate(100)}function C($,G){G=G===0?0:G||10;var P=l($).toHsl();return P.l+=G/100,P.l=nt(P.l),l(P)}function S($,G){G=G===0?0:G||10;var P=l($).toRgb();return P.r=i(0,s(255,P.r-o(255*-(G/100)))),P.g=i(0,s(255,P.g-o(255*-(G/100)))),P.b=i(0,s(255,P.b-o(255*-(G/100)))),l(P)}function k($,G){G=G===0?0:G||10;var P=l($).toHsl();return P.l-=G/100,P.l=nt(P.l),l(P)}function I($,G){var P=l($).toHsl(),ot=(P.h+G)%360;return P.h=ot<0?360+ot:ot,l(P)}function D($){var G=l($).toHsl();return G.h=(G.h+180)%360,l(G)}function R($){var G=l($).toHsl(),P=G.h;return[l($),l({h:(P+120)%360,s:G.s,l:G.l}),l({h:(P+240)%360,s:G.s,l:G.l})]}function M($){var G=l($).toHsl(),P=G.h;return[l($),l({h:(P+90)%360,s:G.s,l:G.l}),l({h:(P+180)%360,s:G.s,l:G.l}),l({h:(P+270)%360,s:G.s,l:G.l})]}function U($){var G=l($).toHsl(),P=G.h;return[l($),l({h:(P+72)%360,s:G.s,l:G.l}),l({h:(P+216)%360,s:G.s,l:G.l})]}function j($,G,P){G=G||6,P=P||30;var ot=l($).toHsl(),ct=360/P,pt=[l($)];for(ot.h=(ot.h-(ct*G>>1)+720)%360;--G;)ot.h=(ot.h+ct)%360,pt.push(l(ot));return pt}function K($,G){G=G||6;for(var P=l($).toHsv(),ot=P.h,ct=P.s,pt=P.v,Ft=[],ne=1/G;G--;)Ft.push(l({h:ot,s:ct,v:pt})),pt=(pt+ne)%1;return Ft}l.mix=function($,G,P){P=P===0?0:P||50;var ot=l($).toRgb(),ct=l(G).toRgb(),pt=P/100,Ft={r:(ct.r-ot.r)*pt+ot.r,g:(ct.g-ot.g)*pt+ot.g,b:(ct.b-ot.b)*pt+ot.b,a:(ct.a-ot.a)*pt+ot.a};return l(Ft)},l.readability=function($,G){var P=l($),ot=l(G);return(e.max(P.getLuminance(),ot.getLuminance())+.05)/(e.min(P.getLuminance(),ot.getLuminance())+.05)},l.isReadable=function($,G,P){var ot=l.readability($,G),ct,pt;switch(pt=!1,ct=Ht(P),ct.level+ct.size){case"AAsmall":case"AAAlarge":pt=ot>=4.5;break;case"AAlarge":pt=ot>=3;break;case"AAAsmall":pt=ot>=7;break}return pt},l.mostReadable=function($,G,P){var ot=null,ct=0,pt,Ft,ne,Bt;P=P||{},Ft=P.includeFallbackColors,ne=P.level,Bt=P.size;for(var Me=0;Me<G.length;Me++)pt=l.readability($,G[Me]),pt>ct&&(ct=pt,ot=l(G[Me]));return l.isReadable($,ot,{level:ne,size:Bt})||!Ft?ot:(P.includeFallbackColors=!1,l.mostReadable($,["#fff","#000"],P))};var W=l.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"},q=l.hexNames=X(W);function X($){var G={};for(var P in $)$.hasOwnProperty(P)&&(G[$[P]]=P);return G}function Q($){return $=parseFloat($),(isNaN($)||$<0||$>1)&&($=1),$}function Y($,G){at($)&&($="100%");var P=lt($);return $=s(G,i(0,parseFloat($))),P&&($=parseInt($*G,10)/100),e.abs($-G)<1e-6?1:$%G/parseFloat(G)}function nt($){return s(1,i(0,$))}function rt($){return parseInt($,16)}function at($){return typeof $=="string"&&$.indexOf(".")!=-1&&parseFloat($)===1}function lt($){return typeof $=="string"&&$.indexOf("%")!=-1}function ut($){return $.length==1?"0"+$:""+$}function it($){return $<=1&&($=$*100+"%"),$}function dt($){return e.round(parseFloat($)*255).toString(16)}function wt($){return rt($)/255}var bt=function(){var $="[-\\+]?\\d+%?",G="[-\\+]?\\d*\\.\\d+%?",P="(?:"+G+")|(?:"+$+")",ot="[\\s|\\(]+("+P+")[,|\\s]+("+P+")[,|\\s]+("+P+")\\s*\\)?",ct="[\\s|\\(]+("+P+")[,|\\s]+("+P+")[,|\\s]+("+P+")[,|\\s]+("+P+")\\s*\\)?";return{CSS_UNIT:new RegExp(P),rgb:new RegExp("rgb"+ot),rgba:new RegExp("rgba"+ct),hsl:new RegExp("hsl"+ot),hsla:new RegExp("hsla"+ct),hsv:new RegExp("hsv"+ot),hsva:new RegExp("hsva"+ct),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/}}();function St($){return!!bt.CSS_UNIT.exec($)}function Wt($){$=$.replace(t,"").replace(r,"").toLowerCase();var G=!1;if(W[$])$=W[$],G=!0;else if($=="transparent")return{r:0,g:0,b:0,a:0,format:"name"};var P;return(P=bt.rgb.exec($))?{r:P[1],g:P[2],b:P[3]}:(P=bt.rgba.exec($))?{r:P[1],g:P[2],b:P[3],a:P[4]}:(P=bt.hsl.exec($))?{h:P[1],s:P[2],l:P[3]}:(P=bt.hsla.exec($))?{h:P[1],s:P[2],l:P[3],a:P[4]}:(P=bt.hsv.exec($))?{h:P[1],s:P[2],v:P[3]}:(P=bt.hsva.exec($))?{h:P[1],s:P[2],v:P[3],a:P[4]}:(P=bt.hex8.exec($))?{r:rt(P[1]),g:rt(P[2]),b:rt(P[3]),a:wt(P[4]),format:G?"name":"hex8"}:(P=bt.hex6.exec($))?{r:rt(P[1]),g:rt(P[2]),b:rt(P[3]),format:G?"name":"hex"}:(P=bt.hex4.exec($))?{r:rt(P[1]+""+P[1]),g:rt(P[2]+""+P[2]),b:rt(P[3]+""+P[3]),a:wt(P[4]+""+P[4]),format:G?"name":"hex8"}:(P=bt.hex3.exec($))?{r:rt(P[1]+""+P[1]),g:rt(P[2]+""+P[2]),b:rt(P[3]+""+P[3]),format:G?"name":"hex"}:!1}function Ht($){var G,P;return $=$||{level:"AA",size:"small"},G=($.level||"AA").toUpperCase(),P=($.size||"small").toLowerCase(),G!=="AA"&&G!=="AAA"&&(G="AA"),P!=="small"&&P!=="large"&&(P="small"),{level:G,size:P}}typeof Ck!="undefined"&&Ck.exports?Ck.exports=l:typeof define=="function"&&define.amd?define(function(){return l}):window.tinycolor=l})(Math)});var qq=Ut(Ge=>{"use strict";function PA(e,t){var r=e.length;e.push(t);t:for(;0<r;){var n=r-1>>>1,o=e[n];if(0<Tk(o,t))e[n]=t,e[r]=o,r=n;else break t}}function Zs(e){return e.length===0?null:e[0]}function Ik(e){if(e.length===0)return null;var t=e[0],r=e.pop();if(r!==t){e[0]=r;t:for(var n=0,o=e.length,s=o>>>1;n<s;){var i=2*(n+1)-1,a=e[i],l=i+1,u=e[l];if(0>Tk(a,r))l<o&&0>Tk(u,a)?(e[n]=u,e[l]=r,n=l):(e[n]=a,e[i]=r,n=i);else if(l<o&&0>Tk(u,r))e[n]=u,e[l]=r,n=l;else break t}}return t}function Tk(e,t){var r=e.sortIndex-t.sortIndex;return r!==0?r:e.id-t.id}typeof performance=="object"&&typeof performance.now=="function"?(Lq=performance,Ge.unstable_now=function(){return Lq.now()}):($A=Date,Mq=$A.now(),Ge.unstable_now=function(){return $A.now()-Mq});var Lq,$A,Mq,Bi=[],yc=[],$gt=1,ws=null,Rn=3,Ek=!1,mf=!1,Ab=!1,Vq=typeof setTimeout=="function"?setTimeout:null,Wq=typeof clearTimeout=="function"?clearTimeout:null,zq=typeof setImmediate!="undefined"?setImmediate:null;typeof navigator!="undefined"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function LA(e){for(var t=Zs(yc);t!==null;){if(t.callback===null)Ik(yc);else if(t.startTime<=e)Ik(yc),t.sortIndex=t.expirationTime,PA(Bi,t);else break;t=Zs(yc)}}function MA(e){if(Ab=!1,LA(e),!mf)if(Zs(Bi)!==null)mf=!0,BA(zA);else{var t=Zs(yc);t!==null&&VA(MA,t.startTime-e)}}function zA(e,t){mf=!1,Ab&&(Ab=!1,Wq(Db),Db=-1),Ek=!0;var r=Rn;try{for(LA(t),ws=Zs(Bi);ws!==null&&(!(ws.expirationTime>t)||e&&!Hq());){var n=ws.callback;if(typeof n=="function"){ws.callback=null,Rn=ws.priorityLevel;var o=n(ws.expirationTime<=t);t=Ge.unstable_now(),typeof o=="function"?ws.callback=o:ws===Zs(Bi)&&Ik(Bi),LA(t)}else Ik(Bi);ws=Zs(Bi)}if(ws!==null)var s=!0;else{var i=Zs(yc);i!==null&&VA(MA,i.startTime-t),s=!1}return s}finally{ws=null,Rn=r,Ek=!1}}var _k=!1,Nk=null,Db=-1,Gq=5,Uq=-1;function Hq(){return!(Ge.unstable_now()-Uq<Gq)}function OA(){if(Nk!==null){var e=Ge.unstable_now();Uq=e;var t=!0;try{t=Nk(!0,e)}finally{t?_b():(_k=!1,Nk=null)}}else _k=!1}var _b;typeof zq=="function"?_b=function(){zq(OA)}:typeof MessageChannel!="undefined"?(FA=new MessageChannel,Bq=FA.port2,FA.port1.onmessage=OA,_b=function(){Bq.postMessage(null)}):_b=function(){Vq(OA,0)};var FA,Bq;function BA(e){Nk=e,_k||(_k=!0,_b())}function VA(e,t){Db=Vq(function(){e(Ge.unstable_now())},t)}Ge.unstable_IdlePriority=5;Ge.unstable_ImmediatePriority=1;Ge.unstable_LowPriority=4;Ge.unstable_NormalPriority=3;Ge.unstable_Profiling=null;Ge.unstable_UserBlockingPriority=2;Ge.unstable_cancelCallback=function(e){e.callback=null};Ge.unstable_continueExecution=function(){mf||Ek||(mf=!0,BA(zA))};Ge.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Gq=0<e?Math.floor(1e3/e):5};Ge.unstable_getCurrentPriorityLevel=function(){return Rn};Ge.unstable_getFirstCallbackNode=function(){return Zs(Bi)};Ge.unstable_next=function(e){switch(Rn){case 1:case 2:case 3:var t=3;break;default:t=Rn}var r=Rn;Rn=t;try{return e()}finally{Rn=r}};Ge.unstable_pauseExecution=function(){};Ge.unstable_requestPaint=function(){};Ge.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var r=Rn;Rn=e;try{return t()}finally{Rn=r}};Ge.unstable_scheduleCallback=function(e,t,r){var n=Ge.unstable_now();switch(typeof r=="object"&&r!==null?(r=r.delay,r=typeof r=="number"&&0<r?n+r:n):r=n,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return o=r+o,e={id:$gt++,callback:t,priorityLevel:e,startTime:r,expirationTime:o,sortIndex:-1},r>n?(e.sortIndex=r,PA(yc,e),Zs(Bi)===null&&e===Zs(yc)&&(Ab?(Wq(Db),Db=-1):Ab=!0,VA(MA,r-n))):(e.sortIndex=o,PA(Bi,e),mf||Ek||(mf=!0,BA(zA))),e};Ge.unstable_shouldYield=Hq;Ge.unstable_wrapCallback=function(e){var t=Rn;return function(){var r=Rn;Rn=t;try{return e.apply(this,arguments)}finally{Rn=r}}}});var Kq=Ut((lKe,jq)=>{"use strict";jq.exports=qq()});var tX=Ut(Wo=>{"use strict";var eK=oe(),Bo=Kq();function ft(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,r=1;r<arguments.length;r++)t+="&args[]="+encodeURIComponent(arguments[r]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var rK=new Set,Jb={};function Nf(e,t){Yh(e,t),Yh(e+"Capture",t)}function Yh(e,t){for(Jb[e]=t,e=0;e<t.length;e++)rK.add(t[e])}var Dl=!(typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"),cD=Object.prototype.hasOwnProperty,Ogt=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Xq={},Yq={};function Fgt(e){return cD.call(Yq,e)?!0:cD.call(Xq,e)?!1:Ogt.test(e)?Yq[e]=!0:(Xq[e]=!0,!1)}function Pgt(e,t,r,n){if(r!==null&&r.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return n?!1:r!==null?!r.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Lgt(e,t,r,n){if(t===null||typeof t=="undefined"||Pgt(e,t,r,n))return!0;if(n)return!1;if(r!==null)switch(r.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function Yn(e,t,r,n,o,s,i){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=n,this.attributeNamespace=o,this.mustUseProperty=r,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var yn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){yn[e]=new Yn(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];yn[t]=new Yn(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){yn[e]=new Yn(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){yn[e]=new Yn(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){yn[e]=new Yn(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){yn[e]=new Yn(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){yn[e]=new Yn(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){yn[e]=new Yn(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){yn[e]=new Yn(e,5,!1,e.toLowerCase(),null,!1,!1)});var rR=/[\-:]([a-z])/g;function nR(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(rR,nR);yn[t]=new Yn(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(rR,nR);yn[t]=new Yn(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(rR,nR);yn[t]=new Yn(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){yn[e]=new Yn(e,1,!1,e.toLowerCase(),null,!1,!1)});yn.xlinkHref=new Yn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){yn[e]=new Yn(e,1,!1,e.toLowerCase(),null,!0,!0)});function oR(e,t,r,n){var o=yn.hasOwnProperty(t)?yn[t]:null;(o!==null?o.type!==0:n||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Lgt(t,r,o,n)&&(r=null),n||o===null?Fgt(t)&&(r===null?e.removeAttribute(t):e.setAttribute(t,""+r)):o.mustUseProperty?e[o.propertyName]=r===null?o.type===3?!1:"":r:(t=o.attributeName,n=o.attributeNamespace,r===null?e.removeAttribute(t):(o=o.type,r=o===3||o===4&&r===!0?"":""+r,n?e.setAttributeNS(n,t,r):e.setAttribute(t,r))))}var Fl=eK.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Ak=Symbol.for("react.element"),Rh=Symbol.for("react.portal"),$h=Symbol.for("react.fragment"),sR=Symbol.for("react.strict_mode"),pD=Symbol.for("react.profiler"),nK=Symbol.for("react.provider"),oK=Symbol.for("react.context"),iR=Symbol.for("react.forward_ref"),fD=Symbol.for("react.suspense"),mD=Symbol.for("react.suspense_list"),aR=Symbol.for("react.memo"),vc=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");var sK=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Qq=Symbol.iterator;function Rb(e){return e===null||typeof e!="object"?null:(e=Qq&&e[Qq]||e["@@iterator"],typeof e=="function"?e:null)}var cr=Object.assign,WA;function Bb(e){if(WA===void 0)try{throw Error()}catch(r){var t=r.stack.trim().match(/\n( *(at )?)/);WA=t&&t[1]||""}return`
`+WA+e}var GA=!1;function UA(e,t){if(!e||GA)return"";GA=!0;var r=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var n=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){n=u}e.call(t.prototype)}else{try{throw Error()}catch(u){n=u}e()}}catch(u){if(u&&n&&typeof u.stack=="string"){for(var o=u.stack.split(`
`),s=n.stack.split(`
`),i=o.length-1,a=s.length-1;1<=i&&0<=a&&o[i]!==s[a];)a--;for(;1<=i&&0<=a;i--,a--)if(o[i]!==s[a]){if(i!==1||a!==1)do if(i--,a--,0>a||o[i]!==s[a]){var l=`
`+o[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=i&&0<=a);break}}}finally{GA=!1,Error.prepareStackTrace=r}return(e=e?e.displayName||e.name:"")?Bb(e):""}function Mgt(e){switch(e.tag){case 5:return Bb(e.type);case 16:return Bb("Lazy");case 13:return Bb("Suspense");case 19:return Bb("SuspenseList");case 0:case 2:case 15:return e=UA(e.type,!1),e;case 11:return e=UA(e.type.render,!1),e;case 1:return e=UA(e.type,!0),e;default:return""}}function dD(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case $h:return"Fragment";case Rh:return"Portal";case pD:return"Profiler";case sR:return"StrictMode";case fD:return"Suspense";case mD:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case oK:return(e.displayName||"Context")+".Consumer";case nK:return(e._context.displayName||"Context")+".Provider";case iR:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case aR:return t=e.displayName||null,t!==null?t:dD(e.type)||"Memo";case vc:t=e._payload,e=e._init;try{return dD(e(t))}catch(r){}}return null}function zgt(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return dD(t);case 8:return t===sR?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Oc(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function iK(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Bgt(e){var t=iK(e)?"checked":"value",r=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),n=""+e[t];if(!e.hasOwnProperty(t)&&typeof r!="undefined"&&typeof r.get=="function"&&typeof r.set=="function"){var o=r.get,s=r.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return o.call(this)},set:function(i){n=""+i,s.call(this,i)}}),Object.defineProperty(e,t,{enumerable:r.enumerable}),{getValue:function(){return n},setValue:function(i){n=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Dk(e){e._valueTracker||(e._valueTracker=Bgt(e))}function aK(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var r=t.getValue(),n="";return e&&(n=iK(e)?e.checked?"true":"false":e.value),e=n,e!==r?(t.setValue(e),!0):!1}function sT(e){if(e=e||(typeof document!="undefined"?document:void 0),typeof e=="undefined")return null;try{return e.activeElement||e.body}catch(t){return e.body}}function hD(e,t){var r=t.checked;return cr({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:r!=null?r:e._wrapperState.initialChecked})}function Zq(e,t){var r=t.defaultValue==null?"":t.defaultValue,n=t.checked!=null?t.checked:t.defaultChecked;r=Oc(t.value!=null?t.value:r),e._wrapperState={initialChecked:n,initialValue:r,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function lK(e,t){t=t.checked,t!=null&&oR(e,"checked",t,!1)}function gD(e,t){lK(e,t);var r=Oc(t.value),n=t.type;if(r!=null)n==="number"?(r===0&&e.value===""||e.value!=r)&&(e.value=""+r):e.value!==""+r&&(e.value=""+r);else if(n==="submit"||n==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?xD(e,t.type,r):t.hasOwnProperty("defaultValue")&&xD(e,t.type,Oc(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function Jq(e,t,r){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var n=t.type;if(!(n!=="submit"&&n!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,r||t===e.value||(e.value=t),e.defaultValue=t}r=e.name,r!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,r!==""&&(e.name=r)}function xD(e,t,r){(t!=="number"||sT(e.ownerDocument)!==e)&&(r==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+r&&(e.defaultValue=""+r))}var Vb=Array.isArray;function Uh(e,t,r,n){if(e=e.options,t){t={};for(var o=0;o<r.length;o++)t["$"+r[o]]=!0;for(r=0;r<e.length;r++)o=t.hasOwnProperty("$"+e[r].value),e[r].selected!==o&&(e[r].selected=o),o&&n&&(e[r].defaultSelected=!0)}else{for(r=""+Oc(r),t=null,o=0;o<e.length;o++){if(e[o].value===r){e[o].selected=!0,n&&(e[o].defaultSelected=!0);return}t!==null||e[o].disabled||(t=e[o])}t!==null&&(t.selected=!0)}}function yD(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(ft(91));return cr({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function tj(e,t){var r=t.value;if(r==null){if(r=t.children,t=t.defaultValue,r!=null){if(t!=null)throw Error(ft(92));if(Vb(r)){if(1<r.length)throw Error(ft(93));r=r[0]}t=r}t==null&&(t=""),r=t}e._wrapperState={initialValue:Oc(r)}}function uK(e,t){var r=Oc(t.value),n=Oc(t.defaultValue);r!=null&&(r=""+r,r!==e.value&&(e.value=r),t.defaultValue==null&&e.defaultValue!==r&&(e.defaultValue=r)),n!=null&&(e.defaultValue=""+n)}function ej(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function cK(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function bD(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?cK(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Rk,pK=function(e){return typeof MSApp!="undefined"&&MSApp.execUnsafeLocalFunction?function(t,r,n,o){MSApp.execUnsafeLocalFunction(function(){return e(t,r,n,o)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(Rk=Rk||document.createElement("div"),Rk.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Rk.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function t0(e,t){if(t){var r=e.firstChild;if(r&&r===e.lastChild&&r.nodeType===3){r.nodeValue=t;return}}e.textContent=t}var Ub={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Vgt=["Webkit","ms","Moz","O"];Object.keys(Ub).forEach(function(e){Vgt.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Ub[t]=Ub[e]})});function fK(e,t,r){return t==null||typeof t=="boolean"||t===""?"":r||typeof t!="number"||t===0||Ub.hasOwnProperty(e)&&Ub[e]?(""+t).trim():t+"px"}function mK(e,t){e=e.style;for(var r in t)if(t.hasOwnProperty(r)){var n=r.indexOf("--")===0,o=fK(r,t[r],n);r==="float"&&(r="cssFloat"),n?e.setProperty(r,o):e[r]=o}}var Wgt=cr({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function vD(e,t){if(t){if(Wgt[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(ft(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(ft(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(ft(61))}if(t.style!=null&&typeof t.style!="object")throw Error(ft(62))}}function wD(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var CD=null;function lR(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var SD=null,Hh=null,qh=null;function rj(e){if(e=y0(e)){if(typeof SD!="function")throw Error(ft(280));var t=e.stateNode;t&&(t=$T(t),SD(e.stateNode,e.type,t))}}function dK(e){Hh?qh?qh.push(e):qh=[e]:Hh=e}function hK(){if(Hh){var e=Hh,t=qh;if(qh=Hh=null,rj(e),t)for(e=0;e<t.length;e++)rj(t[e])}}function gK(e,t){return e(t)}function xK(){}var HA=!1;function yK(e,t,r){if(HA)return e(t,r);HA=!0;try{return gK(e,t,r)}finally{HA=!1,(Hh!==null||qh!==null)&&(xK(),hK())}}function e0(e,t){var r=e.stateNode;if(r===null)return null;var n=$T(r);if(n===null)return null;r=n[t];t:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(n=!n.disabled)||(e=e.type,n=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!n;break t;default:e=!1}if(e)return null;if(r&&typeof r!="function")throw Error(ft(231,t,typeof r));return r}var kD=!1;if(Dl)try{Ah={},Object.defineProperty(Ah,"passive",{get:function(){kD=!0}}),window.addEventListener("test",Ah,Ah),window.removeEventListener("test",Ah,Ah)}catch(e){kD=!1}var Ah;function Ggt(e,t,r,n,o,s,i,a,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(r,u)}catch(c){this.onError(c)}}var Hb=!1,iT=null,aT=!1,TD=null,Ugt={onError:function(e){Hb=!0,iT=e}};function Hgt(e,t,r,n,o,s,i,a,l){Hb=!1,iT=null,Ggt.apply(Ugt,arguments)}function qgt(e,t,r,n,o,s,i,a,l){if(Hgt.apply(this,arguments),Hb){if(Hb){var u=iT;Hb=!1,iT=null}else throw Error(ft(198));aT||(aT=!0,TD=u)}}function If(e){var t=e,r=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,(t.flags&4098)!==0&&(r=t.return),e=t.return;while(e)}return t.tag===3?r:null}function bK(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function nj(e){if(If(e)!==e)throw Error(ft(188))}function jgt(e){var t=e.alternate;if(!t){if(t=If(e),t===null)throw Error(ft(188));return t!==e?null:e}for(var r=e,n=t;;){var o=r.return;if(o===null)break;var s=o.alternate;if(s===null){if(n=o.return,n!==null){r=n;continue}break}if(o.child===s.child){for(s=o.child;s;){if(s===r)return nj(o),e;if(s===n)return nj(o),t;s=s.sibling}throw Error(ft(188))}if(r.return!==n.return)r=o,n=s;else{for(var i=!1,a=o.child;a;){if(a===r){i=!0,r=o,n=s;break}if(a===n){i=!0,n=o,r=s;break}a=a.sibling}if(!i){for(a=s.child;a;){if(a===r){i=!0,r=s,n=o;break}if(a===n){i=!0,n=s,r=o;break}a=a.sibling}if(!i)throw Error(ft(189))}}if(r.alternate!==n)throw Error(ft(190))}if(r.tag!==3)throw Error(ft(188));return r.stateNode.current===r?e:t}function vK(e){return e=jgt(e),e!==null?wK(e):null}function wK(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=wK(e);if(t!==null)return t;e=e.sibling}return null}var CK=Bo.unstable_scheduleCallback,oj=Bo.unstable_cancelCallback,Kgt=Bo.unstable_shouldYield,Xgt=Bo.unstable_requestPaint,kr=Bo.unstable_now,Ygt=Bo.unstable_getCurrentPriorityLevel,uR=Bo.unstable_ImmediatePriority,SK=Bo.unstable_UserBlockingPriority,lT=Bo.unstable_NormalPriority,Qgt=Bo.unstable_LowPriority,kK=Bo.unstable_IdlePriority,_T=null,Ui=null;function Zgt(e){if(Ui&&typeof Ui.onCommitFiberRoot=="function")try{Ui.onCommitFiberRoot(_T,e,void 0,(e.current.flags&128)===128)}catch(t){}}var ni=Math.clz32?Math.clz32:ext,Jgt=Math.log,txt=Math.LN2;function ext(e){return e>>>=0,e===0?32:31-(Jgt(e)/txt|0)|0}var $k=64,Ok=4194304;function Wb(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function uT(e,t){var r=e.pendingLanes;if(r===0)return 0;var n=0,o=e.suspendedLanes,s=e.pingedLanes,i=r&268435455;if(i!==0){var a=i&~o;a!==0?n=Wb(a):(s&=i,s!==0&&(n=Wb(s)))}else i=r&~o,i!==0?n=Wb(i):s!==0&&(n=Wb(s));if(n===0)return 0;if(t!==0&&t!==n&&(t&o)===0&&(o=n&-n,s=t&-t,o>=s||o===16&&(s&4194240)!==0))return t;if((n&4)!==0&&(n|=r&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=n;0<t;)r=31-ni(t),o=1<<r,n|=e[r],t&=~o;return n}function rxt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function nxt(e,t){for(var r=e.suspendedLanes,n=e.pingedLanes,o=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-ni(s),a=1<<i,l=o[i];l===-1?((a&r)===0||(a&n)!==0)&&(o[i]=rxt(a,t)):l<=t&&(e.expiredLanes|=a),s&=~a}}function ND(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function TK(){var e=$k;return $k<<=1,($k&4194240)===0&&($k=64),e}function qA(e){for(var t=[],r=0;31>r;r++)t.push(e);return t}function g0(e,t,r){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-ni(t),e[t]=r}function oxt(e,t){var r=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var n=e.eventTimes;for(e=e.expirationTimes;0<r;){var o=31-ni(r),s=1<<o;t[o]=0,n[o]=-1,e[o]=-1,r&=~s}}function cR(e,t){var r=e.entangledLanes|=t;for(e=e.entanglements;r;){var n=31-ni(r),o=1<<n;o&t|e[n]&t&&(e[n]|=t),r&=~o}}var Te=0;function NK(e){return e&=-e,1<e?4<e?(e&268435455)!==0?16:536870912:4:1}var IK,pR,EK,_K,AK,ID=!1,Fk=[],Nc=null,Ic=null,Ec=null,r0=new Map,n0=new Map,Cc=[],sxt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function sj(e,t){switch(e){case"focusin":case"focusout":Nc=null;break;case"dragenter":case"dragleave":Ic=null;break;case"mouseover":case"mouseout":Ec=null;break;case"pointerover":case"pointerout":r0.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":n0.delete(t.pointerId)}}function $b(e,t,r,n,o,s){return e===null||e.nativeEvent!==s?(e={blockedOn:t,domEventName:r,eventSystemFlags:n,nativeEvent:s,targetContainers:[o]},t!==null&&(t=y0(t),t!==null&&pR(t)),e):(e.eventSystemFlags|=n,t=e.targetContainers,o!==null&&t.indexOf(o)===-1&&t.push(o),e)}function ixt(e,t,r,n,o){switch(t){case"focusin":return Nc=$b(Nc,e,t,r,n,o),!0;case"dragenter":return Ic=$b(Ic,e,t,r,n,o),!0;case"mouseover":return Ec=$b(Ec,e,t,r,n,o),!0;case"pointerover":var s=o.pointerId;return r0.set(s,$b(r0.get(s)||null,e,t,r,n,o)),!0;case"gotpointercapture":return s=o.pointerId,n0.set(s,$b(n0.get(s)||null,e,t,r,n,o)),!0}return!1}function DK(e){var t=gf(e.target);if(t!==null){var r=If(t);if(r!==null){if(t=r.tag,t===13){if(t=bK(r),t!==null){e.blockedOn=t,AK(e.priority,function(){EK(r)});return}}else if(t===3&&r.stateNode.current.memoizedState.isDehydrated){e.blockedOn=r.tag===3?r.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Xk(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var r=ED(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(r===null){r=e.nativeEvent;var n=new r.constructor(r.type,r);CD=n,r.target.dispatchEvent(n),CD=null}else return t=y0(r),t!==null&&pR(t),e.blockedOn=r,!1;t.shift()}return!0}function ij(e,t,r){Xk(e)&&r.delete(t)}function axt(){ID=!1,Nc!==null&&Xk(Nc)&&(Nc=null),Ic!==null&&Xk(Ic)&&(Ic=null),Ec!==null&&Xk(Ec)&&(Ec=null),r0.forEach(ij),n0.forEach(ij)}function Ob(e,t){e.blockedOn===t&&(e.blockedOn=null,ID||(ID=!0,Bo.unstable_scheduleCallback(Bo.unstable_NormalPriority,axt)))}function o0(e){function t(o){return Ob(o,e)}if(0<Fk.length){Ob(Fk[0],e);for(var r=1;r<Fk.length;r++){var n=Fk[r];n.blockedOn===e&&(n.blockedOn=null)}}for(Nc!==null&&Ob(Nc,e),Ic!==null&&Ob(Ic,e),Ec!==null&&Ob(Ec,e),r0.forEach(t),n0.forEach(t),r=0;r<Cc.length;r++)n=Cc[r],n.blockedOn===e&&(n.blockedOn=null);for(;0<Cc.length&&(r=Cc[0],r.blockedOn===null);)DK(r),r.blockedOn===null&&Cc.shift()}var jh=Fl.ReactCurrentBatchConfig,cT=!0;function lxt(e,t,r,n){var o=Te,s=jh.transition;jh.transition=null;try{Te=1,fR(e,t,r,n)}finally{Te=o,jh.transition=s}}function uxt(e,t,r,n){var o=Te,s=jh.transition;jh.transition=null;try{Te=4,fR(e,t,r,n)}finally{Te=o,jh.transition=s}}function fR(e,t,r,n){if(cT){var o=ED(e,t,r,n);if(o===null)JA(e,t,n,pT,r),sj(e,n);else if(ixt(o,e,t,r,n))n.stopPropagation();else if(sj(e,n),t&4&&-1<sxt.indexOf(e)){for(;o!==null;){var s=y0(o);if(s!==null&&IK(s),s=ED(e,t,r,n),s===null&&JA(e,t,n,pT,r),s===o)break;o=s}o!==null&&n.stopPropagation()}else JA(e,t,n,null,r)}}var pT=null;function ED(e,t,r,n){if(pT=null,e=lR(n),e=gf(e),e!==null)if(t=If(e),t===null)e=null;else if(r=t.tag,r===13){if(e=bK(t),e!==null)return e;e=null}else if(r===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return pT=e,null}function RK(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ygt()){case uR:return 1;case SK:return 4;case lT:case Qgt:return 16;case kK:return 536870912;default:return 16}default:return 16}}var kc=null,mR=null,Yk=null;function $K(){if(Yk)return Yk;var e,t=mR,r=t.length,n,o="value"in kc?kc.value:kc.textContent,s=o.length;for(e=0;e<r&&t[e]===o[e];e++);var i=r-e;for(n=1;n<=i&&t[r-n]===o[s-n];n++);return Yk=o.slice(e,1<n?1-n:void 0)}function Qk(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Pk(){return!0}function aj(){return!1}function Vo(e){function t(r,n,o,s,i){this._reactName=r,this._targetInst=o,this.type=n,this.nativeEvent=s,this.target=i,this.currentTarget=null;for(var a in e)e.hasOwnProperty(a)&&(r=e[a],this[a]=r?r(s):s[a]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?Pk:aj,this.isPropagationStopped=aj,this}return cr(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var r=this.nativeEvent;r&&(r.preventDefault?r.preventDefault():typeof r.returnValue!="unknown"&&(r.returnValue=!1),this.isDefaultPrevented=Pk)},stopPropagation:function(){var r=this.nativeEvent;r&&(r.stopPropagation?r.stopPropagation():typeof r.cancelBubble!="unknown"&&(r.cancelBubble=!0),this.isPropagationStopped=Pk)},persist:function(){},isPersistent:Pk}),t}var ng={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dR=Vo(ng),x0=cr({},ng,{view:0,detail:0}),cxt=Vo(x0),jA,KA,Fb,AT=cr({},x0,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:hR,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Fb&&(Fb&&e.type==="mousemove"?(jA=e.screenX-Fb.screenX,KA=e.screenY-Fb.screenY):KA=jA=0,Fb=e),jA)},movementY:function(e){return"movementY"in e?e.movementY:KA}}),lj=Vo(AT),pxt=cr({},AT,{dataTransfer:0}),fxt=Vo(pxt),mxt=cr({},x0,{relatedTarget:0}),XA=Vo(mxt),dxt=cr({},ng,{animationName:0,elapsedTime:0,pseudoElement:0}),hxt=Vo(dxt),gxt=cr({},ng,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),xxt=Vo(gxt),yxt=cr({},ng,{data:0}),uj=Vo(yxt),bxt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},vxt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},wxt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Cxt(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=wxt[e])?!!t[e]:!1}function hR(){return Cxt}var Sxt=cr({},x0,{key:function(e){if(e.key){var t=bxt[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Qk(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?vxt[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:hR,charCode:function(e){return e.type==="keypress"?Qk(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Qk(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),kxt=Vo(Sxt),Txt=cr({},AT,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),cj=Vo(Txt),Nxt=cr({},x0,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:hR}),Ixt=Vo(Nxt),Ext=cr({},ng,{propertyName:0,elapsedTime:0,pseudoElement:0}),_xt=Vo(Ext),Axt=cr({},AT,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Dxt=Vo(Axt),Rxt=[9,13,27,32],gR=Dl&&"CompositionEvent"in window,qb=null;Dl&&"documentMode"in document&&(qb=document.documentMode);var $xt=Dl&&"TextEvent"in window&&!qb,OK=Dl&&(!gR||qb&&8<qb&&11>=qb),pj=String.fromCharCode(32),fj=!1;function FK(e,t){switch(e){case"keyup":return Rxt.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function PK(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Oh=!1;function Oxt(e,t){switch(e){case"compositionend":return PK(t);case"keypress":return t.which!==32?null:(fj=!0,pj);case"textInput":return e=t.data,e===pj&&fj?null:e;default:return null}}function Fxt(e,t){if(Oh)return e==="compositionend"||!gR&&FK(e,t)?(e=$K(),Yk=mR=kc=null,Oh=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return OK&&t.locale!=="ko"?null:t.data;default:return null}}var Pxt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function mj(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!Pxt[e.type]:t==="textarea"}function LK(e,t,r,n){dK(n),t=fT(t,"onChange"),0<t.length&&(r=new dR("onChange","change",null,r,n),e.push({event:r,listeners:t}))}var jb=null,s0=null;function Lxt(e){KK(e,0)}function DT(e){var t=Lh(e);if(aK(t))return e}function Mxt(e,t){if(e==="change")return t}var MK=!1;Dl&&(Dl?(Mk="oninput"in document,Mk||(YA=document.createElement("div"),YA.setAttribute("oninput","return;"),Mk=typeof YA.oninput=="function"),Lk=Mk):Lk=!1,MK=Lk&&(!document.documentMode||9<document.documentMode));var Lk,Mk,YA;function dj(){jb&&(jb.detachEvent("onpropertychange",zK),s0=jb=null)}function zK(e){if(e.propertyName==="value"&&DT(s0)){var t=[];LK(t,s0,e,lR(e)),yK(Lxt,t)}}function zxt(e,t,r){e==="focusin"?(dj(),jb=t,s0=r,jb.attachEvent("onpropertychange",zK)):e==="focusout"&&dj()}function Bxt(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return DT(s0)}function Vxt(e,t){if(e==="click")return DT(t)}function Wxt(e,t){if(e==="input"||e==="change")return DT(t)}function Gxt(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var si=typeof Object.is=="function"?Object.is:Gxt;function i0(e,t){if(si(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(n=0;n<r.length;n++){var o=r[n];if(!cD.call(t,o)||!si(e[o],t[o]))return!1}return!0}function hj(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function gj(e,t){var r=hj(e);e=0;for(var n;r;){if(r.nodeType===3){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}t:{for(;r;){if(r.nextSibling){r=r.nextSibling;break t}r=r.parentNode}r=void 0}r=hj(r)}}function BK(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?BK(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function VK(){for(var e=window,t=sT();t instanceof e.HTMLIFrameElement;){try{var r=typeof t.contentWindow.location.href=="string"}catch(n){r=!1}if(r)e=t.contentWindow;else break;t=sT(e.document)}return t}function xR(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function Uxt(e){var t=VK(),r=e.focusedElem,n=e.selectionRange;if(t!==r&&r&&r.ownerDocument&&BK(r.ownerDocument.documentElement,r)){if(n!==null&&xR(r)){if(t=n.start,e=n.end,e===void 0&&(e=t),"selectionStart"in r)r.selectionStart=t,r.selectionEnd=Math.min(e,r.value.length);else if(e=(t=r.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var o=r.textContent.length,s=Math.min(n.start,o);n=n.end===void 0?s:Math.min(n.end,o),!e.extend&&s>n&&(o=n,n=s,s=o),o=gj(r,s);var i=gj(r,n);o&&i&&(e.rangeCount!==1||e.anchorNode!==o.node||e.anchorOffset!==o.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(t=t.createRange(),t.setStart(o.node,o.offset),e.removeAllRanges(),s>n?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}}for(t=[],e=r;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof r.focus=="function"&&r.focus(),r=0;r<t.length;r++)e=t[r],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Hxt=Dl&&"documentMode"in document&&11>=document.documentMode,Fh=null,_D=null,Kb=null,AD=!1;function xj(e,t,r){var n=r.window===r?r.document:r.nodeType===9?r:r.ownerDocument;AD||Fh==null||Fh!==sT(n)||(n=Fh,"selectionStart"in n&&xR(n)?n={start:n.selectionStart,end:n.selectionEnd}:(n=(n.ownerDocument&&n.ownerDocument.defaultView||window).getSelection(),n={anchorNode:n.anchorNode,anchorOffset:n.anchorOffset,focusNode:n.focusNode,focusOffset:n.focusOffset}),Kb&&i0(Kb,n)||(Kb=n,n=fT(_D,"onSelect"),0<n.length&&(t=new dR("onSelect","select",null,t,r),e.push({event:t,listeners:n}),t.target=Fh)))}function zk(e,t){var r={};return r[e.toLowerCase()]=t.toLowerCase(),r["Webkit"+e]="webkit"+t,r["Moz"+e]="moz"+t,r}var Ph={animationend:zk("Animation","AnimationEnd"),animationiteration:zk("Animation","AnimationIteration"),animationstart:zk("Animation","AnimationStart"),transitionend:zk("Transition","TransitionEnd")},QA={},WK={};Dl&&(WK=document.createElement("div").style,"AnimationEvent"in window||(delete Ph.animationend.animation,delete Ph.animationiteration.animation,delete Ph.animationstart.animation),"TransitionEvent"in window||delete Ph.transitionend.transition);function RT(e){if(QA[e])return QA[e];if(!Ph[e])return e;var t=Ph[e],r;for(r in t)if(t.hasOwnProperty(r)&&r in WK)return QA[e]=t[r];return e}var GK=RT("animationend"),UK=RT("animationiteration"),HK=RT("animationstart"),qK=RT("transitionend"),jK=new Map,yj="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Pc(e,t){jK.set(e,t),Nf(t,[e])}for(Bk=0;Bk<yj.length;Bk++)Vk=yj[Bk],bj=Vk.toLowerCase(),vj=Vk[0].toUpperCase()+Vk.slice(1),Pc(bj,"on"+vj);var Vk,bj,vj,Bk;Pc(GK,"onAnimationEnd");Pc(UK,"onAnimationIteration");Pc(HK,"onAnimationStart");Pc("dblclick","onDoubleClick");Pc("focusin","onFocus");Pc("focusout","onBlur");Pc(qK,"onTransitionEnd");Yh("onMouseEnter",["mouseout","mouseover"]);Yh("onMouseLeave",["mouseout","mouseover"]);Yh("onPointerEnter",["pointerout","pointerover"]);Yh("onPointerLeave",["pointerout","pointerover"]);Nf("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Nf("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Nf("onBeforeInput",["compositionend","keypress","textInput","paste"]);Nf("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Nf("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Nf("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Gb="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),qxt=new Set("cancel close invalid load scroll toggle".split(" ").concat(Gb));function wj(e,t,r){var n=e.type||"unknown-event";e.currentTarget=r,qgt(n,t,void 0,e),e.currentTarget=null}function KK(e,t){t=(t&4)!==0;for(var r=0;r<e.length;r++){var n=e[r],o=n.event;n=n.listeners;t:{var s=void 0;if(t)for(var i=n.length-1;0<=i;i--){var a=n[i],l=a.instance,u=a.currentTarget;if(a=a.listener,l!==s&&o.isPropagationStopped())break t;wj(o,a,u),s=l}else for(i=0;i<n.length;i++){if(a=n[i],l=a.instance,u=a.currentTarget,a=a.listener,l!==s&&o.isPropagationStopped())break t;wj(o,a,u),s=l}}}if(aT)throw e=TD,aT=!1,TD=null,e}function Qe(e,t){var r=t[FD];r===void 0&&(r=t[FD]=new Set);var n=e+"__bubble";r.has(n)||(XK(t,e,2,!1),r.add(n))}function ZA(e,t,r){var n=0;t&&(n|=4),XK(r,e,n,t)}var Wk="_reactListening"+Math.random().toString(36).slice(2);function a0(e){if(!e[Wk]){e[Wk]=!0,rK.forEach(function(r){r!=="selectionchange"&&(qxt.has(r)||ZA(r,!1,e),ZA(r,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Wk]||(t[Wk]=!0,ZA("selectionchange",!1,t))}}function XK(e,t,r,n){switch(RK(t)){case 1:var o=lxt;break;case 4:o=uxt;break;default:o=fR}r=o.bind(null,t,r,e),o=void 0,!kD||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(o=!0),n?o!==void 0?e.addEventListener(t,r,{capture:!0,passive:o}):e.addEventListener(t,r,!0):o!==void 0?e.addEventListener(t,r,{passive:o}):e.addEventListener(t,r,!1)}function JA(e,t,r,n,o){var s=n;if((t&1)===0&&(t&2)===0&&n!==null)t:for(;;){if(n===null)return;var i=n.tag;if(i===3||i===4){var a=n.stateNode.containerInfo;if(a===o||a.nodeType===8&&a.parentNode===o)break;if(i===4)for(i=n.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===o||l.nodeType===8&&l.parentNode===o))return;i=i.return}for(;a!==null;){if(i=gf(a),i===null)return;if(l=i.tag,l===5||l===6){n=s=i;continue t}a=a.parentNode}}n=n.return}yK(function(){var u=s,c=lR(r),p=[];t:{var f=jK.get(e);if(f!==void 0){var m=dR,d=e;switch(e){case"keypress":if(Qk(r)===0)break t;case"keydown":case"keyup":m=kxt;break;case"focusin":d="focus",m=XA;break;case"focusout":d="blur",m=XA;break;case"beforeblur":case"afterblur":m=XA;break;case"click":if(r.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":m=lj;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":m=fxt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":m=Ixt;break;case GK:case UK:case HK:m=hxt;break;case qK:m=_xt;break;case"scroll":m=cxt;break;case"wheel":m=Dxt;break;case"copy":case"cut":case"paste":m=xxt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":m=cj}var h=(t&4)!==0,x=!h&&e==="scroll",g=h?f!==null?f+"Capture":null:f;h=[];for(var y=u,b;y!==null;){b=y;var v=b.stateNode;if(b.tag===5&&v!==null&&(b=v,g!==null&&(v=e0(y,g),v!=null&&h.push(l0(y,v,b)))),x)break;y=y.return}0<h.length&&(f=new m(f,d,null,r,c),p.push({event:f,listeners:h}))}}if((t&7)===0){t:{if(f=e==="mouseover"||e==="pointerover",m=e==="mouseout"||e==="pointerout",f&&r!==CD&&(d=r.relatedTarget||r.fromElement)&&(gf(d)||d[Rl]))break t;if((m||f)&&(f=c.window===c?c:(f=c.ownerDocument)?f.defaultView||f.parentWindow:window,m?(d=r.relatedTarget||r.toElement,m=u,d=d?gf(d):null,d!==null&&(x=If(d),d!==x||d.tag!==5&&d.tag!==6)&&(d=null)):(m=null,d=u),m!==d)){if(h=lj,v="onMouseLeave",g="onMouseEnter",y="mouse",(e==="pointerout"||e==="pointerover")&&(h=cj,v="onPointerLeave",g="onPointerEnter",y="pointer"),x=m==null?f:Lh(m),b=d==null?f:Lh(d),f=new h(v,y+"leave",m,r,c),f.target=x,f.relatedTarget=b,v=null,gf(c)===u&&(h=new h(g,y+"enter",d,r,c),h.target=b,h.relatedTarget=x,v=h),x=v,m&&d)e:{for(h=m,g=d,y=0,b=h;b;b=Dh(b))y++;for(b=0,v=g;v;v=Dh(v))b++;for(;0<y-b;)h=Dh(h),y--;for(;0<b-y;)g=Dh(g),b--;for(;y--;){if(h===g||g!==null&&h===g.alternate)break e;h=Dh(h),g=Dh(g)}h=null}else h=null;m!==null&&Cj(p,f,m,h,!1),d!==null&&x!==null&&Cj(p,x,d,h,!0)}}t:{if(f=u?Lh(u):window,m=f.nodeName&&f.nodeName.toLowerCase(),m==="select"||m==="input"&&f.type==="file")var C=Mxt;else if(mj(f))if(MK)C=Wxt;else{C=Bxt;var S=zxt}else(m=f.nodeName)&&m.toLowerCase()==="input"&&(f.type==="checkbox"||f.type==="radio")&&(C=Vxt);if(C&&(C=C(e,u))){LK(p,C,r,c);break t}S&&S(e,f,u),e==="focusout"&&(S=f._wrapperState)&&S.controlled&&f.type==="number"&&xD(f,"number",f.value)}switch(S=u?Lh(u):window,e){case"focusin":(mj(S)||S.contentEditable==="true")&&(Fh=S,_D=u,Kb=null);break;case"focusout":Kb=_D=Fh=null;break;case"mousedown":AD=!0;break;case"contextmenu":case"mouseup":case"dragend":AD=!1,xj(p,r,c);break;case"selectionchange":if(Hxt)break;case"keydown":case"keyup":xj(p,r,c)}var k;if(gR)t:{switch(e){case"compositionstart":var I="onCompositionStart";break t;case"compositionend":I="onCompositionEnd";break t;case"compositionupdate":I="onCompositionUpdate";break t}I=void 0}else Oh?FK(e,r)&&(I="onCompositionEnd"):e==="keydown"&&r.keyCode===229&&(I="onCompositionStart");I&&(OK&&r.locale!=="ko"&&(Oh||I!=="onCompositionStart"?I==="onCompositionEnd"&&Oh&&(k=$K()):(kc=c,mR="value"in kc?kc.value:kc.textContent,Oh=!0)),S=fT(u,I),0<S.length&&(I=new uj(I,e,null,r,c),p.push({event:I,listeners:S}),k?I.data=k:(k=PK(r),k!==null&&(I.data=k)))),(k=$xt?Oxt(e,r):Fxt(e,r))&&(u=fT(u,"onBeforeInput"),0<u.length&&(c=new uj("onBeforeInput","beforeinput",null,r,c),p.push({event:c,listeners:u}),c.data=k))}KK(p,t)})}function l0(e,t,r){return{instance:e,listener:t,currentTarget:r}}function fT(e,t){for(var r=t+"Capture",n=[];e!==null;){var o=e,s=o.stateNode;o.tag===5&&s!==null&&(o=s,s=e0(e,r),s!=null&&n.unshift(l0(e,s,o)),s=e0(e,t),s!=null&&n.push(l0(e,s,o))),e=e.return}return n}function Dh(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function Cj(e,t,r,n,o){for(var s=t._reactName,i=[];r!==null&&r!==n;){var a=r,l=a.alternate,u=a.stateNode;if(l!==null&&l===n)break;a.tag===5&&u!==null&&(a=u,o?(l=e0(r,s),l!=null&&i.unshift(l0(r,l,a))):o||(l=e0(r,s),l!=null&&i.push(l0(r,l,a)))),r=r.return}i.length!==0&&e.push({event:t,listeners:i})}var jxt=/\r\n?/g,Kxt=/\u0000|\uFFFD/g;function Sj(e){return(typeof e=="string"?e:""+e).replace(jxt,`
`).replace(Kxt,"")}function Gk(e,t,r){if(t=Sj(t),Sj(e)!==t&&r)throw Error(ft(425))}function mT(){}var DD=null,RD=null;function $D(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var OD=typeof setTimeout=="function"?setTimeout:void 0,Xxt=typeof clearTimeout=="function"?clearTimeout:void 0,kj=typeof Promise=="function"?Promise:void 0,Yxt=typeof queueMicrotask=="function"?queueMicrotask:typeof kj!="undefined"?function(e){return kj.resolve(null).then(e).catch(Qxt)}:OD;function Qxt(e){setTimeout(function(){throw e})}function tD(e,t){var r=t,n=0;do{var o=r.nextSibling;if(e.removeChild(r),o&&o.nodeType===8)if(r=o.data,r==="/$"){if(n===0){e.removeChild(o),o0(t);return}n--}else r!=="$"&&r!=="$?"&&r!=="$!"||n++;r=o}while(r);o0(t)}function _c(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function Tj(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var r=e.data;if(r==="$"||r==="$!"||r==="$?"){if(t===0)return e;t--}else r==="/$"&&t++}e=e.previousSibling}return null}var og=Math.random().toString(36).slice(2),Gi="__reactFiber$"+og,u0="__reactProps$"+og,Rl="__reactContainer$"+og,FD="__reactEvents$"+og,Zxt="__reactListeners$"+og,Jxt="__reactHandles$"+og;function gf(e){var t=e[Gi];if(t)return t;for(var r=e.parentNode;r;){if(t=r[Rl]||r[Gi]){if(r=t.alternate,t.child!==null||r!==null&&r.child!==null)for(e=Tj(e);e!==null;){if(r=e[Gi])return r;e=Tj(e)}return t}e=r,r=e.parentNode}return null}function y0(e){return e=e[Gi]||e[Rl],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Lh(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(ft(33))}function $T(e){return e[u0]||null}var PD=[],Mh=-1;function Lc(e){return{current:e}}function Ze(e){0>Mh||(e.current=PD[Mh],PD[Mh]=null,Mh--)}function Ue(e,t){Mh++,PD[Mh]=e.current,e.current=t}var Fc={},Pn=Lc(Fc),wo=Lc(!1),wf=Fc;function Qh(e,t){var r=e.type.contextTypes;if(!r)return Fc;var n=e.stateNode;if(n&&n.__reactInternalMemoizedUnmaskedChildContext===t)return n.__reactInternalMemoizedMaskedChildContext;var o={},s;for(s in r)o[s]=t[s];return n&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=o),o}function Co(e){return e=e.childContextTypes,e!=null}function dT(){Ze(wo),Ze(Pn)}function Nj(e,t,r){if(Pn.current!==Fc)throw Error(ft(168));Ue(Pn,t),Ue(wo,r)}function YK(e,t,r){var n=e.stateNode;if(t=t.childContextTypes,typeof n.getChildContext!="function")return r;n=n.getChildContext();for(var o in n)if(!(o in t))throw Error(ft(108,zgt(e)||"Unknown",o));return cr({},r,n)}function hT(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Fc,wf=Pn.current,Ue(Pn,e),Ue(wo,wo.current),!0}function Ij(e,t,r){var n=e.stateNode;if(!n)throw Error(ft(169));r?(e=YK(e,t,wf),n.__reactInternalMemoizedMergedChildContext=e,Ze(wo),Ze(Pn),Ue(Pn,e)):Ze(wo),Ue(wo,r)}var Il=null,OT=!1,eD=!1;function QK(e){Il===null?Il=[e]:Il.push(e)}function tyt(e){OT=!0,QK(e)}function Mc(){if(!eD&&Il!==null){eD=!0;var e=0,t=Te;try{var r=Il;for(Te=1;e<r.length;e++){var n=r[e];do n=n(!0);while(n!==null)}Il=null,OT=!1}catch(o){throw Il!==null&&(Il=Il.slice(e+1)),CK(uR,Mc),o}finally{Te=t,eD=!1}}return null}var zh=[],Bh=0,gT=null,xT=0,Cs=[],Ss=0,Cf=null,El=1,_l="";function df(e,t){zh[Bh++]=xT,zh[Bh++]=gT,gT=e,xT=t}function ZK(e,t,r){Cs[Ss++]=El,Cs[Ss++]=_l,Cs[Ss++]=Cf,Cf=e;var n=El;e=_l;var o=32-ni(n)-1;n&=~(1<<o),r+=1;var s=32-ni(t)+o;if(30<s){var i=o-o%5;s=(n&(1<<i)-1).toString(32),n>>=i,o-=i,El=1<<32-ni(t)+o|r<<o|n,_l=s+e}else El=1<<s|r<<o|n,_l=e}function yR(e){e.return!==null&&(df(e,1),ZK(e,1,0))}function bR(e){for(;e===gT;)gT=zh[--Bh],zh[Bh]=null,xT=zh[--Bh],zh[Bh]=null;for(;e===Cf;)Cf=Cs[--Ss],Cs[Ss]=null,_l=Cs[--Ss],Cs[Ss]=null,El=Cs[--Ss],Cs[Ss]=null}var zo=null,Mo=null,rr=!1,ri=null;function JK(e,t){var r=ks(5,null,null,0);r.elementType="DELETED",r.stateNode=t,r.return=e,t=e.deletions,t===null?(e.deletions=[r],e.flags|=16):t.push(r)}function Ej(e,t){switch(e.tag){case 5:var r=e.type;return t=t.nodeType!==1||r.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,zo=e,Mo=_c(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,zo=e,Mo=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(r=Cf!==null?{id:El,overflow:_l}:null,e.memoizedState={dehydrated:t,treeContext:r,retryLane:1073741824},r=ks(18,null,null,0),r.stateNode=t,r.return=e,e.child=r,zo=e,Mo=null,!0):!1;default:return!1}}function LD(e){return(e.mode&1)!==0&&(e.flags&128)===0}function MD(e){if(rr){var t=Mo;if(t){var r=t;if(!Ej(e,t)){if(LD(e))throw Error(ft(418));t=_c(r.nextSibling);var n=zo;t&&Ej(e,t)?JK(n,r):(e.flags=e.flags&-4097|2,rr=!1,zo=e)}}else{if(LD(e))throw Error(ft(418));e.flags=e.flags&-4097|2,rr=!1,zo=e}}}function _j(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;zo=e}function Uk(e){if(e!==zo)return!1;if(!rr)return _j(e),rr=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!$D(e.type,e.memoizedProps)),t&&(t=Mo)){if(LD(e))throw t8(),Error(ft(418));for(;t;)JK(e,t),t=_c(t.nextSibling)}if(_j(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(ft(317));t:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var r=e.data;if(r==="/$"){if(t===0){Mo=_c(e.nextSibling);break t}t--}else r!=="$"&&r!=="$!"&&r!=="$?"||t++}e=e.nextSibling}Mo=null}}else Mo=zo?_c(e.stateNode.nextSibling):null;return!0}function t8(){for(var e=Mo;e;)e=_c(e.nextSibling)}function Zh(){Mo=zo=null,rr=!1}function vR(e){ri===null?ri=[e]:ri.push(e)}var eyt=Fl.ReactCurrentBatchConfig;function ti(e,t){if(e&&e.defaultProps){t=cr({},t),e=e.defaultProps;for(var r in e)t[r]===void 0&&(t[r]=e[r]);return t}return t}var yT=Lc(null),bT=null,Vh=null,wR=null;function CR(){wR=Vh=bT=null}function SR(e){var t=yT.current;Ze(yT),e._currentValue=t}function zD(e,t,r){for(;e!==null;){var n=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,n!==null&&(n.childLanes|=t)):n!==null&&(n.childLanes&t)!==t&&(n.childLanes|=t),e===r)break;e=e.return}}function Kh(e,t){bT=e,wR=Vh=null,e=e.dependencies,e!==null&&e.firstContext!==null&&((e.lanes&t)!==0&&(vo=!0),e.firstContext=null)}function Ns(e){var t=e._currentValue;if(wR!==e)if(e={context:e,memoizedValue:t,next:null},Vh===null){if(bT===null)throw Error(ft(308));Vh=e,bT.dependencies={lanes:0,firstContext:e}}else Vh=Vh.next=e;return t}var xf=null;function kR(e){xf===null?xf=[e]:xf.push(e)}function e8(e,t,r,n){var o=t.interleaved;return o===null?(r.next=r,kR(t)):(r.next=o.next,o.next=r),t.interleaved=r,$l(e,n)}function $l(e,t){e.lanes|=t;var r=e.alternate;for(r!==null&&(r.lanes|=t),r=e,e=e.return;e!==null;)e.childLanes|=t,r=e.alternate,r!==null&&(r.childLanes|=t),r=e,e=e.return;return r.tag===3?r.stateNode:null}var wc=!1;function TR(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function r8(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Al(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Ac(e,t,r){var n=e.updateQueue;if(n===null)return null;if(n=n.shared,(ue&2)!==0){var o=n.pending;return o===null?t.next=t:(t.next=o.next,o.next=t),n.pending=t,$l(e,r)}return o=n.interleaved,o===null?(t.next=t,kR(n)):(t.next=o.next,o.next=t),n.interleaved=t,$l(e,r)}function Zk(e,t,r){if(t=t.updateQueue,t!==null&&(t=t.shared,(r&4194240)!==0)){var n=t.lanes;n&=e.pendingLanes,r|=n,t.lanes=r,cR(e,r)}}function Aj(e,t){var r=e.updateQueue,n=e.alternate;if(n!==null&&(n=n.updateQueue,r===n)){var o=null,s=null;if(r=r.firstBaseUpdate,r!==null){do{var i={eventTime:r.eventTime,lane:r.lane,tag:r.tag,payload:r.payload,callback:r.callback,next:null};s===null?o=s=i:s=s.next=i,r=r.next}while(r!==null);s===null?o=s=t:s=s.next=t}else o=s=t;r={baseState:n.baseState,firstBaseUpdate:o,lastBaseUpdate:s,shared:n.shared,effects:n.effects},e.updateQueue=r;return}e=r.lastBaseUpdate,e===null?r.firstBaseUpdate=t:e.next=t,r.lastBaseUpdate=t}function vT(e,t,r,n){var o=e.updateQueue;wc=!1;var s=o.firstBaseUpdate,i=o.lastBaseUpdate,a=o.shared.pending;if(a!==null){o.shared.pending=null;var l=a,u=l.next;l.next=null,i===null?s=u:i.next=u,i=l;var c=e.alternate;c!==null&&(c=c.updateQueue,a=c.lastBaseUpdate,a!==i&&(a===null?c.firstBaseUpdate=u:a.next=u,c.lastBaseUpdate=l))}if(s!==null){var p=o.baseState;i=0,c=u=l=null,a=s;do{var f=a.lane,m=a.eventTime;if((n&f)===f){c!==null&&(c=c.next={eventTime:m,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});t:{var d=e,h=a;switch(f=t,m=r,h.tag){case 1:if(d=h.payload,typeof d=="function"){p=d.call(m,p,f);break t}p=d;break t;case 3:d.flags=d.flags&-65537|128;case 0:if(d=h.payload,f=typeof d=="function"?d.call(m,p,f):d,f==null)break t;p=cr({},p,f);break t;case 2:wc=!0}}a.callback!==null&&a.lane!==0&&(e.flags|=64,f=o.effects,f===null?o.effects=[a]:f.push(a))}else m={eventTime:m,lane:f,tag:a.tag,payload:a.payload,callback:a.callback,next:null},c===null?(u=c=m,l=p):c=c.next=m,i|=f;if(a=a.next,a===null){if(a=o.shared.pending,a===null)break;f=a,a=f.next,f.next=null,o.lastBaseUpdate=f,o.shared.pending=null}}while(1);if(c===null&&(l=p),o.baseState=l,o.firstBaseUpdate=u,o.lastBaseUpdate=c,t=o.shared.interleaved,t!==null){o=t;do i|=o.lane,o=o.next;while(o!==t)}else s===null&&(o.shared.lanes=0);kf|=i,e.lanes=i,e.memoizedState=p}}function Dj(e,t,r){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var n=e[t],o=n.callback;if(o!==null){if(n.callback=null,n=r,typeof o!="function")throw Error(ft(191,o));o.call(n)}}}var n8=new eK.Component().refs;function BD(e,t,r,n){t=e.memoizedState,r=r(n,t),r=r==null?t:cr({},t,r),e.memoizedState=r,e.lanes===0&&(e.updateQueue.baseState=r)}var FT={isMounted:function(e){return(e=e._reactInternals)?If(e)===e:!1},enqueueSetState:function(e,t,r){e=e._reactInternals;var n=Xn(),o=Rc(e),s=Al(n,o);s.payload=t,r!=null&&(s.callback=r),t=Ac(e,s,o),t!==null&&(oi(t,e,o,n),Zk(t,e,o))},enqueueReplaceState:function(e,t,r){e=e._reactInternals;var n=Xn(),o=Rc(e),s=Al(n,o);s.tag=1,s.payload=t,r!=null&&(s.callback=r),t=Ac(e,s,o),t!==null&&(oi(t,e,o,n),Zk(t,e,o))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var r=Xn(),n=Rc(e),o=Al(r,n);o.tag=2,t!=null&&(o.callback=t),t=Ac(e,o,n),t!==null&&(oi(t,e,n,r),Zk(t,e,n))}};function Rj(e,t,r,n,o,s,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(n,s,i):t.prototype&&t.prototype.isPureReactComponent?!i0(r,n)||!i0(o,s):!0}function o8(e,t,r){var n=!1,o=Fc,s=t.contextType;return typeof s=="object"&&s!==null?s=Ns(s):(o=Co(t)?wf:Pn.current,n=t.contextTypes,s=(n=n!=null)?Qh(e,o):Fc),t=new t(r,s),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=FT,e.stateNode=t,t._reactInternals=e,n&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=s),t}function $j(e,t,r,n){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(r,n),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(r,n),t.state!==e&&FT.enqueueReplaceState(t,t.state,null)}function VD(e,t,r,n){var o=e.stateNode;o.props=r,o.state=e.memoizedState,o.refs=n8,TR(e);var s=t.contextType;typeof s=="object"&&s!==null?o.context=Ns(s):(s=Co(t)?wf:Pn.current,o.context=Qh(e,s)),o.state=e.memoizedState,s=t.getDerivedStateFromProps,typeof s=="function"&&(BD(e,t,s,r),o.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof o.getSnapshotBeforeUpdate=="function"||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(t=o.state,typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount(),t!==o.state&&FT.enqueueReplaceState(o,o.state,null),vT(e,r,o,n),o.state=e.memoizedState),typeof o.componentDidMount=="function"&&(e.flags|=4194308)}function Pb(e,t,r){if(e=r.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(r._owner){if(r=r._owner,r){if(r.tag!==1)throw Error(ft(309));var n=r.stateNode}if(!n)throw Error(ft(147,e));var o=n,s=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===s?t.ref:(t=function(i){var a=o.refs;a===n8&&(a=o.refs={}),i===null?delete a[s]:a[s]=i},t._stringRef=s,t)}if(typeof e!="string")throw Error(ft(284));if(!r._owner)throw Error(ft(290,e))}return e}function Hk(e,t){throw e=Object.prototype.toString.call(t),Error(ft(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Oj(e){var t=e._init;return t(e._payload)}function s8(e){function t(g,y){if(e){var b=g.deletions;b===null?(g.deletions=[y],g.flags|=16):b.push(y)}}function r(g,y){if(!e)return null;for(;y!==null;)t(g,y),y=y.sibling;return null}function n(g,y){for(g=new Map;y!==null;)y.key!==null?g.set(y.key,y):g.set(y.index,y),y=y.sibling;return g}function o(g,y){return g=$c(g,y),g.index=0,g.sibling=null,g}function s(g,y,b){return g.index=b,e?(b=g.alternate,b!==null?(b=b.index,b<y?(g.flags|=2,y):b):(g.flags|=2,y)):(g.flags|=1048576,y)}function i(g){return e&&g.alternate===null&&(g.flags|=2),g}function a(g,y,b,v){return y===null||y.tag!==6?(y=lD(b,g.mode,v),y.return=g,y):(y=o(y,b),y.return=g,y)}function l(g,y,b,v){var C=b.type;return C===$h?c(g,y,b.props.children,v,b.key):y!==null&&(y.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===vc&&Oj(C)===y.type)?(v=o(y,b.props),v.ref=Pb(g,y,b),v.return=g,v):(v=oT(b.type,b.key,b.props,null,g.mode,v),v.ref=Pb(g,y,b),v.return=g,v)}function u(g,y,b,v){return y===null||y.tag!==4||y.stateNode.containerInfo!==b.containerInfo||y.stateNode.implementation!==b.implementation?(y=uD(b,g.mode,v),y.return=g,y):(y=o(y,b.children||[]),y.return=g,y)}function c(g,y,b,v,C){return y===null||y.tag!==7?(y=vf(b,g.mode,v,C),y.return=g,y):(y=o(y,b),y.return=g,y)}function p(g,y,b){if(typeof y=="string"&&y!==""||typeof y=="number")return y=lD(""+y,g.mode,b),y.return=g,y;if(typeof y=="object"&&y!==null){switch(y.$$typeof){case Ak:return b=oT(y.type,y.key,y.props,null,g.mode,b),b.ref=Pb(g,null,y),b.return=g,b;case Rh:return y=uD(y,g.mode,b),y.return=g,y;case vc:var v=y._init;return p(g,v(y._payload),b)}if(Vb(y)||Rb(y))return y=vf(y,g.mode,b,null),y.return=g,y;Hk(g,y)}return null}function f(g,y,b,v){var C=y!==null?y.key:null;if(typeof b=="string"&&b!==""||typeof b=="number")return C!==null?null:a(g,y,""+b,v);if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Ak:return b.key===C?l(g,y,b,v):null;case Rh:return b.key===C?u(g,y,b,v):null;case vc:return C=b._init,f(g,y,C(b._payload),v)}if(Vb(b)||Rb(b))return C!==null?null:c(g,y,b,v,null);Hk(g,b)}return null}function m(g,y,b,v,C){if(typeof v=="string"&&v!==""||typeof v=="number")return g=g.get(b)||null,a(y,g,""+v,C);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case Ak:return g=g.get(v.key===null?b:v.key)||null,l(y,g,v,C);case Rh:return g=g.get(v.key===null?b:v.key)||null,u(y,g,v,C);case vc:var S=v._init;return m(g,y,b,S(v._payload),C)}if(Vb(v)||Rb(v))return g=g.get(b)||null,c(y,g,v,C,null);Hk(y,v)}return null}function d(g,y,b,v){for(var C=null,S=null,k=y,I=y=0,D=null;k!==null&&I<b.length;I++){k.index>I?(D=k,k=null):D=k.sibling;var R=f(g,k,b[I],v);if(R===null){k===null&&(k=D);break}e&&k&&R.alternate===null&&t(g,k),y=s(R,y,I),S===null?C=R:S.sibling=R,S=R,k=D}if(I===b.length)return r(g,k),rr&&df(g,I),C;if(k===null){for(;I<b.length;I++)k=p(g,b[I],v),k!==null&&(y=s(k,y,I),S===null?C=k:S.sibling=k,S=k);return rr&&df(g,I),C}for(k=n(g,k);I<b.length;I++)D=m(k,g,I,b[I],v),D!==null&&(e&&D.alternate!==null&&k.delete(D.key===null?I:D.key),y=s(D,y,I),S===null?C=D:S.sibling=D,S=D);return e&&k.forEach(function(M){return t(g,M)}),rr&&df(g,I),C}function h(g,y,b,v){var C=Rb(b);if(typeof C!="function")throw Error(ft(150));if(b=C.call(b),b==null)throw Error(ft(151));for(var S=C=null,k=y,I=y=0,D=null,R=b.next();k!==null&&!R.done;I++,R=b.next()){k.index>I?(D=k,k=null):D=k.sibling;var M=f(g,k,R.value,v);if(M===null){k===null&&(k=D);break}e&&k&&M.alternate===null&&t(g,k),y=s(M,y,I),S===null?C=M:S.sibling=M,S=M,k=D}if(R.done)return r(g,k),rr&&df(g,I),C;if(k===null){for(;!R.done;I++,R=b.next())R=p(g,R.value,v),R!==null&&(y=s(R,y,I),S===null?C=R:S.sibling=R,S=R);return rr&&df(g,I),C}for(k=n(g,k);!R.done;I++,R=b.next())R=m(k,g,I,R.value,v),R!==null&&(e&&R.alternate!==null&&k.delete(R.key===null?I:R.key),y=s(R,y,I),S===null?C=R:S.sibling=R,S=R);return e&&k.forEach(function(U){return t(g,U)}),rr&&df(g,I),C}function x(g,y,b,v){if(typeof b=="object"&&b!==null&&b.type===$h&&b.key===null&&(b=b.props.children),typeof b=="object"&&b!==null){switch(b.$$typeof){case Ak:t:{for(var C=b.key,S=y;S!==null;){if(S.key===C){if(C=b.type,C===$h){if(S.tag===7){r(g,S.sibling),y=o(S,b.props.children),y.return=g,g=y;break t}}else if(S.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===vc&&Oj(C)===S.type){r(g,S.sibling),y=o(S,b.props),y.ref=Pb(g,S,b),y.return=g,g=y;break t}r(g,S);break}else t(g,S);S=S.sibling}b.type===$h?(y=vf(b.props.children,g.mode,v,b.key),y.return=g,g=y):(v=oT(b.type,b.key,b.props,null,g.mode,v),v.ref=Pb(g,y,b),v.return=g,g=v)}return i(g);case Rh:t:{for(S=b.key;y!==null;){if(y.key===S)if(y.tag===4&&y.stateNode.containerInfo===b.containerInfo&&y.stateNode.implementation===b.implementation){r(g,y.sibling),y=o(y,b.children||[]),y.return=g,g=y;break t}else{r(g,y);break}else t(g,y);y=y.sibling}y=uD(b,g.mode,v),y.return=g,g=y}return i(g);case vc:return S=b._init,x(g,y,S(b._payload),v)}if(Vb(b))return d(g,y,b,v);if(Rb(b))return h(g,y,b,v);Hk(g,b)}return typeof b=="string"&&b!==""||typeof b=="number"?(b=""+b,y!==null&&y.tag===6?(r(g,y.sibling),y=o(y,b),y.return=g,g=y):(r(g,y),y=lD(b,g.mode,v),y.return=g,g=y),i(g)):r(g,y)}return x}var Jh=s8(!0),i8=s8(!1),b0={},Hi=Lc(b0),c0=Lc(b0),p0=Lc(b0);function yf(e){if(e===b0)throw Error(ft(174));return e}function NR(e,t){switch(Ue(p0,t),Ue(c0,e),Ue(Hi,b0),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:bD(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=bD(t,e)}Ze(Hi),Ue(Hi,t)}function tg(){Ze(Hi),Ze(c0),Ze(p0)}function a8(e){yf(p0.current);var t=yf(Hi.current),r=bD(t,e.type);t!==r&&(Ue(c0,e),Ue(Hi,r))}function IR(e){c0.current===e&&(Ze(Hi),Ze(c0))}var lr=Lc(0);function wT(e){for(var t=e;t!==null;){if(t.tag===13){var r=t.memoizedState;if(r!==null&&(r=r.dehydrated,r===null||r.data==="$?"||r.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if((t.flags&128)!==0)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var rD=[];function ER(){for(var e=0;e<rD.length;e++)rD[e]._workInProgressVersionPrimary=null;rD.length=0}var Jk=Fl.ReactCurrentDispatcher,nD=Fl.ReactCurrentBatchConfig,Sf=0,ur=null,Ur=null,on=null,CT=!1,Xb=!1,f0=0,ryt=0;function $n(){throw Error(ft(321))}function _R(e,t){if(t===null)return!1;for(var r=0;r<t.length&&r<e.length;r++)if(!si(e[r],t[r]))return!1;return!0}function AR(e,t,r,n,o,s){if(Sf=s,ur=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Jk.current=e===null||e.memoizedState===null?iyt:ayt,e=r(n,o),Xb){s=0;do{if(Xb=!1,f0=0,25<=s)throw Error(ft(301));s+=1,on=Ur=null,t.updateQueue=null,Jk.current=lyt,e=r(n,o)}while(Xb)}if(Jk.current=ST,t=Ur!==null&&Ur.next!==null,Sf=0,on=Ur=ur=null,CT=!1,t)throw Error(ft(300));return e}function DR(){var e=f0!==0;return f0=0,e}function Wi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return on===null?ur.memoizedState=on=e:on=on.next=e,on}function Is(){if(Ur===null){var e=ur.alternate;e=e!==null?e.memoizedState:null}else e=Ur.next;var t=on===null?ur.memoizedState:on.next;if(t!==null)on=t,Ur=e;else{if(e===null)throw Error(ft(310));Ur=e,e={memoizedState:Ur.memoizedState,baseState:Ur.baseState,baseQueue:Ur.baseQueue,queue:Ur.queue,next:null},on===null?ur.memoizedState=on=e:on=on.next=e}return on}function m0(e,t){return typeof t=="function"?t(e):t}function oD(e){var t=Is(),r=t.queue;if(r===null)throw Error(ft(311));r.lastRenderedReducer=e;var n=Ur,o=n.baseQueue,s=r.pending;if(s!==null){if(o!==null){var i=o.next;o.next=s.next,s.next=i}n.baseQueue=o=s,r.pending=null}if(o!==null){s=o.next,n=n.baseState;var a=i=null,l=null,u=s;do{var c=u.lane;if((Sf&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),n=u.hasEagerState?u.eagerState:e(n,u.action);else{var p={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(a=l=p,i=n):l=l.next=p,ur.lanes|=c,kf|=c}u=u.next}while(u!==null&&u!==s);l===null?i=n:l.next=a,si(n,t.memoizedState)||(vo=!0),t.memoizedState=n,t.baseState=i,t.baseQueue=l,r.lastRenderedState=n}if(e=r.interleaved,e!==null){o=e;do s=o.lane,ur.lanes|=s,kf|=s,o=o.next;while(o!==e)}else o===null&&(r.lanes=0);return[t.memoizedState,r.dispatch]}function sD(e){var t=Is(),r=t.queue;if(r===null)throw Error(ft(311));r.lastRenderedReducer=e;var n=r.dispatch,o=r.pending,s=t.memoizedState;if(o!==null){r.pending=null;var i=o=o.next;do s=e(s,i.action),i=i.next;while(i!==o);si(s,t.memoizedState)||(vo=!0),t.memoizedState=s,t.baseQueue===null&&(t.baseState=s),r.lastRenderedState=s}return[s,n]}function l8(){}function u8(e,t){var r=ur,n=Is(),o=t(),s=!si(n.memoizedState,o);if(s&&(n.memoizedState=o,vo=!0),n=n.queue,RR(f8.bind(null,r,n,e),[e]),n.getSnapshot!==t||s||on!==null&&on.memoizedState.tag&1){if(r.flags|=2048,d0(9,p8.bind(null,r,n,o,t),void 0,null),sn===null)throw Error(ft(349));(Sf&30)!==0||c8(r,t,o)}return o}function c8(e,t,r){e.flags|=16384,e={getSnapshot:t,value:r},t=ur.updateQueue,t===null?(t={lastEffect:null,stores:null},ur.updateQueue=t,t.stores=[e]):(r=t.stores,r===null?t.stores=[e]:r.push(e))}function p8(e,t,r,n){t.value=r,t.getSnapshot=n,m8(t)&&d8(e)}function f8(e,t,r){return r(function(){m8(t)&&d8(e)})}function m8(e){var t=e.getSnapshot;e=e.value;try{var r=t();return!si(e,r)}catch(n){return!0}}function d8(e){var t=$l(e,1);t!==null&&oi(t,e,1,-1)}function Fj(e){var t=Wi();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:m0,lastRenderedState:e},t.queue=e,e=e.dispatch=syt.bind(null,ur,e),[t.memoizedState,e]}function d0(e,t,r,n){return e={tag:e,create:t,destroy:r,deps:n,next:null},t=ur.updateQueue,t===null?(t={lastEffect:null,stores:null},ur.updateQueue=t,t.lastEffect=e.next=e):(r=t.lastEffect,r===null?t.lastEffect=e.next=e:(n=r.next,r.next=e,e.next=n,t.lastEffect=e)),e}function h8(){return Is().memoizedState}function tT(e,t,r,n){var o=Wi();ur.flags|=e,o.memoizedState=d0(1|t,r,void 0,n===void 0?null:n)}function PT(e,t,r,n){var o=Is();n=n===void 0?null:n;var s=void 0;if(Ur!==null){var i=Ur.memoizedState;if(s=i.destroy,n!==null&&_R(n,i.deps)){o.memoizedState=d0(t,r,s,n);return}}ur.flags|=e,o.memoizedState=d0(1|t,r,s,n)}function Pj(e,t){return tT(8390656,8,e,t)}function RR(e,t){return PT(2048,8,e,t)}function g8(e,t){return PT(4,2,e,t)}function x8(e,t){return PT(4,4,e,t)}function y8(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function b8(e,t,r){return r=r!=null?r.concat([e]):null,PT(4,4,y8.bind(null,t,e),r)}function $R(){}function v8(e,t){var r=Is();t=t===void 0?null:t;var n=r.memoizedState;return n!==null&&t!==null&&_R(t,n[1])?n[0]:(r.memoizedState=[e,t],e)}function w8(e,t){var r=Is();t=t===void 0?null:t;var n=r.memoizedState;return n!==null&&t!==null&&_R(t,n[1])?n[0]:(e=e(),r.memoizedState=[e,t],e)}function C8(e,t,r){return(Sf&21)===0?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=r):(si(r,t)||(r=TK(),ur.lanes|=r,kf|=r,e.baseState=!0),t)}function nyt(e,t){var r=Te;Te=r!==0&&4>r?r:4,e(!0);var n=nD.transition;nD.transition={};try{e(!1),t()}finally{Te=r,nD.transition=n}}function S8(){return Is().memoizedState}function oyt(e,t,r){var n=Rc(e);if(r={lane:n,action:r,hasEagerState:!1,eagerState:null,next:null},k8(e))T8(t,r);else if(r=e8(e,t,r,n),r!==null){var o=Xn();oi(r,e,n,o),N8(r,t,n)}}function syt(e,t,r){var n=Rc(e),o={lane:n,action:r,hasEagerState:!1,eagerState:null,next:null};if(k8(e))T8(t,o);else{var s=e.alternate;if(e.lanes===0&&(s===null||s.lanes===0)&&(s=t.lastRenderedReducer,s!==null))try{var i=t.lastRenderedState,a=s(i,r);if(o.hasEagerState=!0,o.eagerState=a,si(a,i)){var l=t.interleaved;l===null?(o.next=o,kR(t)):(o.next=l.next,l.next=o),t.interleaved=o;return}}catch(u){}finally{}r=e8(e,t,o,n),r!==null&&(o=Xn(),oi(r,e,n,o),N8(r,t,n))}}function k8(e){var t=e.alternate;return e===ur||t!==null&&t===ur}function T8(e,t){Xb=CT=!0;var r=e.pending;r===null?t.next=t:(t.next=r.next,r.next=t),e.pending=t}function N8(e,t,r){if((r&4194240)!==0){var n=t.lanes;n&=e.pendingLanes,r|=n,t.lanes=r,cR(e,r)}}var ST={readContext:Ns,useCallback:$n,useContext:$n,useEffect:$n,useImperativeHandle:$n,useInsertionEffect:$n,useLayoutEffect:$n,useMemo:$n,useReducer:$n,useRef:$n,useState:$n,useDebugValue:$n,useDeferredValue:$n,useTransition:$n,useMutableSource:$n,useSyncExternalStore:$n,useId:$n,unstable_isNewReconciler:!1},iyt={readContext:Ns,useCallback:function(e,t){return Wi().memoizedState=[e,t===void 0?null:t],e},useContext:Ns,useEffect:Pj,useImperativeHandle:function(e,t,r){return r=r!=null?r.concat([e]):null,tT(4194308,4,y8.bind(null,t,e),r)},useLayoutEffect:function(e,t){return tT(4194308,4,e,t)},useInsertionEffect:function(e,t){return tT(4,2,e,t)},useMemo:function(e,t){var r=Wi();return t=t===void 0?null:t,e=e(),r.memoizedState=[e,t],e},useReducer:function(e,t,r){var n=Wi();return t=r!==void 0?r(t):t,n.memoizedState=n.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},n.queue=e,e=e.dispatch=oyt.bind(null,ur,e),[n.memoizedState,e]},useRef:function(e){var t=Wi();return e={current:e},t.memoizedState=e},useState:Fj,useDebugValue:$R,useDeferredValue:function(e){return Wi().memoizedState=e},useTransition:function(){var e=Fj(!1),t=e[0];return e=nyt.bind(null,e[1]),Wi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,r){var n=ur,o=Wi();if(rr){if(r===void 0)throw Error(ft(407));r=r()}else{if(r=t(),sn===null)throw Error(ft(349));(Sf&30)!==0||c8(n,t,r)}o.memoizedState=r;var s={value:r,getSnapshot:t};return o.queue=s,Pj(f8.bind(null,n,s,e),[e]),n.flags|=2048,d0(9,p8.bind(null,n,s,r,t),void 0,null),r},useId:function(){var e=Wi(),t=sn.identifierPrefix;if(rr){var r=_l,n=El;r=(n&~(1<<32-ni(n)-1)).toString(32)+r,t=":"+t+"R"+r,r=f0++,0<r&&(t+="H"+r.toString(32)),t+=":"}else r=ryt++,t=":"+t+"r"+r.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},ayt={readContext:Ns,useCallback:v8,useContext:Ns,useEffect:RR,useImperativeHandle:b8,useInsertionEffect:g8,useLayoutEffect:x8,useMemo:w8,useReducer:oD,useRef:h8,useState:function(){return oD(m0)},useDebugValue:$R,useDeferredValue:function(e){var t=Is();return C8(t,Ur.memoizedState,e)},useTransition:function(){var e=oD(m0)[0],t=Is().memoizedState;return[e,t]},useMutableSource:l8,useSyncExternalStore:u8,useId:S8,unstable_isNewReconciler:!1},lyt={readContext:Ns,useCallback:v8,useContext:Ns,useEffect:RR,useImperativeHandle:b8,useInsertionEffect:g8,useLayoutEffect:x8,useMemo:w8,useReducer:sD,useRef:h8,useState:function(){return sD(m0)},useDebugValue:$R,useDeferredValue:function(e){var t=Is();return Ur===null?t.memoizedState=e:C8(t,Ur.memoizedState,e)},useTransition:function(){var e=sD(m0)[0],t=Is().memoizedState;return[e,t]},useMutableSource:l8,useSyncExternalStore:u8,useId:S8,unstable_isNewReconciler:!1};function eg(e,t){try{var r="",n=t;do r+=Mgt(n),n=n.return;while(n);var o=r}catch(s){o=`
Error generating stack: `+s.message+`
`+s.stack}return{value:e,source:t,stack:o,digest:null}}function iD(e,t,r){return{value:e,source:null,stack:r!=null?r:null,digest:t!=null?t:null}}function WD(e,t){try{console.error(t.value)}catch(r){setTimeout(function(){throw r})}}var uyt=typeof WeakMap=="function"?WeakMap:Map;function I8(e,t,r){r=Al(-1,r),r.tag=3,r.payload={element:null};var n=t.value;return r.callback=function(){TT||(TT=!0,ZD=n),WD(e,t)},r}function E8(e,t,r){r=Al(-1,r),r.tag=3;var n=e.type.getDerivedStateFromError;if(typeof n=="function"){var o=t.value;r.payload=function(){return n(o)},r.callback=function(){WD(e,t)}}var s=e.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(r.callback=function(){WD(e,t),typeof n!="function"&&(Dc===null?Dc=new Set([this]):Dc.add(this));var i=t.stack;this.componentDidCatch(t.value,{componentStack:i!==null?i:""})}),r}function Lj(e,t,r){var n=e.pingCache;if(n===null){n=e.pingCache=new uyt;var o=new Set;n.set(t,o)}else o=n.get(t),o===void 0&&(o=new Set,n.set(t,o));o.has(r)||(o.add(r),e=Syt.bind(null,e,t,r),t.then(e,e))}function Mj(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function zj(e,t,r,n,o){return(e.mode&1)===0?(e===t?e.flags|=65536:(e.flags|=128,r.flags|=131072,r.flags&=-52805,r.tag===1&&(r.alternate===null?r.tag=17:(t=Al(-1,1),t.tag=2,Ac(r,t,1))),r.lanes|=1),e):(e.flags|=65536,e.lanes=o,e)}var cyt=Fl.ReactCurrentOwner,vo=!1;function Kn(e,t,r,n){t.child=e===null?i8(t,null,r,n):Jh(t,e.child,r,n)}function Bj(e,t,r,n,o){r=r.render;var s=t.ref;return Kh(t,o),n=AR(e,t,r,n,s,o),r=DR(),e!==null&&!vo?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~o,Ol(e,t,o)):(rr&&r&&yR(t),t.flags|=1,Kn(e,t,n,o),t.child)}function Vj(e,t,r,n,o){if(e===null){var s=r.type;return typeof s=="function"&&!VR(s)&&s.defaultProps===void 0&&r.compare===null&&r.defaultProps===void 0?(t.tag=15,t.type=s,_8(e,t,s,n,o)):(e=oT(r.type,null,n,t,t.mode,o),e.ref=t.ref,e.return=t,t.child=e)}if(s=e.child,(e.lanes&o)===0){var i=s.memoizedProps;if(r=r.compare,r=r!==null?r:i0,r(i,n)&&e.ref===t.ref)return Ol(e,t,o)}return t.flags|=1,e=$c(s,n),e.ref=t.ref,e.return=t,t.child=e}function _8(e,t,r,n,o){if(e!==null){var s=e.memoizedProps;if(i0(s,n)&&e.ref===t.ref)if(vo=!1,t.pendingProps=n=s,(e.lanes&o)!==0)(e.flags&131072)!==0&&(vo=!0);else return t.lanes=e.lanes,Ol(e,t,o)}return GD(e,t,r,n,o)}function A8(e,t,r){var n=t.pendingProps,o=n.children,s=e!==null?e.memoizedState:null;if(n.mode==="hidden")if((t.mode&1)===0)t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ue(Gh,Lo),Lo|=r;else{if((r&1073741824)===0)return e=s!==null?s.baseLanes|r:r,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ue(Gh,Lo),Lo|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},n=s!==null?s.baseLanes:r,Ue(Gh,Lo),Lo|=n}else s!==null?(n=s.baseLanes|r,t.memoizedState=null):n=r,Ue(Gh,Lo),Lo|=n;return Kn(e,t,o,r),t.child}function D8(e,t){var r=t.ref;(e===null&&r!==null||e!==null&&e.ref!==r)&&(t.flags|=512,t.flags|=2097152)}function GD(e,t,r,n,o){var s=Co(r)?wf:Pn.current;return s=Qh(t,s),Kh(t,o),r=AR(e,t,r,n,s,o),n=DR(),e!==null&&!vo?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~o,Ol(e,t,o)):(rr&&n&&yR(t),t.flags|=1,Kn(e,t,r,o),t.child)}function Wj(e,t,r,n,o){if(Co(r)){var s=!0;hT(t)}else s=!1;if(Kh(t,o),t.stateNode===null)eT(e,t),o8(t,r,n),VD(t,r,n,o),n=!0;else if(e===null){var i=t.stateNode,a=t.memoizedProps;i.props=a;var l=i.context,u=r.contextType;typeof u=="object"&&u!==null?u=Ns(u):(u=Co(r)?wf:Pn.current,u=Qh(t,u));var c=r.getDerivedStateFromProps,p=typeof c=="function"||typeof i.getSnapshotBeforeUpdate=="function";p||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(a!==n||l!==u)&&$j(t,i,n,u),wc=!1;var f=t.memoizedState;i.state=f,vT(t,n,i,o),l=t.memoizedState,a!==n||f!==l||wo.current||wc?(typeof c=="function"&&(BD(t,r,c,n),l=t.memoizedState),(a=wc||Rj(t,r,a,n,f,l,u))?(p||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(t.flags|=4194308)):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=n,t.memoizedState=l),i.props=n,i.state=l,i.context=u,n=a):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),n=!1)}else{i=t.stateNode,r8(e,t),a=t.memoizedProps,u=t.type===t.elementType?a:ti(t.type,a),i.props=u,p=t.pendingProps,f=i.context,l=r.contextType,typeof l=="object"&&l!==null?l=Ns(l):(l=Co(r)?wf:Pn.current,l=Qh(t,l));var m=r.getDerivedStateFromProps;(c=typeof m=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(a!==p||f!==l)&&$j(t,i,n,l),wc=!1,f=t.memoizedState,i.state=f,vT(t,n,i,o);var d=t.memoizedState;a!==p||f!==d||wo.current||wc?(typeof m=="function"&&(BD(t,r,m,n),d=t.memoizedState),(u=wc||Rj(t,r,u,n,f,d,l)||!1)?(c||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(n,d,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(n,d,l)),typeof i.componentDidUpdate=="function"&&(t.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof i.componentDidUpdate!="function"||a===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),t.memoizedProps=n,t.memoizedState=d),i.props=n,i.state=d,i.context=l,n=u):(typeof i.componentDidUpdate!="function"||a===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),n=!1)}return UD(e,t,r,n,s,o)}function UD(e,t,r,n,o,s){D8(e,t);var i=(t.flags&128)!==0;if(!n&&!i)return o&&Ij(t,r,!1),Ol(e,t,s);n=t.stateNode,cyt.current=t;var a=i&&typeof r.getDerivedStateFromError!="function"?null:n.render();return t.flags|=1,e!==null&&i?(t.child=Jh(t,e.child,null,s),t.child=Jh(t,null,a,s)):Kn(e,t,a,s),t.memoizedState=n.state,o&&Ij(t,r,!0),t.child}function R8(e){var t=e.stateNode;t.pendingContext?Nj(e,t.pendingContext,t.pendingContext!==t.context):t.context&&Nj(e,t.context,!1),NR(e,t.containerInfo)}function Gj(e,t,r,n,o){return Zh(),vR(o),t.flags|=256,Kn(e,t,r,n),t.child}var HD={dehydrated:null,treeContext:null,retryLane:0};function qD(e){return{baseLanes:e,cachePool:null,transitions:null}}function $8(e,t,r){var n=t.pendingProps,o=lr.current,s=!1,i=(t.flags&128)!==0,a;if((a=i)||(a=e!==null&&e.memoizedState===null?!1:(o&2)!==0),a?(s=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(o|=1),Ue(lr,o&1),e===null)return MD(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?((t.mode&1)===0?t.lanes=1:e.data==="$!"?t.lanes=8:t.lanes=1073741824,null):(i=n.children,e=n.fallback,s?(n=t.mode,s=t.child,i={mode:"hidden",children:i},(n&1)===0&&s!==null?(s.childLanes=0,s.pendingProps=i):s=zT(i,n,0,null),e=vf(e,n,r,null),s.return=t,e.return=t,s.sibling=e,t.child=s,t.child.memoizedState=qD(r),t.memoizedState=HD,e):OR(t,i));if(o=e.memoizedState,o!==null&&(a=o.dehydrated,a!==null))return pyt(e,t,i,n,a,o,r);if(s){s=n.fallback,i=t.mode,o=e.child,a=o.sibling;var l={mode:"hidden",children:n.children};return(i&1)===0&&t.child!==o?(n=t.child,n.childLanes=0,n.pendingProps=l,t.deletions=null):(n=$c(o,l),n.subtreeFlags=o.subtreeFlags&14680064),a!==null?s=$c(a,s):(s=vf(s,i,r,null),s.flags|=2),s.return=t,n.return=t,n.sibling=s,t.child=n,n=s,s=t.child,i=e.child.memoizedState,i=i===null?qD(r):{baseLanes:i.baseLanes|r,cachePool:null,transitions:i.transitions},s.memoizedState=i,s.childLanes=e.childLanes&~r,t.memoizedState=HD,n}return s=e.child,e=s.sibling,n=$c(s,{mode:"visible",children:n.children}),(t.mode&1)===0&&(n.lanes=r),n.return=t,n.sibling=null,e!==null&&(r=t.deletions,r===null?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=n,t.memoizedState=null,n}function OR(e,t){return t=zT({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function qk(e,t,r,n){return n!==null&&vR(n),Jh(t,e.child,null,r),e=OR(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function pyt(e,t,r,n,o,s,i){if(r)return t.flags&256?(t.flags&=-257,n=iD(Error(ft(422))),qk(e,t,i,n)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(s=n.fallback,o=t.mode,n=zT({mode:"visible",children:n.children},o,0,null),s=vf(s,o,i,null),s.flags|=2,n.return=t,s.return=t,n.sibling=s,t.child=n,(t.mode&1)!==0&&Jh(t,e.child,null,i),t.child.memoizedState=qD(i),t.memoizedState=HD,s);if((t.mode&1)===0)return qk(e,t,i,null);if(o.data==="$!"){if(n=o.nextSibling&&o.nextSibling.dataset,n)var a=n.dgst;return n=a,s=Error(ft(419)),n=iD(s,n,void 0),qk(e,t,i,n)}if(a=(i&e.childLanes)!==0,vo||a){if(n=sn,n!==null){switch(i&-i){case 4:o=2;break;case 16:o=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:o=32;break;case 536870912:o=268435456;break;default:o=0}o=(o&(n.suspendedLanes|i))!==0?0:o,o!==0&&o!==s.retryLane&&(s.retryLane=o,$l(e,o),oi(n,e,o,-1))}return BR(),n=iD(Error(ft(421))),qk(e,t,i,n)}return o.data==="$?"?(t.flags|=128,t.child=e.child,t=kyt.bind(null,e),o._reactRetry=t,null):(e=s.treeContext,Mo=_c(o.nextSibling),zo=t,rr=!0,ri=null,e!==null&&(Cs[Ss++]=El,Cs[Ss++]=_l,Cs[Ss++]=Cf,El=e.id,_l=e.overflow,Cf=t),t=OR(t,n.children),t.flags|=4096,t)}function Uj(e,t,r){e.lanes|=t;var n=e.alternate;n!==null&&(n.lanes|=t),zD(e.return,t,r)}function aD(e,t,r,n,o){var s=e.memoizedState;s===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:n,tail:r,tailMode:o}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=n,s.tail=r,s.tailMode=o)}function O8(e,t,r){var n=t.pendingProps,o=n.revealOrder,s=n.tail;if(Kn(e,t,n.children,r),n=lr.current,(n&2)!==0)n=n&1|2,t.flags|=128;else{if(e!==null&&(e.flags&128)!==0)t:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Uj(e,r,t);else if(e.tag===19)Uj(e,r,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break t;for(;e.sibling===null;){if(e.return===null||e.return===t)break t;e=e.return}e.sibling.return=e.return,e=e.sibling}n&=1}if(Ue(lr,n),(t.mode&1)===0)t.memoizedState=null;else switch(o){case"forwards":for(r=t.child,o=null;r!==null;)e=r.alternate,e!==null&&wT(e)===null&&(o=r),r=r.sibling;r=o,r===null?(o=t.child,t.child=null):(o=r.sibling,r.sibling=null),aD(t,!1,o,r,s);break;case"backwards":for(r=null,o=t.child,t.child=null;o!==null;){if(e=o.alternate,e!==null&&wT(e)===null){t.child=o;break}e=o.sibling,o.sibling=r,r=o,o=e}aD(t,!0,r,null,s);break;case"together":aD(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function eT(e,t){(t.mode&1)===0&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Ol(e,t,r){if(e!==null&&(t.dependencies=e.dependencies),kf|=t.lanes,(r&t.childLanes)===0)return null;if(e!==null&&t.child!==e.child)throw Error(ft(153));if(t.child!==null){for(e=t.child,r=$c(e,e.pendingProps),t.child=r,r.return=t;e.sibling!==null;)e=e.sibling,r=r.sibling=$c(e,e.pendingProps),r.return=t;r.sibling=null}return t.child}function fyt(e,t,r){switch(t.tag){case 3:R8(t),Zh();break;case 5:a8(t);break;case 1:Co(t.type)&&hT(t);break;case 4:NR(t,t.stateNode.containerInfo);break;case 10:var n=t.type._context,o=t.memoizedProps.value;Ue(yT,n._currentValue),n._currentValue=o;break;case 13:if(n=t.memoizedState,n!==null)return n.dehydrated!==null?(Ue(lr,lr.current&1),t.flags|=128,null):(r&t.child.childLanes)!==0?$8(e,t,r):(Ue(lr,lr.current&1),e=Ol(e,t,r),e!==null?e.sibling:null);Ue(lr,lr.current&1);break;case 19:if(n=(r&t.childLanes)!==0,(e.flags&128)!==0){if(n)return O8(e,t,r);t.flags|=128}if(o=t.memoizedState,o!==null&&(o.rendering=null,o.tail=null,o.lastEffect=null),Ue(lr,lr.current),n)break;return null;case 22:case 23:return t.lanes=0,A8(e,t,r)}return Ol(e,t,r)}var F8,jD,P8,L8;F8=function(e,t){for(var r=t.child;r!==null;){if(r.tag===5||r.tag===6)e.appendChild(r.stateNode);else if(r.tag!==4&&r.child!==null){r.child.return=r,r=r.child;continue}if(r===t)break;for(;r.sibling===null;){if(r.return===null||r.return===t)return;r=r.return}r.sibling.return=r.return,r=r.sibling}};jD=function(){};P8=function(e,t,r,n){var o=e.memoizedProps;if(o!==n){e=t.stateNode,yf(Hi.current);var s=null;switch(r){case"input":o=hD(e,o),n=hD(e,n),s=[];break;case"select":o=cr({},o,{value:void 0}),n=cr({},n,{value:void 0}),s=[];break;case"textarea":o=yD(e,o),n=yD(e,n),s=[];break;default:typeof o.onClick!="function"&&typeof n.onClick=="function"&&(e.onclick=mT)}vD(r,n);var i;r=null;for(u in o)if(!n.hasOwnProperty(u)&&o.hasOwnProperty(u)&&o[u]!=null)if(u==="style"){var a=o[u];for(i in a)a.hasOwnProperty(i)&&(r||(r={}),r[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Jb.hasOwnProperty(u)?s||(s=[]):(s=s||[]).push(u,null));for(u in n){var l=n[u];if(a=o!=null?o[u]:void 0,n.hasOwnProperty(u)&&l!==a&&(l!=null||a!=null))if(u==="style")if(a){for(i in a)!a.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(r||(r={}),r[i]="");for(i in l)l.hasOwnProperty(i)&&a[i]!==l[i]&&(r||(r={}),r[i]=l[i])}else r||(s||(s=[]),s.push(u,r)),r=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(s=s||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(Jb.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&Qe("scroll",e),s||a===l||(s=[])):(s=s||[]).push(u,l))}r&&(s=s||[]).push("style",r);var u=s;(t.updateQueue=u)&&(t.flags|=4)}};L8=function(e,t,r,n){r!==n&&(t.flags|=4)};function Lb(e,t){if(!rr)switch(e.tailMode){case"hidden":t=e.tail;for(var r=null;t!==null;)t.alternate!==null&&(r=t),t=t.sibling;r===null?e.tail=null:r.sibling=null;break;case"collapsed":r=e.tail;for(var n=null;r!==null;)r.alternate!==null&&(n=r),r=r.sibling;n===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:n.sibling=null}}function On(e){var t=e.alternate!==null&&e.alternate.child===e.child,r=0,n=0;if(t)for(var o=e.child;o!==null;)r|=o.lanes|o.childLanes,n|=o.subtreeFlags&14680064,n|=o.flags&14680064,o.return=e,o=o.sibling;else for(o=e.child;o!==null;)r|=o.lanes|o.childLanes,n|=o.subtreeFlags,n|=o.flags,o.return=e,o=o.sibling;return e.subtreeFlags|=n,e.childLanes=r,t}function myt(e,t,r){var n=t.pendingProps;switch(bR(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return On(t),null;case 1:return Co(t.type)&&dT(),On(t),null;case 3:return n=t.stateNode,tg(),Ze(wo),Ze(Pn),ER(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),(e===null||e.child===null)&&(Uk(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&(t.flags&256)===0||(t.flags|=1024,ri!==null&&(eR(ri),ri=null))),jD(e,t),On(t),null;case 5:IR(t);var o=yf(p0.current);if(r=t.type,e!==null&&t.stateNode!=null)P8(e,t,r,n,o),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!n){if(t.stateNode===null)throw Error(ft(166));return On(t),null}if(e=yf(Hi.current),Uk(t)){n=t.stateNode,r=t.type;var s=t.memoizedProps;switch(n[Gi]=t,n[u0]=s,e=(t.mode&1)!==0,r){case"dialog":Qe("cancel",n),Qe("close",n);break;case"iframe":case"object":case"embed":Qe("load",n);break;case"video":case"audio":for(o=0;o<Gb.length;o++)Qe(Gb[o],n);break;case"source":Qe("error",n);break;case"img":case"image":case"link":Qe("error",n),Qe("load",n);break;case"details":Qe("toggle",n);break;case"input":Zq(n,s),Qe("invalid",n);break;case"select":n._wrapperState={wasMultiple:!!s.multiple},Qe("invalid",n);break;case"textarea":tj(n,s),Qe("invalid",n)}vD(r,s),o=null;for(var i in s)if(s.hasOwnProperty(i)){var a=s[i];i==="children"?typeof a=="string"?n.textContent!==a&&(s.suppressHydrationWarning!==!0&&Gk(n.textContent,a,e),o=["children",a]):typeof a=="number"&&n.textContent!==""+a&&(s.suppressHydrationWarning!==!0&&Gk(n.textContent,a,e),o=["children",""+a]):Jb.hasOwnProperty(i)&&a!=null&&i==="onScroll"&&Qe("scroll",n)}switch(r){case"input":Dk(n),Jq(n,s,!0);break;case"textarea":Dk(n),ej(n);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(n.onclick=mT)}n=o,t.updateQueue=n,n!==null&&(t.flags|=4)}else{i=o.nodeType===9?o:o.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=cK(r)),e==="http://www.w3.org/1999/xhtml"?r==="script"?(e=i.createElement("div"),e.innerHTML="<script></script>",e=e.removeChild(e.firstChild)):typeof n.is=="string"?e=i.createElement(r,{is:n.is}):(e=i.createElement(r),r==="select"&&(i=e,n.multiple?i.multiple=!0:n.size&&(i.size=n.size))):e=i.createElementNS(e,r),e[Gi]=t,e[u0]=n,F8(e,t,!1,!1),t.stateNode=e;t:{switch(i=wD(r,n),r){case"dialog":Qe("cancel",e),Qe("close",e),o=n;break;case"iframe":case"object":case"embed":Qe("load",e),o=n;break;case"video":case"audio":for(o=0;o<Gb.length;o++)Qe(Gb[o],e);o=n;break;case"source":Qe("error",e),o=n;break;case"img":case"image":case"link":Qe("error",e),Qe("load",e),o=n;break;case"details":Qe("toggle",e),o=n;break;case"input":Zq(e,n),o=hD(e,n),Qe("invalid",e);break;case"option":o=n;break;case"select":e._wrapperState={wasMultiple:!!n.multiple},o=cr({},n,{value:void 0}),Qe("invalid",e);break;case"textarea":tj(e,n),o=yD(e,n),Qe("invalid",e);break;default:o=n}vD(r,o),a=o;for(s in a)if(a.hasOwnProperty(s)){var l=a[s];s==="style"?mK(e,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&pK(e,l)):s==="children"?typeof l=="string"?(r!=="textarea"||l!=="")&&t0(e,l):typeof l=="number"&&t0(e,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(Jb.hasOwnProperty(s)?l!=null&&s==="onScroll"&&Qe("scroll",e):l!=null&&oR(e,s,l,i))}switch(r){case"input":Dk(e),Jq(e,n,!1);break;case"textarea":Dk(e),ej(e);break;case"option":n.value!=null&&e.setAttribute("value",""+Oc(n.value));break;case"select":e.multiple=!!n.multiple,s=n.value,s!=null?Uh(e,!!n.multiple,s,!1):n.defaultValue!=null&&Uh(e,!!n.multiple,n.defaultValue,!0);break;default:typeof o.onClick=="function"&&(e.onclick=mT)}switch(r){case"button":case"input":case"select":case"textarea":n=!!n.autoFocus;break t;case"img":n=!0;break t;default:n=!1}}n&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return On(t),null;case 6:if(e&&t.stateNode!=null)L8(e,t,e.memoizedProps,n);else{if(typeof n!="string"&&t.stateNode===null)throw Error(ft(166));if(r=yf(p0.current),yf(Hi.current),Uk(t)){if(n=t.stateNode,r=t.memoizedProps,n[Gi]=t,(s=n.nodeValue!==r)&&(e=zo,e!==null))switch(e.tag){case 3:Gk(n.nodeValue,r,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Gk(n.nodeValue,r,(e.mode&1)!==0)}s&&(t.flags|=4)}else n=(r.nodeType===9?r:r.ownerDocument).createTextNode(n),n[Gi]=t,t.stateNode=n}return On(t),null;case 13:if(Ze(lr),n=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(rr&&Mo!==null&&(t.mode&1)!==0&&(t.flags&128)===0)t8(),Zh(),t.flags|=98560,s=!1;else if(s=Uk(t),n!==null&&n.dehydrated!==null){if(e===null){if(!s)throw Error(ft(318));if(s=t.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(ft(317));s[Gi]=t}else Zh(),(t.flags&128)===0&&(t.memoizedState=null),t.flags|=4;On(t),s=!1}else ri!==null&&(eR(ri),ri=null),s=!0;if(!s)return t.flags&65536?t:null}return(t.flags&128)!==0?(t.lanes=r,t):(n=n!==null,n!==(e!==null&&e.memoizedState!==null)&&n&&(t.child.flags|=8192,(t.mode&1)!==0&&(e===null||(lr.current&1)!==0?Hr===0&&(Hr=3):BR())),t.updateQueue!==null&&(t.flags|=4),On(t),null);case 4:return tg(),jD(e,t),e===null&&a0(t.stateNode.containerInfo),On(t),null;case 10:return SR(t.type._context),On(t),null;case 17:return Co(t.type)&&dT(),On(t),null;case 19:if(Ze(lr),s=t.memoizedState,s===null)return On(t),null;if(n=(t.flags&128)!==0,i=s.rendering,i===null)if(n)Lb(s,!1);else{if(Hr!==0||e!==null&&(e.flags&128)!==0)for(e=t.child;e!==null;){if(i=wT(e),i!==null){for(t.flags|=128,Lb(s,!1),n=i.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),t.subtreeFlags=0,n=r,r=t.child;r!==null;)s=r,e=n,s.flags&=14680066,i=s.alternate,i===null?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=i.childLanes,s.lanes=i.lanes,s.child=i.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=i.memoizedProps,s.memoizedState=i.memoizedState,s.updateQueue=i.updateQueue,s.type=i.type,e=i.dependencies,s.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),r=r.sibling;return Ue(lr,lr.current&1|2),t.child}e=e.sibling}s.tail!==null&&kr()>rg&&(t.flags|=128,n=!0,Lb(s,!1),t.lanes=4194304)}else{if(!n)if(e=wT(i),e!==null){if(t.flags|=128,n=!0,r=e.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),Lb(s,!0),s.tail===null&&s.tailMode==="hidden"&&!i.alternate&&!rr)return On(t),null}else 2*kr()-s.renderingStartTime>rg&&r!==1073741824&&(t.flags|=128,n=!0,Lb(s,!1),t.lanes=4194304);s.isBackwards?(i.sibling=t.child,t.child=i):(r=s.last,r!==null?r.sibling=i:t.child=i,s.last=i)}return s.tail!==null?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=kr(),t.sibling=null,r=lr.current,Ue(lr,n?r&1|2:r&1),t):(On(t),null);case 22:case 23:return zR(),n=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==n&&(t.flags|=8192),n&&(t.mode&1)!==0?(Lo&1073741824)!==0&&(On(t),t.subtreeFlags&6&&(t.flags|=8192)):On(t),null;case 24:return null;case 25:return null}throw Error(ft(156,t.tag))}function dyt(e,t){switch(bR(t),t.tag){case 1:return Co(t.type)&&dT(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return tg(),Ze(wo),Ze(Pn),ER(),e=t.flags,(e&65536)!==0&&(e&128)===0?(t.flags=e&-65537|128,t):null;case 5:return IR(t),null;case 13:if(Ze(lr),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(ft(340));Zh()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Ze(lr),null;case 4:return tg(),null;case 10:return SR(t.type._context),null;case 22:case 23:return zR(),null;case 24:return null;default:return null}}var jk=!1,Fn=!1,hyt=typeof WeakSet=="function"?WeakSet:Set,Tt=null;function Wh(e,t){var r=e.ref;if(r!==null)if(typeof r=="function")try{r(null)}catch(n){yr(e,t,n)}else r.current=null}function KD(e,t,r){try{r()}catch(n){yr(e,t,n)}}var Hj=!1;function gyt(e,t){if(DD=cT,e=VK(),xR(e)){if("selectionStart"in e)var r={start:e.selectionStart,end:e.selectionEnd};else t:{r=(r=e.ownerDocument)&&r.defaultView||window;var n=r.getSelection&&r.getSelection();if(n&&n.rangeCount!==0){r=n.anchorNode;var o=n.anchorOffset,s=n.focusNode;n=n.focusOffset;try{r.nodeType,s.nodeType}catch(v){r=null;break t}var i=0,a=-1,l=-1,u=0,c=0,p=e,f=null;e:for(;;){for(var m;p!==r||o!==0&&p.nodeType!==3||(a=i+o),p!==s||n!==0&&p.nodeType!==3||(l=i+n),p.nodeType===3&&(i+=p.nodeValue.length),(m=p.firstChild)!==null;)f=p,p=m;for(;;){if(p===e)break e;if(f===r&&++u===o&&(a=i),f===s&&++c===n&&(l=i),(m=p.nextSibling)!==null)break;p=f,f=p.parentNode}p=m}r=a===-1||l===-1?null:{start:a,end:l}}else r=null}r=r||{start:0,end:0}}else r=null;for(RD={focusedElem:e,selectionRange:r},cT=!1,Tt=t;Tt!==null;)if(t=Tt,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Tt=e;else for(;Tt!==null;){t=Tt;try{var d=t.alternate;if((t.flags&1024)!==0)switch(t.tag){case 0:case 11:case 15:break;case 1:if(d!==null){var h=d.memoizedProps,x=d.memoizedState,g=t.stateNode,y=g.getSnapshotBeforeUpdate(t.elementType===t.type?h:ti(t.type,h),x);g.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var b=t.stateNode.containerInfo;b.nodeType===1?b.textContent="":b.nodeType===9&&b.documentElement&&b.removeChild(b.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(ft(163))}}catch(v){yr(t,t.return,v)}if(e=t.sibling,e!==null){e.return=t.return,Tt=e;break}Tt=t.return}return d=Hj,Hj=!1,d}function Yb(e,t,r){var n=t.updateQueue;if(n=n!==null?n.lastEffect:null,n!==null){var o=n=n.next;do{if((o.tag&e)===e){var s=o.destroy;o.destroy=void 0,s!==void 0&&KD(t,r,s)}o=o.next}while(o!==n)}}function LT(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var r=t=t.next;do{if((r.tag&e)===e){var n=r.create;r.destroy=n()}r=r.next}while(r!==t)}}function XD(e){var t=e.ref;if(t!==null){var r=e.stateNode;switch(e.tag){case 5:e=r;break;default:e=r}typeof t=="function"?t(e):t.current=e}}function M8(e){var t=e.alternate;t!==null&&(e.alternate=null,M8(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Gi],delete t[u0],delete t[FD],delete t[Zxt],delete t[Jxt])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function z8(e){return e.tag===5||e.tag===3||e.tag===4}function qj(e){t:for(;;){for(;e.sibling===null;){if(e.return===null||z8(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue t;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function YD(e,t,r){var n=e.tag;if(n===5||n===6)e=e.stateNode,t?r.nodeType===8?r.parentNode.insertBefore(e,t):r.insertBefore(e,t):(r.nodeType===8?(t=r.parentNode,t.insertBefore(e,r)):(t=r,t.appendChild(e)),r=r._reactRootContainer,r!=null||t.onclick!==null||(t.onclick=mT));else if(n!==4&&(e=e.child,e!==null))for(YD(e,t,r),e=e.sibling;e!==null;)YD(e,t,r),e=e.sibling}function QD(e,t,r){var n=e.tag;if(n===5||n===6)e=e.stateNode,t?r.insertBefore(e,t):r.appendChild(e);else if(n!==4&&(e=e.child,e!==null))for(QD(e,t,r),e=e.sibling;e!==null;)QD(e,t,r),e=e.sibling}var gn=null,ei=!1;function bc(e,t,r){for(r=r.child;r!==null;)B8(e,t,r),r=r.sibling}function B8(e,t,r){if(Ui&&typeof Ui.onCommitFiberUnmount=="function")try{Ui.onCommitFiberUnmount(_T,r)}catch(a){}switch(r.tag){case 5:Fn||Wh(r,t);case 6:var n=gn,o=ei;gn=null,bc(e,t,r),gn=n,ei=o,gn!==null&&(ei?(e=gn,r=r.stateNode,e.nodeType===8?e.parentNode.removeChild(r):e.removeChild(r)):gn.removeChild(r.stateNode));break;case 18:gn!==null&&(ei?(e=gn,r=r.stateNode,e.nodeType===8?tD(e.parentNode,r):e.nodeType===1&&tD(e,r),o0(e)):tD(gn,r.stateNode));break;case 4:n=gn,o=ei,gn=r.stateNode.containerInfo,ei=!0,bc(e,t,r),gn=n,ei=o;break;case 0:case 11:case 14:case 15:if(!Fn&&(n=r.updateQueue,n!==null&&(n=n.lastEffect,n!==null))){o=n=n.next;do{var s=o,i=s.destroy;s=s.tag,i!==void 0&&((s&2)!==0||(s&4)!==0)&&KD(r,t,i),o=o.next}while(o!==n)}bc(e,t,r);break;case 1:if(!Fn&&(Wh(r,t),n=r.stateNode,typeof n.componentWillUnmount=="function"))try{n.props=r.memoizedProps,n.state=r.memoizedState,n.componentWillUnmount()}catch(a){yr(r,t,a)}bc(e,t,r);break;case 21:bc(e,t,r);break;case 22:r.mode&1?(Fn=(n=Fn)||r.memoizedState!==null,bc(e,t,r),Fn=n):bc(e,t,r);break;default:bc(e,t,r)}}function jj(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var r=e.stateNode;r===null&&(r=e.stateNode=new hyt),t.forEach(function(n){var o=Tyt.bind(null,e,n);r.has(n)||(r.add(n),n.then(o,o))})}}function Js(e,t){var r=t.deletions;if(r!==null)for(var n=0;n<r.length;n++){var o=r[n];try{var s=e,i=t,a=i;t:for(;a!==null;){switch(a.tag){case 5:gn=a.stateNode,ei=!1;break t;case 3:gn=a.stateNode.containerInfo,ei=!0;break t;case 4:gn=a.stateNode.containerInfo,ei=!0;break t}a=a.return}if(gn===null)throw Error(ft(160));B8(s,i,o),gn=null,ei=!1;var l=o.alternate;l!==null&&(l.return=null),o.return=null}catch(u){yr(o,t,u)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)V8(t,e),t=t.sibling}function V8(e,t){var r=e.alternate,n=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(Js(t,e),Vi(e),n&4){try{Yb(3,e,e.return),LT(3,e)}catch(h){yr(e,e.return,h)}try{Yb(5,e,e.return)}catch(h){yr(e,e.return,h)}}break;case 1:Js(t,e),Vi(e),n&512&&r!==null&&Wh(r,r.return);break;case 5:if(Js(t,e),Vi(e),n&512&&r!==null&&Wh(r,r.return),e.flags&32){var o=e.stateNode;try{t0(o,"")}catch(h){yr(e,e.return,h)}}if(n&4&&(o=e.stateNode,o!=null)){var s=e.memoizedProps,i=r!==null?r.memoizedProps:s,a=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{a==="input"&&s.type==="radio"&&s.name!=null&&lK(o,s),wD(a,i);var u=wD(a,s);for(i=0;i<l.length;i+=2){var c=l[i],p=l[i+1];c==="style"?mK(o,p):c==="dangerouslySetInnerHTML"?pK(o,p):c==="children"?t0(o,p):oR(o,c,p,u)}switch(a){case"input":gD(o,s);break;case"textarea":uK(o,s);break;case"select":var f=o._wrapperState.wasMultiple;o._wrapperState.wasMultiple=!!s.multiple;var m=s.value;m!=null?Uh(o,!!s.multiple,m,!1):f!==!!s.multiple&&(s.defaultValue!=null?Uh(o,!!s.multiple,s.defaultValue,!0):Uh(o,!!s.multiple,s.multiple?[]:"",!1))}o[u0]=s}catch(h){yr(e,e.return,h)}}break;case 6:if(Js(t,e),Vi(e),n&4){if(e.stateNode===null)throw Error(ft(162));o=e.stateNode,s=e.memoizedProps;try{o.nodeValue=s}catch(h){yr(e,e.return,h)}}break;case 3:if(Js(t,e),Vi(e),n&4&&r!==null&&r.memoizedState.isDehydrated)try{o0(t.containerInfo)}catch(h){yr(e,e.return,h)}break;case 4:Js(t,e),Vi(e);break;case 13:Js(t,e),Vi(e),o=e.child,o.flags&8192&&(s=o.memoizedState!==null,o.stateNode.isHidden=s,!s||o.alternate!==null&&o.alternate.memoizedState!==null||(LR=kr())),n&4&&jj(e);break;case 22:if(c=r!==null&&r.memoizedState!==null,e.mode&1?(Fn=(u=Fn)||c,Js(t,e),Fn=u):Js(t,e),Vi(e),n&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!c&&(e.mode&1)!==0)for(Tt=e,c=e.child;c!==null;){for(p=Tt=c;Tt!==null;){switch(f=Tt,m=f.child,f.tag){case 0:case 11:case 14:case 15:Yb(4,f,f.return);break;case 1:Wh(f,f.return);var d=f.stateNode;if(typeof d.componentWillUnmount=="function"){n=f,r=f.return;try{t=n,d.props=t.memoizedProps,d.state=t.memoizedState,d.componentWillUnmount()}catch(h){yr(n,r,h)}}break;case 5:Wh(f,f.return);break;case 22:if(f.memoizedState!==null){Xj(p);continue}}m!==null?(m.return=f,Tt=m):Xj(p)}c=c.sibling}t:for(c=null,p=e;;){if(p.tag===5){if(c===null){c=p;try{o=p.stateNode,u?(s=o.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(a=p.stateNode,l=p.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=fK("display",i))}catch(h){yr(e,e.return,h)}}}else if(p.tag===6){if(c===null)try{p.stateNode.nodeValue=u?"":p.memoizedProps}catch(h){yr(e,e.return,h)}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===e)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===e)break t;for(;p.sibling===null;){if(p.return===null||p.return===e)break t;c===p&&(c=null),p=p.return}c===p&&(c=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:Js(t,e),Vi(e),n&4&&jj(e);break;case 21:break;default:Js(t,e),Vi(e)}}function Vi(e){var t=e.flags;if(t&2){try{t:{for(var r=e.return;r!==null;){if(z8(r)){var n=r;break t}r=r.return}throw Error(ft(160))}switch(n.tag){case 5:var o=n.stateNode;n.flags&32&&(t0(o,""),n.flags&=-33);var s=qj(e);QD(e,s,o);break;case 3:case 4:var i=n.stateNode.containerInfo,a=qj(e);YD(e,a,i);break;default:throw Error(ft(161))}}catch(l){yr(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function xyt(e,t,r){Tt=e,W8(e,t,r)}function W8(e,t,r){for(var n=(e.mode&1)!==0;Tt!==null;){var o=Tt,s=o.child;if(o.tag===22&&n){var i=o.memoizedState!==null||jk;if(!i){var a=o.alternate,l=a!==null&&a.memoizedState!==null||Fn;a=jk;var u=Fn;if(jk=i,(Fn=l)&&!u)for(Tt=o;Tt!==null;)i=Tt,l=i.child,i.tag===22&&i.memoizedState!==null?Yj(o):l!==null?(l.return=i,Tt=l):Yj(o);for(;s!==null;)Tt=s,W8(s,t,r),s=s.sibling;Tt=o,jk=a,Fn=u}Kj(e,t,r)}else(o.subtreeFlags&8772)!==0&&s!==null?(s.return=o,Tt=s):Kj(e,t,r)}}function Kj(e){for(;Tt!==null;){var t=Tt;if((t.flags&8772)!==0){var r=t.alternate;try{if((t.flags&8772)!==0)switch(t.tag){case 0:case 11:case 15:Fn||LT(5,t);break;case 1:var n=t.stateNode;if(t.flags&4&&!Fn)if(r===null)n.componentDidMount();else{var o=t.elementType===t.type?r.memoizedProps:ti(t.type,r.memoizedProps);n.componentDidUpdate(o,r.memoizedState,n.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;s!==null&&Dj(t,s,n);break;case 3:var i=t.updateQueue;if(i!==null){if(r=null,t.child!==null)switch(t.child.tag){case 5:r=t.child.stateNode;break;case 1:r=t.child.stateNode}Dj(t,i,r)}break;case 5:var a=t.stateNode;if(r===null&&t.flags&4){r=a;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&r.focus();break;case"img":l.src&&(r.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var u=t.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var p=c.dehydrated;p!==null&&o0(p)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(ft(163))}Fn||t.flags&512&&XD(t)}catch(f){yr(t,t.return,f)}}if(t===e){Tt=null;break}if(r=t.sibling,r!==null){r.return=t.return,Tt=r;break}Tt=t.return}}function Xj(e){for(;Tt!==null;){var t=Tt;if(t===e){Tt=null;break}var r=t.sibling;if(r!==null){r.return=t.return,Tt=r;break}Tt=t.return}}function Yj(e){for(;Tt!==null;){var t=Tt;try{switch(t.tag){case 0:case 11:case 15:var r=t.return;try{LT(4,t)}catch(l){yr(t,r,l)}break;case 1:var n=t.stateNode;if(typeof n.componentDidMount=="function"){var o=t.return;try{n.componentDidMount()}catch(l){yr(t,o,l)}}var s=t.return;try{XD(t)}catch(l){yr(t,s,l)}break;case 5:var i=t.return;try{XD(t)}catch(l){yr(t,i,l)}}}catch(l){yr(t,t.return,l)}if(t===e){Tt=null;break}var a=t.sibling;if(a!==null){a.return=t.return,Tt=a;break}Tt=t.return}}var yyt=Math.ceil,kT=Fl.ReactCurrentDispatcher,FR=Fl.ReactCurrentOwner,Ts=Fl.ReactCurrentBatchConfig,ue=0,sn=null,$r=null,xn=0,Lo=0,Gh=Lc(0),Hr=0,h0=null,kf=0,MT=0,PR=0,Qb=null,bo=null,LR=0,rg=1/0,Nl=null,TT=!1,ZD=null,Dc=null,Kk=!1,Tc=null,NT=0,Zb=0,JD=null,rT=-1,nT=0;function Xn(){return(ue&6)!==0?kr():rT!==-1?rT:rT=kr()}function Rc(e){return(e.mode&1)===0?1:(ue&2)!==0&&xn!==0?xn&-xn:eyt.transition!==null?(nT===0&&(nT=TK()),nT):(e=Te,e!==0||(e=window.event,e=e===void 0?16:RK(e.type)),e)}function oi(e,t,r,n){if(50<Zb)throw Zb=0,JD=null,Error(ft(185));g0(e,r,n),((ue&2)===0||e!==sn)&&(e===sn&&((ue&2)===0&&(MT|=r),Hr===4&&Sc(e,xn)),So(e,n),r===1&&ue===0&&(t.mode&1)===0&&(rg=kr()+500,OT&&Mc()))}function So(e,t){var r=e.callbackNode;nxt(e,t);var n=uT(e,e===sn?xn:0);if(n===0)r!==null&&oj(r),e.callbackNode=null,e.callbackPriority=0;else if(t=n&-n,e.callbackPriority!==t){if(r!=null&&oj(r),t===1)e.tag===0?tyt(Qj.bind(null,e)):QK(Qj.bind(null,e)),Yxt(function(){(ue&6)===0&&Mc()}),r=null;else{switch(NK(n)){case 1:r=uR;break;case 4:r=SK;break;case 16:r=lT;break;case 536870912:r=kK;break;default:r=lT}r=Y8(r,G8.bind(null,e))}e.callbackPriority=t,e.callbackNode=r}}function G8(e,t){if(rT=-1,nT=0,(ue&6)!==0)throw Error(ft(327));var r=e.callbackNode;if(Xh()&&e.callbackNode!==r)return null;var n=uT(e,e===sn?xn:0);if(n===0)return null;if((n&30)!==0||(n&e.expiredLanes)!==0||t)t=IT(e,n);else{t=n;var o=ue;ue|=2;var s=H8();(sn!==e||xn!==t)&&(Nl=null,rg=kr()+500,bf(e,t));do try{wyt();break}catch(a){U8(e,a)}while(1);CR(),kT.current=s,ue=o,$r!==null?t=0:(sn=null,xn=0,t=Hr)}if(t!==0){if(t===2&&(o=ND(e),o!==0&&(n=o,t=tR(e,o))),t===1)throw r=h0,bf(e,0),Sc(e,n),So(e,kr()),r;if(t===6)Sc(e,n);else{if(o=e.current.alternate,(n&30)===0&&!byt(o)&&(t=IT(e,n),t===2&&(s=ND(e),s!==0&&(n=s,t=tR(e,s))),t===1))throw r=h0,bf(e,0),Sc(e,n),So(e,kr()),r;switch(e.finishedWork=o,e.finishedLanes=n,t){case 0:case 1:throw Error(ft(345));case 2:hf(e,bo,Nl);break;case 3:if(Sc(e,n),(n&130023424)===n&&(t=LR+500-kr(),10<t)){if(uT(e,0)!==0)break;if(o=e.suspendedLanes,(o&n)!==n){Xn(),e.pingedLanes|=e.suspendedLanes&o;break}e.timeoutHandle=OD(hf.bind(null,e,bo,Nl),t);break}hf(e,bo,Nl);break;case 4:if(Sc(e,n),(n&4194240)===n)break;for(t=e.eventTimes,o=-1;0<n;){var i=31-ni(n);s=1<<i,i=t[i],i>o&&(o=i),n&=~s}if(n=o,n=kr()-n,n=(120>n?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*yyt(n/1960))-n,10<n){e.timeoutHandle=OD(hf.bind(null,e,bo,Nl),n);break}hf(e,bo,Nl);break;case 5:hf(e,bo,Nl);break;default:throw Error(ft(329))}}}return So(e,kr()),e.callbackNode===r?G8.bind(null,e):null}function tR(e,t){var r=Qb;return e.current.memoizedState.isDehydrated&&(bf(e,t).flags|=256),e=IT(e,t),e!==2&&(t=bo,bo=r,t!==null&&eR(t)),e}function eR(e){bo===null?bo=e:bo.push.apply(bo,e)}function byt(e){for(var t=e;;){if(t.flags&16384){var r=t.updateQueue;if(r!==null&&(r=r.stores,r!==null))for(var n=0;n<r.length;n++){var o=r[n],s=o.getSnapshot;o=o.value;try{if(!si(s(),o))return!1}catch(i){return!1}}}if(r=t.child,t.subtreeFlags&16384&&r!==null)r.return=t,t=r;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Sc(e,t){for(t&=~PR,t&=~MT,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var r=31-ni(t),n=1<<r;e[r]=-1,t&=~n}}function Qj(e){if((ue&6)!==0)throw Error(ft(327));Xh();var t=uT(e,0);if((t&1)===0)return So(e,kr()),null;var r=IT(e,t);if(e.tag!==0&&r===2){var n=ND(e);n!==0&&(t=n,r=tR(e,n))}if(r===1)throw r=h0,bf(e,0),Sc(e,t),So(e,kr()),r;if(r===6)throw Error(ft(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,hf(e,bo,Nl),So(e,kr()),null}function MR(e,t){var r=ue;ue|=1;try{return e(t)}finally{ue=r,ue===0&&(rg=kr()+500,OT&&Mc())}}function Tf(e){Tc!==null&&Tc.tag===0&&(ue&6)===0&&Xh();var t=ue;ue|=1;var r=Ts.transition,n=Te;try{if(Ts.transition=null,Te=1,e)return e()}finally{Te=n,Ts.transition=r,ue=t,(ue&6)===0&&Mc()}}function zR(){Lo=Gh.current,Ze(Gh)}function bf(e,t){e.finishedWork=null,e.finishedLanes=0;var r=e.timeoutHandle;if(r!==-1&&(e.timeoutHandle=-1,Xxt(r)),$r!==null)for(r=$r.return;r!==null;){var n=r;switch(bR(n),n.tag){case 1:n=n.type.childContextTypes,n!=null&&dT();break;case 3:tg(),Ze(wo),Ze(Pn),ER();break;case 5:IR(n);break;case 4:tg();break;case 13:Ze(lr);break;case 19:Ze(lr);break;case 10:SR(n.type._context);break;case 22:case 23:zR()}r=r.return}if(sn=e,$r=e=$c(e.current,null),xn=Lo=t,Hr=0,h0=null,PR=MT=kf=0,bo=Qb=null,xf!==null){for(t=0;t<xf.length;t++)if(r=xf[t],n=r.interleaved,n!==null){r.interleaved=null;var o=n.next,s=r.pending;if(s!==null){var i=s.next;s.next=o,n.next=i}r.pending=n}xf=null}return e}function U8(e,t){do{var r=$r;try{if(CR(),Jk.current=ST,CT){for(var n=ur.memoizedState;n!==null;){var o=n.queue;o!==null&&(o.pending=null),n=n.next}CT=!1}if(Sf=0,on=Ur=ur=null,Xb=!1,f0=0,FR.current=null,r===null||r.return===null){Hr=1,h0=t,$r=null;break}t:{var s=e,i=r.return,a=r,l=t;if(t=xn,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=a,p=c.tag;if((c.mode&1)===0&&(p===0||p===11||p===15)){var f=c.alternate;f?(c.updateQueue=f.updateQueue,c.memoizedState=f.memoizedState,c.lanes=f.lanes):(c.updateQueue=null,c.memoizedState=null)}var m=Mj(i);if(m!==null){m.flags&=-257,zj(m,i,a,s,t),m.mode&1&&Lj(s,u,t),t=m,l=u;var d=t.updateQueue;if(d===null){var h=new Set;h.add(l),t.updateQueue=h}else d.add(l);break t}else{if((t&1)===0){Lj(s,u,t),BR();break t}l=Error(ft(426))}}else if(rr&&a.mode&1){var x=Mj(i);if(x!==null){(x.flags&65536)===0&&(x.flags|=256),zj(x,i,a,s,t),vR(eg(l,a));break t}}s=l=eg(l,a),Hr!==4&&(Hr=2),Qb===null?Qb=[s]:Qb.push(s),s=i;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t;var g=I8(s,l,t);Aj(s,g);break t;case 1:a=l;var y=s.type,b=s.stateNode;if((s.flags&128)===0&&(typeof y.getDerivedStateFromError=="function"||b!==null&&typeof b.componentDidCatch=="function"&&(Dc===null||!Dc.has(b)))){s.flags|=65536,t&=-t,s.lanes|=t;var v=E8(s,a,t);Aj(s,v);break t}}s=s.return}while(s!==null)}j8(r)}catch(C){t=C,$r===r&&r!==null&&($r=r=r.return);continue}break}while(1)}function H8(){var e=kT.current;return kT.current=ST,e===null?ST:e}function BR(){(Hr===0||Hr===3||Hr===2)&&(Hr=4),sn===null||(kf&268435455)===0&&(MT&268435455)===0||Sc(sn,xn)}function IT(e,t){var r=ue;ue|=2;var n=H8();(sn!==e||xn!==t)&&(Nl=null,bf(e,t));do try{vyt();break}catch(o){U8(e,o)}while(1);if(CR(),ue=r,kT.current=n,$r!==null)throw Error(ft(261));return sn=null,xn=0,Hr}function vyt(){for(;$r!==null;)q8($r)}function wyt(){for(;$r!==null&&!Kgt();)q8($r)}function q8(e){var t=X8(e.alternate,e,Lo);e.memoizedProps=e.pendingProps,t===null?j8(e):$r=t,FR.current=null}function j8(e){var t=e;do{var r=t.alternate;if(e=t.return,(t.flags&32768)===0){if(r=myt(r,t,Lo),r!==null){$r=r;return}}else{if(r=dyt(r,t),r!==null){r.flags&=32767,$r=r;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{Hr=6,$r=null;return}}if(t=t.sibling,t!==null){$r=t;return}$r=t=e}while(t!==null);Hr===0&&(Hr=5)}function hf(e,t,r){var n=Te,o=Ts.transition;try{Ts.transition=null,Te=1,Cyt(e,t,r,n)}finally{Ts.transition=o,Te=n}return null}function Cyt(e,t,r,n){do Xh();while(Tc!==null);if((ue&6)!==0)throw Error(ft(327));r=e.finishedWork;var o=e.finishedLanes;if(r===null)return null;if(e.finishedWork=null,e.finishedLanes=0,r===e.current)throw Error(ft(177));e.callbackNode=null,e.callbackPriority=0;var s=r.lanes|r.childLanes;if(oxt(e,s),e===sn&&($r=sn=null,xn=0),(r.subtreeFlags&2064)===0&&(r.flags&2064)===0||Kk||(Kk=!0,Y8(lT,function(){return Xh(),null})),s=(r.flags&15990)!==0,(r.subtreeFlags&15990)!==0||s){s=Ts.transition,Ts.transition=null;var i=Te;Te=1;var a=ue;ue|=4,FR.current=null,gyt(e,r),V8(r,e),Uxt(RD),cT=!!DD,RD=DD=null,e.current=r,xyt(r,e,o),Xgt(),ue=a,Te=i,Ts.transition=s}else e.current=r;if(Kk&&(Kk=!1,Tc=e,NT=o),s=e.pendingLanes,s===0&&(Dc=null),Zgt(r.stateNode,n),So(e,kr()),t!==null)for(n=e.onRecoverableError,r=0;r<t.length;r++)o=t[r],n(o.value,{componentStack:o.stack,digest:o.digest});if(TT)throw TT=!1,e=ZD,ZD=null,e;return(NT&1)!==0&&e.tag!==0&&Xh(),s=e.pendingLanes,(s&1)!==0?e===JD?Zb++:(Zb=0,JD=e):Zb=0,Mc(),null}function Xh(){if(Tc!==null){var e=NK(NT),t=Ts.transition,r=Te;try{if(Ts.transition=null,Te=16>e?16:e,Tc===null)var n=!1;else{if(e=Tc,Tc=null,NT=0,(ue&6)!==0)throw Error(ft(331));var o=ue;for(ue|=4,Tt=e.current;Tt!==null;){var s=Tt,i=s.child;if((Tt.flags&16)!==0){var a=s.deletions;if(a!==null){for(var l=0;l<a.length;l++){var u=a[l];for(Tt=u;Tt!==null;){var c=Tt;switch(c.tag){case 0:case 11:case 15:Yb(8,c,s)}var p=c.child;if(p!==null)p.return=c,Tt=p;else for(;Tt!==null;){c=Tt;var f=c.sibling,m=c.return;if(M8(c),c===u){Tt=null;break}if(f!==null){f.return=m,Tt=f;break}Tt=m}}}var d=s.alternate;if(d!==null){var h=d.child;if(h!==null){d.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(h!==null)}}Tt=s}}if((s.subtreeFlags&2064)!==0&&i!==null)i.return=s,Tt=i;else t:for(;Tt!==null;){if(s=Tt,(s.flags&2048)!==0)switch(s.tag){case 0:case 11:case 15:Yb(9,s,s.return)}var g=s.sibling;if(g!==null){g.return=s.return,Tt=g;break t}Tt=s.return}}var y=e.current;for(Tt=y;Tt!==null;){i=Tt;var b=i.child;if((i.subtreeFlags&2064)!==0&&b!==null)b.return=i,Tt=b;else t:for(i=y;Tt!==null;){if(a=Tt,(a.flags&2048)!==0)try{switch(a.tag){case 0:case 11:case 15:LT(9,a)}}catch(C){yr(a,a.return,C)}if(a===i){Tt=null;break t}var v=a.sibling;if(v!==null){v.return=a.return,Tt=v;break t}Tt=a.return}}if(ue=o,Mc(),Ui&&typeof Ui.onPostCommitFiberRoot=="function")try{Ui.onPostCommitFiberRoot(_T,e)}catch(C){}n=!0}return n}finally{Te=r,Ts.transition=t}}return!1}function Zj(e,t,r){t=eg(r,t),t=I8(e,t,1),e=Ac(e,t,1),t=Xn(),e!==null&&(g0(e,1,t),So(e,t))}function yr(e,t,r){if(e.tag===3)Zj(e,e,r);else for(;t!==null;){if(t.tag===3){Zj(t,e,r);break}else if(t.tag===1){var n=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof n.componentDidCatch=="function"&&(Dc===null||!Dc.has(n))){e=eg(r,e),e=E8(t,e,1),t=Ac(t,e,1),e=Xn(),t!==null&&(g0(t,1,e),So(t,e));break}}t=t.return}}function Syt(e,t,r){var n=e.pingCache;n!==null&&n.delete(t),t=Xn(),e.pingedLanes|=e.suspendedLanes&r,sn===e&&(xn&r)===r&&(Hr===4||Hr===3&&(xn&130023424)===xn&&500>kr()-LR?bf(e,0):PR|=r),So(e,t)}function K8(e,t){t===0&&((e.mode&1)===0?t=1:(t=Ok,Ok<<=1,(Ok&130023424)===0&&(Ok=4194304)));var r=Xn();e=$l(e,t),e!==null&&(g0(e,t,r),So(e,r))}function kyt(e){var t=e.memoizedState,r=0;t!==null&&(r=t.retryLane),K8(e,r)}function Tyt(e,t){var r=0;switch(e.tag){case 13:var n=e.stateNode,o=e.memoizedState;o!==null&&(r=o.retryLane);break;case 19:n=e.stateNode;break;default:throw Error(ft(314))}n!==null&&n.delete(t),K8(e,r)}var X8;X8=function(e,t,r){if(e!==null)if(e.memoizedProps!==t.pendingProps||wo.current)vo=!0;else{if((e.lanes&r)===0&&(t.flags&128)===0)return vo=!1,fyt(e,t,r);vo=(e.flags&131072)!==0}else vo=!1,rr&&(t.flags&1048576)!==0&&ZK(t,xT,t.index);switch(t.lanes=0,t.tag){case 2:var n=t.type;eT(e,t),e=t.pendingProps;var o=Qh(t,Pn.current);Kh(t,r),o=AR(null,t,n,e,o,r);var s=DR();return t.flags|=1,typeof o=="object"&&o!==null&&typeof o.render=="function"&&o.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Co(n)?(s=!0,hT(t)):s=!1,t.memoizedState=o.state!==null&&o.state!==void 0?o.state:null,TR(t),o.updater=FT,t.stateNode=o,o._reactInternals=t,VD(t,n,e,r),t=UD(null,t,n,!0,s,r)):(t.tag=0,rr&&s&&yR(t),Kn(null,t,o,r),t=t.child),t;case 16:n=t.elementType;t:{switch(eT(e,t),e=t.pendingProps,o=n._init,n=o(n._payload),t.type=n,o=t.tag=Iyt(n),e=ti(n,e),o){case 0:t=GD(null,t,n,e,r);break t;case 1:t=Wj(null,t,n,e,r);break t;case 11:t=Bj(null,t,n,e,r);break t;case 14:t=Vj(null,t,n,ti(n.type,e),r);break t}throw Error(ft(306,n,""))}return t;case 0:return n=t.type,o=t.pendingProps,o=t.elementType===n?o:ti(n,o),GD(e,t,n,o,r);case 1:return n=t.type,o=t.pendingProps,o=t.elementType===n?o:ti(n,o),Wj(e,t,n,o,r);case 3:t:{if(R8(t),e===null)throw Error(ft(387));n=t.pendingProps,s=t.memoizedState,o=s.element,r8(e,t),vT(t,n,null,r);var i=t.memoizedState;if(n=i.element,s.isDehydrated)if(s={element:n,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=s,t.memoizedState=s,t.flags&256){o=eg(Error(ft(423)),t),t=Gj(e,t,n,r,o);break t}else if(n!==o){o=eg(Error(ft(424)),t),t=Gj(e,t,n,r,o);break t}else for(Mo=_c(t.stateNode.containerInfo.firstChild),zo=t,rr=!0,ri=null,r=i8(t,null,n,r),t.child=r;r;)r.flags=r.flags&-3|4096,r=r.sibling;else{if(Zh(),n===o){t=Ol(e,t,r);break t}Kn(e,t,n,r)}t=t.child}return t;case 5:return a8(t),e===null&&MD(t),n=t.type,o=t.pendingProps,s=e!==null?e.memoizedProps:null,i=o.children,$D(n,o)?i=null:s!==null&&$D(n,s)&&(t.flags|=32),D8(e,t),Kn(e,t,i,r),t.child;case 6:return e===null&&MD(t),null;case 13:return $8(e,t,r);case 4:return NR(t,t.stateNode.containerInfo),n=t.pendingProps,e===null?t.child=Jh(t,null,n,r):Kn(e,t,n,r),t.child;case 11:return n=t.type,o=t.pendingProps,o=t.elementType===n?o:ti(n,o),Bj(e,t,n,o,r);case 7:return Kn(e,t,t.pendingProps,r),t.child;case 8:return Kn(e,t,t.pendingProps.children,r),t.child;case 12:return Kn(e,t,t.pendingProps.children,r),t.child;case 10:t:{if(n=t.type._context,o=t.pendingProps,s=t.memoizedProps,i=o.value,Ue(yT,n._currentValue),n._currentValue=i,s!==null)if(si(s.value,i)){if(s.children===o.children&&!wo.current){t=Ol(e,t,r);break t}}else for(s=t.child,s!==null&&(s.return=t);s!==null;){var a=s.dependencies;if(a!==null){i=s.child;for(var l=a.firstContext;l!==null;){if(l.context===n){if(s.tag===1){l=Al(-1,r&-r),l.tag=2;var u=s.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}s.lanes|=r,l=s.alternate,l!==null&&(l.lanes|=r),zD(s.return,r,t),a.lanes|=r;break}l=l.next}}else if(s.tag===10)i=s.type===t.type?null:s.child;else if(s.tag===18){if(i=s.return,i===null)throw Error(ft(341));i.lanes|=r,a=i.alternate,a!==null&&(a.lanes|=r),zD(i,r,t),i=s.sibling}else i=s.child;if(i!==null)i.return=s;else for(i=s;i!==null;){if(i===t){i=null;break}if(s=i.sibling,s!==null){s.return=i.return,i=s;break}i=i.return}s=i}Kn(e,t,o.children,r),t=t.child}return t;case 9:return o=t.type,n=t.pendingProps.children,Kh(t,r),o=Ns(o),n=n(o),t.flags|=1,Kn(e,t,n,r),t.child;case 14:return n=t.type,o=ti(n,t.pendingProps),o=ti(n.type,o),Vj(e,t,n,o,r);case 15:return _8(e,t,t.type,t.pendingProps,r);case 17:return n=t.type,o=t.pendingProps,o=t.elementType===n?o:ti(n,o),eT(e,t),t.tag=1,Co(n)?(e=!0,hT(t)):e=!1,Kh(t,r),o8(t,n,o),VD(t,n,o,r),UD(null,t,n,!0,e,r);case 19:return O8(e,t,r);case 22:return A8(e,t,r)}throw Error(ft(156,t.tag))};function Y8(e,t){return CK(e,t)}function Nyt(e,t,r,n){this.tag=e,this.key=r,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=n,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ks(e,t,r,n){return new Nyt(e,t,r,n)}function VR(e){return e=e.prototype,!(!e||!e.isReactComponent)}function Iyt(e){if(typeof e=="function")return VR(e)?1:0;if(e!=null){if(e=e.$$typeof,e===iR)return 11;if(e===aR)return 14}return 2}function $c(e,t){var r=e.alternate;return r===null?(r=ks(e.tag,t,e.key,e.mode),r.elementType=e.elementType,r.type=e.type,r.stateNode=e.stateNode,r.alternate=e,e.alternate=r):(r.pendingProps=t,r.type=e.type,r.flags=0,r.subtreeFlags=0,r.deletions=null),r.flags=e.flags&14680064,r.childLanes=e.childLanes,r.lanes=e.lanes,r.child=e.child,r.memoizedProps=e.memoizedProps,r.memoizedState=e.memoizedState,r.updateQueue=e.updateQueue,t=e.dependencies,r.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},r.sibling=e.sibling,r.index=e.index,r.ref=e.ref,r}function oT(e,t,r,n,o,s){var i=2;if(n=e,typeof e=="function")VR(e)&&(i=1);else if(typeof e=="string")i=5;else t:switch(e){case $h:return vf(r.children,o,s,t);case sR:i=8,o|=8;break;case pD:return e=ks(12,r,t,o|2),e.elementType=pD,e.lanes=s,e;case fD:return e=ks(13,r,t,o),e.elementType=fD,e.lanes=s,e;case mD:return e=ks(19,r,t,o),e.elementType=mD,e.lanes=s,e;case sK:return zT(r,o,s,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case nK:i=10;break t;case oK:i=9;break t;case iR:i=11;break t;case aR:i=14;break t;case vc:i=16,n=null;break t}throw Error(ft(130,e==null?e:typeof e,""))}return t=ks(i,r,t,o),t.elementType=e,t.type=n,t.lanes=s,t}function vf(e,t,r,n){return e=ks(7,e,n,t),e.lanes=r,e}function zT(e,t,r,n){return e=ks(22,e,n,t),e.elementType=sK,e.lanes=r,e.stateNode={isHidden:!1},e}function lD(e,t,r){return e=ks(6,e,null,t),e.lanes=r,e}function uD(e,t,r){return t=ks(4,e.children!==null?e.children:[],e.key,t),t.lanes=r,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Eyt(e,t,r,n,o){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=qA(0),this.expirationTimes=qA(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=qA(0),this.identifierPrefix=n,this.onRecoverableError=o,this.mutableSourceEagerHydrationData=null}function WR(e,t,r,n,o,s,i,a,l){return e=new Eyt(e,t,r,a,l),t===1?(t=1,s===!0&&(t|=8)):t=0,s=ks(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:n,isDehydrated:r,cache:null,transitions:null,pendingSuspenseBoundaries:null},TR(s),e}function _yt(e,t,r){var n=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Rh,key:n==null?null:""+n,children:e,containerInfo:t,implementation:r}}function Q8(e){if(!e)return Fc;e=e._reactInternals;t:{if(If(e)!==e||e.tag!==1)throw Error(ft(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break t;case 1:if(Co(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break t}}t=t.return}while(t!==null);throw Error(ft(171))}if(e.tag===1){var r=e.type;if(Co(r))return YK(e,r,t)}return t}function Z8(e,t,r,n,o,s,i,a,l){return e=WR(r,n,!0,e,o,s,i,a,l),e.context=Q8(null),r=e.current,n=Xn(),o=Rc(r),s=Al(n,o),s.callback=t!=null?t:null,Ac(r,s,o),e.current.lanes=o,g0(e,o,n),So(e,n),e}function BT(e,t,r,n){var o=t.current,s=Xn(),i=Rc(o);return r=Q8(r),t.context===null?t.context=r:t.pendingContext=r,t=Al(s,i),t.payload={element:e},n=n===void 0?null:n,n!==null&&(t.callback=n),e=Ac(o,t,i),e!==null&&(oi(e,o,i,s),Zk(e,o,i)),i}function ET(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Jj(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var r=e.retryLane;e.retryLane=r!==0&&r<t?r:t}}function GR(e,t){Jj(e,t),(e=e.alternate)&&Jj(e,t)}function Ayt(){return null}var J8=typeof reportError=="function"?reportError:function(e){console.error(e)};function UR(e){this._internalRoot=e}VT.prototype.render=UR.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(ft(409));BT(e,t,null,null)};VT.prototype.unmount=UR.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Tf(function(){BT(null,e,null,null)}),t[Rl]=null}};function VT(e){this._internalRoot=e}VT.prototype.unstable_scheduleHydration=function(e){if(e){var t=_K();e={blockedOn:null,target:e,priority:t};for(var r=0;r<Cc.length&&t!==0&&t<Cc[r].priority;r++);Cc.splice(r,0,e),r===0&&DK(e)}};function HR(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function WT(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function tK(){}function Dyt(e,t,r,n,o){if(o){if(typeof n=="function"){var s=n;n=function(){var u=ET(i);s.call(u)}}var i=Z8(t,n,e,0,null,!1,!1,"",tK);return e._reactRootContainer=i,e[Rl]=i.current,a0(e.nodeType===8?e.parentNode:e),Tf(),i}for(;o=e.lastChild;)e.removeChild(o);if(typeof n=="function"){var a=n;n=function(){var u=ET(l);a.call(u)}}var l=WR(e,0,!1,null,null,!1,!1,"",tK);return e._reactRootContainer=l,e[Rl]=l.current,a0(e.nodeType===8?e.parentNode:e),Tf(function(){BT(t,l,r,n)}),l}function GT(e,t,r,n,o){var s=r._reactRootContainer;if(s){var i=s;if(typeof o=="function"){var a=o;o=function(){var l=ET(i);a.call(l)}}BT(t,i,e,o)}else i=Dyt(r,t,e,o,n);return ET(i)}IK=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var r=Wb(t.pendingLanes);r!==0&&(cR(t,r|1),So(t,kr()),(ue&6)===0&&(rg=kr()+500,Mc()))}break;case 13:Tf(function(){var n=$l(e,1);if(n!==null){var o=Xn();oi(n,e,1,o)}}),GR(e,1)}};pR=function(e){if(e.tag===13){var t=$l(e,134217728);if(t!==null){var r=Xn();oi(t,e,134217728,r)}GR(e,134217728)}};EK=function(e){if(e.tag===13){var t=Rc(e),r=$l(e,t);if(r!==null){var n=Xn();oi(r,e,t,n)}GR(e,t)}};_K=function(){return Te};AK=function(e,t){var r=Te;try{return Te=e,t()}finally{Te=r}};SD=function(e,t,r){switch(t){case"input":if(gD(e,r),t=r.name,r.type==="radio"&&t!=null){for(r=e;r.parentNode;)r=r.parentNode;for(r=r.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<r.length;t++){var n=r[t];if(n!==e&&n.form===e.form){var o=$T(n);if(!o)throw Error(ft(90));aK(n),gD(n,o)}}}break;case"textarea":uK(e,r);break;case"select":t=r.value,t!=null&&Uh(e,!!r.multiple,t,!1)}};gK=MR;xK=Tf;var Ryt={usingClientEntryPoint:!1,Events:[y0,Lh,$T,dK,hK,MR]},Mb={findFiberByHostInstance:gf,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},$yt={bundleType:Mb.bundleType,version:Mb.version,rendererPackageName:Mb.rendererPackageName,rendererConfig:Mb.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Fl.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=vK(e),e===null?null:e.stateNode},findFiberByHostInstance:Mb.findFiberByHostInstance||Ayt,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!="undefined"&&(zb=__REACT_DEVTOOLS_GLOBAL_HOOK__,!zb.isDisabled&&zb.supportsFiber))try{_T=zb.inject($yt),Ui=zb}catch(e){}var zb;Wo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Ryt;Wo.createPortal=function(e,t){var r=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!HR(t))throw Error(ft(200));return _yt(e,t,null,r)};Wo.createRoot=function(e,t){if(!HR(e))throw Error(ft(299));var r=!1,n="",o=J8;return t!=null&&(t.unstable_strictMode===!0&&(r=!0),t.identifierPrefix!==void 0&&(n=t.identifierPrefix),t.onRecoverableError!==void 0&&(o=t.onRecoverableError)),t=WR(e,1,!1,null,null,r,!1,n,o),e[Rl]=t.current,a0(e.nodeType===8?e.parentNode:e),new UR(t)};Wo.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(ft(188)):(e=Object.keys(e).join(","),Error(ft(268,e)));return e=vK(t),e=e===null?null:e.stateNode,e};Wo.flushSync=function(e){return Tf(e)};Wo.hydrate=function(e,t,r){if(!WT(t))throw Error(ft(200));return GT(null,e,t,!0,r)};Wo.hydrateRoot=function(e,t,r){if(!HR(e))throw Error(ft(405));var n=r!=null&&r.hydratedSources||null,o=!1,s="",i=J8;if(r!=null&&(r.unstable_strictMode===!0&&(o=!0),r.identifierPrefix!==void 0&&(s=r.identifierPrefix),r.onRecoverableError!==void 0&&(i=r.onRecoverableError)),t=Z8(t,null,e,1,r!=null?r:null,o,!1,s,i),e[Rl]=t.current,a0(e),n)for(e=0;e<n.length;e++)r=n[e],o=r._getVersion,o=o(r._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[r,o]:t.mutableSourceEagerHydrationData.push(r,o);return new VT(t)};Wo.render=function(e,t,r){if(!WT(t))throw Error(ft(200));return GT(null,e,t,!1,r)};Wo.unmountComponentAtNode=function(e){if(!WT(e))throw Error(ft(40));return e._reactRootContainer?(Tf(function(){GT(null,null,e,!1,function(){e._reactRootContainer=null,e[Rl]=null})}),!0):!1};Wo.unstable_batchedUpdates=MR;Wo.unstable_renderSubtreeIntoContainer=function(e,t,r,n){if(!WT(r))throw Error(ft(200));if(e==null||e._reactInternals===void 0)throw Error(ft(38));return GT(e,t,r,!1,n)};Wo.version="18.2.0-next-9e3b772b8-20220608"});var qR=Ut((cKe,rX)=>{"use strict";function eX(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__=="undefined"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(eX)}catch(e){console.error(e)}}eX(),rX.exports=tX()});var TX=Ut((o7e,kX)=>{var mbt=typeof Element!="undefined",dbt=typeof Map=="function",hbt=typeof Set=="function",gbt=typeof ArrayBuffer=="function"&&!!ArrayBuffer.isView;function YT(e,t){if(e===t)return!0;if(e&&t&&typeof e=="object"&&typeof t=="object"){if(e.constructor!==t.constructor)return!1;var r,n,o;if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(n=r;n--!==0;)if(!YT(e[n],t[n]))return!1;return!0}var s;if(dbt&&e instanceof Map&&t instanceof Map){if(e.size!==t.size)return!1;for(s=e.entries();!(n=s.next()).done;)if(!t.has(n.value[0]))return!1;for(s=e.entries();!(n=s.next()).done;)if(!YT(n.value[1],t.get(n.value[0])))return!1;return!0}if(hbt&&e instanceof Set&&t instanceof Set){if(e.size!==t.size)return!1;for(s=e.entries();!(n=s.next()).done;)if(!t.has(n.value[0]))return!1;return!0}if(gbt&&ArrayBuffer.isView(e)&&ArrayBuffer.isView(t)){if(r=e.length,r!=t.length)return!1;for(n=r;n--!==0;)if(e[n]!==t[n])return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if(o=Object.keys(e),r=o.length,r!==Object.keys(t).length)return!1;for(n=r;n--!==0;)if(!Object.prototype.hasOwnProperty.call(t,o[n]))return!1;if(mbt&&e instanceof Element)return!1;for(n=r;n--!==0;)if(!((o[n]==="_owner"||o[n]==="__v"||o[n]==="__o")&&e.$$typeof)&&!YT(e[o[n]],t[o[n]]))return!1;return!0}return e!==e&&t!==t}kX.exports=function(t,r){try{return YT(t,r)}catch(n){if((n.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw n}}});var zX=Ut(p$=>{"use strict";var MX=qR();p$.createRoot=MX.createRoot,p$.hydrateRoot=MX.hydrateRoot;var z7e});var Ebt={};Zn(Ebt,{AttentionHeads:()=>tP,AttentionPattern:()=>qg,AttentionPatterns:()=>Pq,ColoredTokens:()=>I0,ColoredTokensMulti:()=>FX,Hello:()=>LX,TextNeuronActivations:()=>GX,TokenLogProbs:()=>qX,TopkSamples:()=>jX,TopkTokens:()=>XX,render:()=>WX});var un=Yt(oe()),oa=Yt(Uc());var Yc=Yt(oe());function Os(){}var $N=(()=>{let e=0;return()=>e++})();function ze(e){return e===null||typeof e=="undefined"}function tr(e){if(Array.isArray&&Array.isArray(e))return!0;let t=Object.prototype.toString.call(e);return t.slice(0,7)==="[object"&&t.slice(-6)==="Array]"}function se(e){return e!==null&&Object.prototype.toString.call(e)==="[object Object]"}function Nr(e){return(typeof e=="number"||e instanceof Number)&&isFinite(+e)}function zn(e,t){return Nr(e)?e:t}function Je(e,t){return typeof e=="undefined"?t:e}var ON=(e,t)=>typeof e=="string"&&e.endsWith("%")?parseFloat(e)/100*t:+e;function er(e,t,r){if(e&&typeof e.call=="function")return e.apply(r,t)}function ge(e,t,r,n){let o,s,i;if(tr(e))if(s=e.length,n)for(o=s-1;o>=0;o--)t.call(r,e[o],o);else for(o=0;o<s;o++)t.call(r,e[o],o);else if(se(e))for(i=Object.keys(e),s=i.length,o=0;o<s;o++)t.call(r,e[i[o]],i[o])}function Kf(e,t){let r,n,o,s;if(!e||!t||e.length!==t.length)return!1;for(r=0,n=e.length;r<n;++r)if(o=e[r],s=t[r],o.datasetIndex!==s.datasetIndex||o.index!==s.index)return!1;return!0}function vg(e){if(tr(e))return e.map(vg);if(se(e)){let t=Object.create(null),r=Object.keys(e),n=r.length,o=0;for(;o<n;++o)t[r[o]]=vg(e[r[o]]);return t}return e}function TO(e){return["__proto__","prototype","constructor"].indexOf(e)===-1}function NO(e,t,r,n){if(!TO(e))return;let o=t[e],s=r[e];se(o)&&se(s)?qc(o,s,n):t[e]=vg(s)}function qc(e,t,r){let n=tr(t)?t:[t],o=n.length;if(!se(e))return e;r=r||{};let s=r.merger||NO,i;for(let a=0;a<o;++a){if(i=n[a],!se(i))continue;let l=Object.keys(i);for(let u=0,c=l.length;u<c;++u)s(l[u],e,i,r)}return e}function jc(e,t){return qc(e,t,{merger:IO})}function IO(e,t,r){if(!TO(e))return;let n=t[e],o=r[e];se(n)&&se(o)?jc(n,o):Object.prototype.hasOwnProperty.call(t,e)||(t[e]=vg(o))}var hO={"":e=>e,x:e=>e.x,y:e=>e.y};function EO(e){let t=e.split("."),r=[],n="";for(let o of t)n+=o,n.endsWith("\\")?n=n.slice(0,-1)+".":(r.push(n),n="");return r}function O7(e){let t=EO(e);return r=>{for(let n of t){if(n==="")break;r=r&&r[n]}return r}}function Xf(e,t){return(hO[t]||(hO[t]=O7(t)))(e)}function Cg(e){return e.charAt(0).toUpperCase()+e.slice(1)}var No=e=>typeof e!="undefined",ui=e=>typeof e=="function",lv=(e,t)=>{if(e.size!==t.size)return!1;for(let r of e)if(!t.has(r))return!1;return!0};function FN(e){return e.type==="mouseup"||e.type==="click"||e.type==="contextmenu"}var Xr=Math.PI,To=2*Xr,F7=To+Xr,wg=Number.POSITIVE_INFINITY,_O=Xr/180,Cn=Xr/2,ql=Xr/4,AN=Xr*2/3,ci=Math.log10,Yf=Math.sign;function Qf(e,t,r){return Math.abs(e-t)<r}function uv(e){let t=Math.round(e);e=Qf(e,t,e/1e3)?t:e;let r=Math.pow(10,Math.floor(ci(e))),n=e/r;return(n<=1?1:n<=2?2:n<=5?5:10)*r}function PN(e){let t=[],r=Math.sqrt(e),n;for(n=1;n<r;n++)e%n===0&&(t.push(n),t.push(e/n));return r===(r|0)&&t.push(r),t.sort((o,s)=>o-s).pop(),t}function Zf(e){return!isNaN(parseFloat(e))&&isFinite(e)}function LN(e,t){let r=Math.round(e);return r-t<=e&&r+t>=e}function cv(e,t,r){let n,o,s;for(n=0,o=e.length;n<o;n++)s=e[n][r],isNaN(s)||(t.min=Math.min(t.min,s),t.max=Math.max(t.max,s))}function pi(e){return e*(Xr/180)}function Sg(e){return e*(180/Xr)}function pv(e){if(!Nr(e))return;let t=1,r=0;for(;Math.round(e*t)/t!==e;)t*=10,r++;return r}function MN(e,t){let r=t.x-e.x,n=t.y-e.y,o=Math.sqrt(r*r+n*n),s=Math.atan2(n,r);return s<-.5*Xr&&(s+=To),{angle:s,distance:o}}function zN(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}function jo(e){return(e%To+To)%To}function BN(e,t,r,n){let o=jo(e),s=jo(t),i=jo(r),a=jo(s-o),l=jo(i-o),u=jo(o-s),c=jo(o-i);return o===s||o===i||n&&s===i||a>l&&u<c}function Ko(e,t,r){return Math.max(t,Math.min(r,e))}function VN(e){return Ko(e,-32768,32767)}function kg(e,t,r){r=r||(i=>e[i]<t);let n=e.length-1,o=0,s;for(;n-o>1;)s=o+n>>1,r(s)?o=s:n=s;return{lo:o,hi:n}}var Tg=(e,t,r,n)=>kg(e,r,n?o=>{let s=e[o][t];return s<r||s===r&&e[o+1][t]===r}:o=>e[o][t]<r),WN=(e,t,r)=>kg(e,r,n=>e[n][t]>=r);function GN(e,t,r){let n=0,o=e.length;for(;n<o&&e[n]<t;)n++;for(;o>n&&e[o-1]>r;)o--;return n>0||o<e.length?e.slice(n,o):e}var AO=["push","pop","shift","splice","unshift"];function UN(e,t){if(e._chartjs){e._chartjs.listeners.push(t);return}Object.defineProperty(e,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),AO.forEach(r=>{let n="_onData"+Cg(r),o=e[r];Object.defineProperty(e,r,{configurable:!0,enumerable:!1,value(...s){let i=o.apply(this,s);return e._chartjs.listeners.forEach(a=>{typeof a[n]=="function"&&a[n](...s)}),i}})})}function fv(e,t){let r=e._chartjs;if(!r)return;let n=r.listeners,o=n.indexOf(t);o!==-1&&n.splice(o,1),!(n.length>0)&&(AO.forEach(s=>{delete e[s]}),delete e._chartjs)}function HN(e){let t=new Set,r,n;for(r=0,n=e.length;r<n;++r)t.add(e[r]);return t.size===n?e:Array.from(t)}var mv=function(){return typeof window=="undefined"?function(e){return e()}:window.requestAnimationFrame}();function dv(e,t){let r=!1;return function(...n){r||(r=!0,mv.call(window,()=>{r=!1,e.apply(t,n)}))}}function qN(e,t){let r;return function(...n){return t?(clearTimeout(r),r=setTimeout(e,t,n)):e.apply(this,n),t}}var jN=e=>e==="start"?"left":e==="end"?"right":"center",hv=(e,t,r)=>e==="start"?t:e==="end"?r:(t+r)/2;var tv=e=>e===0||e===1,gO=(e,t,r)=>-(Math.pow(2,10*(e-=1))*Math.sin((e-t)*To/r)),xO=(e,t,r)=>Math.pow(2,-10*e)*Math.sin((e-t)*To/r)+1,sv={linear:e=>e,easeInQuad:e=>e*e,easeOutQuad:e=>-e*(e-2),easeInOutQuad:e=>(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1),easeInCubic:e=>e*e*e,easeOutCubic:e=>(e-=1)*e*e+1,easeInOutCubic:e=>(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2),easeInQuart:e=>e*e*e*e,easeOutQuart:e=>-((e-=1)*e*e*e-1),easeInOutQuart:e=>(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2),easeInQuint:e=>e*e*e*e*e,easeOutQuint:e=>(e-=1)*e*e*e*e+1,easeInOutQuint:e=>(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2),easeInSine:e=>-Math.cos(e*Cn)+1,easeOutSine:e=>Math.sin(e*Cn),easeInOutSine:e=>-.5*(Math.cos(Xr*e)-1),easeInExpo:e=>e===0?0:Math.pow(2,10*(e-1)),easeOutExpo:e=>e===1?1:-Math.pow(2,-10*e)+1,easeInOutExpo:e=>tv(e)?e:e<.5?.5*Math.pow(2,10*(e*2-1)):.5*(-Math.pow(2,-10*(e*2-1))+2),easeInCirc:e=>e>=1?e:-(Math.sqrt(1-e*e)-1),easeOutCirc:e=>Math.sqrt(1-(e-=1)*e),easeInOutCirc:e=>(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1),easeInElastic:e=>tv(e)?e:gO(e,.075,.3),easeOutElastic:e=>tv(e)?e:xO(e,.075,.3),easeInOutElastic(e){return tv(e)?e:e<.5?.5*gO(e*2,.1125,.45):.5+.5*xO(e*2-1,.1125,.45)},easeInBack(e){return e*e*((1.70158+1)*e-1.70158)},easeOutBack(e){return(e-=1)*e*((1.70158+1)*e+1.70158)+1},easeInOutBack(e){let t=1.70158;return(e/=.5)<1?.5*(e*e*(((t*=1.525)+1)*e-t)):.5*((e-=2)*e*(((t*=1.525)+1)*e+t)+2)},easeInBounce:e=>1-sv.easeOutBounce(1-e),easeOutBounce(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},easeInOutBounce:e=>e<.5?sv.easeInBounce(e*2)*.5:sv.easeOutBounce(e*2-1)*.5+.5},gv=sv;function Ng(e){return e+.5|0}var jl=(e,t,r)=>Math.max(Math.min(e,r),t);function yg(e){return jl(Ng(e*2.55),0,255)}function Kl(e){return jl(Ng(e*255),0,255)}function ji(e){return jl(Ng(e/2.55)/100,0,1)}function yO(e){return jl(Ng(e*100),0,100)}var qo={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},DN=[..."0123456789ABCDEF"],P7=e=>DN[e&15],L7=e=>DN[(e&240)>>4]+DN[e&15],ev=e=>(e&240)>>4===(e&15),M7=e=>ev(e.r)&&ev(e.g)&&ev(e.b)&&ev(e.a);function z7(e){var t=e.length,r;return e[0]==="#"&&(t===4||t===5?r={r:255&qo[e[1]]*17,g:255&qo[e[2]]*17,b:255&qo[e[3]]*17,a:t===5?qo[e[4]]*17:255}:(t===7||t===9)&&(r={r:qo[e[1]]<<4|qo[e[2]],g:qo[e[3]]<<4|qo[e[4]],b:qo[e[5]]<<4|qo[e[6]],a:t===9?qo[e[7]]<<4|qo[e[8]]:255})),r}var B7=(e,t)=>e<255?t(e):"";function V7(e){var t=M7(e)?P7:L7;return e?"#"+t(e.r)+t(e.g)+t(e.b)+B7(e.a,t):void 0}var W7=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function DO(e,t,r){let n=t*Math.min(r,1-r),o=(s,i=(s+e/30)%12)=>r-n*Math.max(Math.min(i-3,9-i,1),-1);return[o(0),o(8),o(4)]}function G7(e,t,r){let n=(o,s=(o+e/60)%6)=>r-r*t*Math.max(Math.min(s,4-s,1),0);return[n(5),n(3),n(1)]}function U7(e,t,r){let n=DO(e,1,.5),o;for(t+r>1&&(o=1/(t+r),t*=o,r*=o),o=0;o<3;o++)n[o]*=1-t-r,n[o]+=t;return n}function H7(e,t,r,n,o){return e===o?(t-r)/n+(t<r?6:0):t===o?(r-e)/n+2:(e-t)/n+4}function KN(e){let r=e.r/255,n=e.g/255,o=e.b/255,s=Math.max(r,n,o),i=Math.min(r,n,o),a=(s+i)/2,l,u,c;return s!==i&&(c=s-i,u=a>.5?c/(2-s-i):c/(s+i),l=H7(r,n,o,c,s),l=l*60+.5),[l|0,u||0,a]}function XN(e,t,r,n){return(Array.isArray(t)?e(t[0],t[1],t[2]):e(t,r,n)).map(Kl)}function YN(e,t,r){return XN(DO,e,t,r)}function q7(e,t,r){return XN(U7,e,t,r)}function j7(e,t,r){return XN(G7,e,t,r)}function RO(e){return(e%360+360)%360}function K7(e){let t=W7.exec(e),r=255,n;if(!t)return;t[5]!==n&&(r=t[6]?yg(+t[5]):Kl(+t[5]));let o=RO(+t[2]),s=+t[3]/100,i=+t[4]/100;return t[1]==="hwb"?n=q7(o,s,i):t[1]==="hsv"?n=j7(o,s,i):n=YN(o,s,i),{r:n[0],g:n[1],b:n[2],a:r}}function X7(e,t){var r=KN(e);r[0]=RO(r[0]+t),r=YN(r),e.r=r[0],e.g=r[1],e.b=r[2]}function Y7(e){if(!e)return;let t=KN(e),r=t[0],n=yO(t[1]),o=yO(t[2]);return e.a<255?`hsla(${r}, ${n}%, ${o}%, ${ji(e.a)})`:`hsl(${r}, ${n}%, ${o}%)`}var bO={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},vO={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function Q7(){let e={},t=Object.keys(vO),r=Object.keys(bO),n,o,s,i,a;for(n=0;n<t.length;n++){for(i=a=t[n],o=0;o<r.length;o++)s=r[o],a=a.replace(s,bO[s]);s=parseInt(vO[i],16),e[a]=[s>>16&255,s>>8&255,s&255]}return e}var rv;function Z7(e){rv||(rv=Q7(),rv.transparent=[0,0,0,0]);let t=rv[e.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:t.length===4?t[3]:255}}var J7=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function tY(e){let t=J7.exec(e),r=255,n,o,s;if(!!t){if(t[7]!==n){let i=+t[7];r=t[8]?yg(i):jl(i*255,0,255)}return n=+t[1],o=+t[3],s=+t[5],n=255&(t[2]?yg(n):jl(n,0,255)),o=255&(t[4]?yg(o):jl(o,0,255)),s=255&(t[6]?yg(s):jl(s,0,255)),{r:n,g:o,b:s,a:r}}}function eY(e){return e&&(e.a<255?`rgba(${e.r}, ${e.g}, ${e.b}, ${ji(e.a)})`:`rgb(${e.r}, ${e.g}, ${e.b})`)}var EN=e=>e<=.0031308?e*12.92:Math.pow(e,1/2.4)*1.055-.055,Hf=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);function rY(e,t,r){let n=Hf(ji(e.r)),o=Hf(ji(e.g)),s=Hf(ji(e.b));return{r:Kl(EN(n+r*(Hf(ji(t.r))-n))),g:Kl(EN(o+r*(Hf(ji(t.g))-o))),b:Kl(EN(s+r*(Hf(ji(t.b))-s))),a:e.a+r*(t.a-e.a)}}function nv(e,t,r){if(e){let n=KN(e);n[t]=Math.max(0,Math.min(n[t]+n[t]*r,t===0?360:1)),n=YN(n),e.r=n[0],e.g=n[1],e.b=n[2]}}function $O(e,t){return e&&Object.assign(t||{},e)}function wO(e){var t={r:0,g:0,b:0,a:255};return Array.isArray(e)?e.length>=3&&(t={r:e[0],g:e[1],b:e[2],a:255},e.length>3&&(t.a=Kl(e[3]))):(t=$O(e,{r:0,g:0,b:0,a:1}),t.a=Kl(t.a)),t}function nY(e){return e.charAt(0)==="r"?tY(e):K7(e)}var qf=class{constructor(t){if(t instanceof qf)return t;let r=typeof t,n;r==="object"?n=wO(t):r==="string"&&(n=z7(t)||Z7(t)||nY(t)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var t=$O(this._rgb);return t&&(t.a=ji(t.a)),t}set rgb(t){this._rgb=wO(t)}rgbString(){return this._valid?eY(this._rgb):void 0}hexString(){return this._valid?V7(this._rgb):void 0}hslString(){return this._valid?Y7(this._rgb):void 0}mix(t,r){if(t){let n=this.rgb,o=t.rgb,s,i=r===s?.5:r,a=2*i-1,l=n.a-o.a,u=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;s=1-u,n.r=255&u*n.r+s*o.r+.5,n.g=255&u*n.g+s*o.g+.5,n.b=255&u*n.b+s*o.b+.5,n.a=i*n.a+(1-i)*o.a,this.rgb=n}return this}interpolate(t,r){return t&&(this._rgb=rY(this._rgb,t._rgb,r)),this}clone(){return new qf(this.rgb)}alpha(t){return this._rgb.a=Kl(t),this}clearer(t){let r=this._rgb;return r.a*=1-t,this}greyscale(){let t=this._rgb,r=Ng(t.r*.3+t.g*.59+t.b*.11);return t.r=t.g=t.b=r,this}opaquer(t){let r=this._rgb;return r.a*=1+t,this}negate(){let t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return nv(this._rgb,2,t),this}darken(t){return nv(this._rgb,2,-t),this}saturate(t){return nv(this._rgb,1,t),this}desaturate(t){return nv(this._rgb,1,-t),this}rotate(t){return X7(this._rgb,t),this}};function OO(e){return new qf(e)}function QN(e){if(e&&typeof e=="object"){let t=e.toString();return t==="[object CanvasPattern]"||t==="[object CanvasGradient]"}return!1}function xv(e){return QN(e)?e:OO(e)}function iv(e){return QN(e)?e:OO(e).saturate(.5).darken(.1).hexString()}var oY=["x","y","borderWidth","radius","tension"],sY=["color","borderColor","backgroundColor"];function iY(e){e.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),e.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>t!=="onProgress"&&t!=="onComplete"&&t!=="fn"}),e.set("animations",{colors:{type:"color",properties:sY},numbers:{type:"number",properties:oY}}),e.describe("animations",{_fallback:"animation"}),e.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>t|0}}}})}function aY(e){e.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}var CO=new Map;function lY(e,t){t=t||{};let r=e+JSON.stringify(t),n=CO.get(r);return n||(n=new Intl.NumberFormat(e,t),CO.set(r,n)),n}function Ig(e,t,r){return lY(t,r).format(e)}var FO={values(e){return tr(e)?e:""+e},numeric(e,t,r){if(e===0)return"0";let n=this.chart.options.locale,o,s=e;if(r.length>1){let u=Math.max(Math.abs(r[0].value),Math.abs(r[r.length-1].value));(u<1e-4||u>1e15)&&(o="scientific"),s=uY(e,r)}let i=ci(Math.abs(s)),a=Math.max(Math.min(-1*Math.floor(i),20),0),l={notation:o,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),Ig(e,n,l)},logarithmic(e,t,r){if(e===0)return"0";let n=r[t].significand||e/Math.pow(10,Math.floor(ci(e)));return[1,2,3,5,10,15].includes(n)||t>.8*r.length?FO.numeric.call(this,e,t,r):""}};function uY(e,t){let r=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(r)>=1&&e!==Math.floor(e)&&(r=e-Math.floor(e)),r}var Eg={formatters:FO};function cY(e){e.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,r)=>r.lineWidth,tickColor:(t,r)=>r.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Eg.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),e.route("scale.ticks","color","","color"),e.route("scale.grid","color","","borderColor"),e.route("scale.border","color","","borderColor"),e.route("scale.title","color","","color"),e.describe("scale",{_fallback:!1,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&t!=="callback"&&t!=="parser",_indexable:t=>t!=="borderDash"&&t!=="tickBorderDash"&&t!=="dash"}),e.describe("scales",{_fallback:"scale"}),e.describe("scale.ticks",{_scriptable:t=>t!=="backdropPadding"&&t!=="callback",_indexable:t=>t!=="backdropPadding"})}var Yl=Object.create(null),yv=Object.create(null);function bg(e,t){if(!t)return e;let r=t.split(".");for(let n=0,o=r.length;n<o;++n){let s=r[n];e=e[s]||(e[s]=Object.create(null))}return e}function _N(e,t,r){return typeof t=="string"?qc(bg(e,t),r):qc(bg(e,""),t)}var RN=class{constructor(t,r){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=n=>n.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(n,o)=>iv(o.backgroundColor),this.hoverBorderColor=(n,o)=>iv(o.borderColor),this.hoverColor=(n,o)=>iv(o.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(r)}set(t,r){return _N(this,t,r)}get(t){return bg(this,t)}describe(t,r){return _N(yv,t,r)}override(t,r){return _N(Yl,t,r)}route(t,r,n,o){let s=bg(this,t),i=bg(this,n),a="_"+r;Object.defineProperties(s,{[a]:{value:s[r],writable:!0},[r]:{enumerable:!0,get(){let l=this[a],u=i[o];return se(l)?Object.assign({},u,l):Je(l,u)},set(l){this[a]=l}}})}apply(t){t.forEach(r=>r(this))}},vr=new RN({_scriptable:e=>!e.startsWith("on"),_indexable:e=>e!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[iY,aY,cY]);function PO(e){return!e||ze(e.size)||ze(e.family)?null:(e.style?e.style+" ":"")+(e.weight?e.weight+" ":"")+e.size+"px "+e.family}function jf(e,t,r,n,o){let s=t[o];return s||(s=t[o]=e.measureText(o).width,r.push(o)),s>n&&(n=s),n}function ZN(e,t,r,n){n=n||{};let o=n.data=n.data||{},s=n.garbageCollect=n.garbageCollect||[];n.font!==t&&(o=n.data={},s=n.garbageCollect=[],n.font=t),e.save(),e.font=t;let i=0,a=r.length,l,u,c,p,f;for(l=0;l<a;l++)if(p=r[l],p!=null&&tr(p)!==!0)i=jf(e,o,s,i,p);else if(tr(p))for(u=0,c=p.length;u<c;u++)f=p[u],f!=null&&!tr(f)&&(i=jf(e,o,s,i,f));e.restore();let m=s.length/2;if(m>r.length){for(l=0;l<m;l++)delete o[s[l]];s.splice(0,m)}return i}function Ki(e,t,r){let n=e.currentDevicePixelRatio,o=r!==0?Math.max(r/2,.5):0;return Math.round((t-o)*n)/n+o}function bv(e,t){t=t||e.getContext("2d"),t.save(),t.resetTransform(),t.clearRect(0,0,e.width,e.height),t.restore()}function vv(e,t,r,n){JN(e,t,r,n,null)}function JN(e,t,r,n,o){let s,i,a,l,u,c,p,f,m=t.pointStyle,d=t.rotation,h=t.radius,x=(d||0)*_O;if(m&&typeof m=="object"&&(s=m.toString(),s==="[object HTMLImageElement]"||s==="[object HTMLCanvasElement]")){e.save(),e.translate(r,n),e.rotate(x),e.drawImage(m,-m.width/2,-m.height/2,m.width,m.height),e.restore();return}if(!(isNaN(h)||h<=0)){switch(e.beginPath(),m){default:o?e.ellipse(r,n,o/2,h,0,0,To):e.arc(r,n,h,0,To),e.closePath();break;case"triangle":c=o?o/2:h,e.moveTo(r+Math.sin(x)*c,n-Math.cos(x)*h),x+=AN,e.lineTo(r+Math.sin(x)*c,n-Math.cos(x)*h),x+=AN,e.lineTo(r+Math.sin(x)*c,n-Math.cos(x)*h),e.closePath();break;case"rectRounded":u=h*.516,l=h-u,i=Math.cos(x+ql)*l,p=Math.cos(x+ql)*(o?o/2-u:l),a=Math.sin(x+ql)*l,f=Math.sin(x+ql)*(o?o/2-u:l),e.arc(r-p,n-a,u,x-Xr,x-Cn),e.arc(r+f,n-i,u,x-Cn,x),e.arc(r+p,n+a,u,x,x+Cn),e.arc(r-f,n+i,u,x+Cn,x+Xr),e.closePath();break;case"rect":if(!d){l=Math.SQRT1_2*h,c=o?o/2:l,e.rect(r-c,n-l,2*c,2*l);break}x+=ql;case"rectRot":p=Math.cos(x)*(o?o/2:h),i=Math.cos(x)*h,a=Math.sin(x)*h,f=Math.sin(x)*(o?o/2:h),e.moveTo(r-p,n-a),e.lineTo(r+f,n-i),e.lineTo(r+p,n+a),e.lineTo(r-f,n+i),e.closePath();break;case"crossRot":x+=ql;case"cross":p=Math.cos(x)*(o?o/2:h),i=Math.cos(x)*h,a=Math.sin(x)*h,f=Math.sin(x)*(o?o/2:h),e.moveTo(r-p,n-a),e.lineTo(r+p,n+a),e.moveTo(r+f,n-i),e.lineTo(r-f,n+i);break;case"star":p=Math.cos(x)*(o?o/2:h),i=Math.cos(x)*h,a=Math.sin(x)*h,f=Math.sin(x)*(o?o/2:h),e.moveTo(r-p,n-a),e.lineTo(r+p,n+a),e.moveTo(r+f,n-i),e.lineTo(r-f,n+i),x+=ql,p=Math.cos(x)*(o?o/2:h),i=Math.cos(x)*h,a=Math.sin(x)*h,f=Math.sin(x)*(o?o/2:h),e.moveTo(r-p,n-a),e.lineTo(r+p,n+a),e.moveTo(r+f,n-i),e.lineTo(r-f,n+i);break;case"line":i=o?o/2:Math.cos(x)*h,a=Math.sin(x)*h,e.moveTo(r-i,n-a),e.lineTo(r+i,n+a);break;case"dash":e.moveTo(r,n),e.lineTo(r+Math.cos(x)*(o?o/2:h),n+Math.sin(x)*h);break}e.fill(),t.borderWidth>0&&e.stroke()}}function wv(e,t,r){return r=r||.5,!t||e&&e.x>t.left-r&&e.x<t.right+r&&e.y>t.top-r&&e.y<t.bottom+r}function Cv(e,t){e.save(),e.beginPath(),e.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),e.clip()}function Sv(e){e.restore()}function Jf(e,t,r,n,o,s={}){let i=tr(t)?t:[t],a=s.strokeWidth>0&&s.strokeColor!=="",l,u;for(e.save(),e.font=o.string,pY(e,s),l=0;l<i.length;++l)u=i[l],s.backdrop&&mY(e,s.backdrop),a&&(s.strokeColor&&(e.strokeStyle=s.strokeColor),ze(s.strokeWidth)||(e.lineWidth=s.strokeWidth),e.strokeText(u,r,n,s.maxWidth)),e.fillText(u,r,n,s.maxWidth),fY(e,r,n,u,s),n+=o.lineHeight;e.restore()}function pY(e,t){t.translation&&e.translate(t.translation[0],t.translation[1]),ze(t.rotation)||e.rotate(t.rotation),t.color&&(e.fillStyle=t.color),t.textAlign&&(e.textAlign=t.textAlign),t.textBaseline&&(e.textBaseline=t.textBaseline)}function fY(e,t,r,n,o){if(o.strikethrough||o.underline){let s=e.measureText(n),i=t-s.actualBoundingBoxLeft,a=t+s.actualBoundingBoxRight,l=r-s.actualBoundingBoxAscent,u=r+s.actualBoundingBoxDescent,c=o.strikethrough?(l+u)/2:u;e.strokeStyle=e.fillStyle,e.beginPath(),e.lineWidth=o.decorationWidth||2,e.moveTo(i,c),e.lineTo(a,c),e.stroke()}}function mY(e,t){let r=e.fillStyle;e.fillStyle=t.color,e.fillRect(t.left,t.top,t.width,t.height),e.fillStyle=r}function Xi(e,t){let{x:r,y:n,w:o,h:s,radius:i}=t;e.arc(r+i.topLeft,n+i.topLeft,i.topLeft,-Cn,Xr,!0),e.lineTo(r,n+s-i.bottomLeft),e.arc(r+i.bottomLeft,n+s-i.bottomLeft,i.bottomLeft,Xr,Cn,!0),e.lineTo(r+o-i.bottomRight,n+s),e.arc(r+o-i.bottomRight,n+s-i.bottomRight,i.bottomRight,Cn,0,!0),e.lineTo(r+o,n+i.topRight),e.arc(r+o-i.topRight,n+i.topRight,i.topRight,0,-Cn,!0),e.lineTo(r+i.topLeft,n)}var dY=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,hY=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function LO(e,t){let r=(""+e).match(dY);if(!r||r[1]==="normal")return t*1.2;switch(e=+r[2],r[3]){case"px":return e;case"%":e/=100;break}return t*e}var gY=e=>+e||0;function kv(e,t){let r={},n=se(t),o=n?Object.keys(t):t,s=se(e)?n?i=>Je(e[i],e[t[i]]):i=>e[i]:()=>e;for(let i of o)r[i]=gY(s(i));return r}function tI(e){return kv(e,{top:"y",right:"x",bottom:"y",left:"x"})}function Yi(e){return kv(e,["topLeft","topRight","bottomLeft","bottomRight"])}function to(e){let t=tI(e);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function Bn(e,t){e=e||{},t=t||vr.font;let r=Je(e.size,t.size);typeof r=="string"&&(r=parseInt(r,10));let n=Je(e.style,t.style);n&&!(""+n).match(hY)&&(console.warn('Invalid font style specified: "'+n+'"'),n=void 0);let o={family:Je(e.family,t.family),lineHeight:LO(Je(e.lineHeight,t.lineHeight),r),size:r,style:n,weight:Je(e.weight,t.weight),string:""};return o.string=PO(o),o}function tm(e,t,r,n){let o=!0,s,i,a;for(s=0,i=e.length;s<i;++s)if(a=e[s],a!==void 0&&(t!==void 0&&typeof a=="function"&&(a=a(t),o=!1),r!==void 0&&tr(a)&&(a=a[r%a.length],o=!1),a!==void 0))return n&&!o&&(n.cacheable=!1),a}function eI(e,t,r){let{min:n,max:o}=e,s=ON(t,(o-n)/2),i=(a,l)=>r&&a===0?0:a+l;return{min:i(n,-Math.abs(s)),max:i(o,s)}}function Qi(e,t){return Object.assign(Object.create(e),t)}function _g(e,t=[""],r=e,n,o=()=>e[0]){No(n)||(n=BO("_fallback",e));let s={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:e,_rootScopes:r,_fallback:n,_getTarget:o,override:i=>_g([i,...e],t,r,n)};return new Proxy(s,{deleteProperty(i,a){return delete i[a],delete i._keys,delete e[0][a],!0},get(i,a){return MO(i,a,()=>kY(a,t,e,i))},getOwnPropertyDescriptor(i,a){return Reflect.getOwnPropertyDescriptor(i._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(e[0])},has(i,a){return kO(i).includes(a)},ownKeys(i){return kO(i)},set(i,a,l){let u=i._storage||(i._storage=o());return i[a]=u[a]=l,delete i._keys,!0}})}function Xl(e,t,r,n){let o={_cacheable:!1,_proxy:e,_context:t,_subProxy:r,_stack:new Set,_descriptors:Tv(e,n),setContext:s=>Xl(e,s,r,n),override:s=>Xl(e.override(s),t,r,n)};return new Proxy(o,{deleteProperty(s,i){return delete s[i],delete e[i],!0},get(s,i,a){return MO(s,i,()=>yY(s,i,a))},getOwnPropertyDescriptor(s,i){return s._descriptors.allKeys?Reflect.has(e,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(e,i)},getPrototypeOf(){return Reflect.getPrototypeOf(e)},has(s,i){return Reflect.has(e,i)},ownKeys(){return Reflect.ownKeys(e)},set(s,i,a){return e[i]=a,delete s[i],!0}})}function Tv(e,t={scriptable:!0,indexable:!0}){let{_scriptable:r=t.scriptable,_indexable:n=t.indexable,_allKeys:o=t.allKeys}=e;return{allKeys:o,scriptable:r,indexable:n,isScriptable:ui(r)?r:()=>r,isIndexable:ui(n)?n:()=>n}}var xY=(e,t)=>e?e+Cg(t):t,rI=(e,t)=>se(t)&&e!=="adapters"&&(Object.getPrototypeOf(t)===null||t.constructor===Object);function MO(e,t,r){if(Object.prototype.hasOwnProperty.call(e,t))return e[t];let n=r();return e[t]=n,n}function yY(e,t,r){let{_proxy:n,_context:o,_subProxy:s,_descriptors:i}=e,a=n[t];return ui(a)&&i.isScriptable(t)&&(a=bY(t,a,e,r)),tr(a)&&a.length&&(a=vY(t,a,e,i.isIndexable)),rI(t,a)&&(a=Xl(a,o,s&&s[t],i)),a}function bY(e,t,r,n){let{_proxy:o,_context:s,_subProxy:i,_stack:a}=r;if(a.has(e))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+e);return a.add(e),t=t(s,i||n),a.delete(e),rI(e,t)&&(t=nI(o._scopes,o,e,t)),t}function vY(e,t,r,n){let{_proxy:o,_context:s,_subProxy:i,_descriptors:a}=r;if(No(s.index)&&n(e))t=t[s.index%t.length];else if(se(t[0])){let l=t,u=o._scopes.filter(c=>c!==l);t=[];for(let c of l){let p=nI(u,o,e,c);t.push(Xl(p,s,i&&i[e],a))}}return t}function zO(e,t,r){return ui(e)?e(t,r):e}var wY=(e,t)=>e===!0?t:typeof e=="string"?Xf(t,e):void 0;function CY(e,t,r,n,o){for(let s of t){let i=wY(r,s);if(i){e.add(i);let a=zO(i._fallback,r,o);if(No(a)&&a!==r&&a!==n)return a}else if(i===!1&&No(n)&&r!==n)return null}return!1}function nI(e,t,r,n){let o=t._rootScopes,s=zO(t._fallback,r,n),i=[...e,...o],a=new Set;a.add(n);let l=SO(a,i,r,s||r,n);return l===null||No(s)&&s!==r&&(l=SO(a,i,s,l,n),l===null)?!1:_g(Array.from(a),[""],o,s,()=>SY(t,r,n))}function SO(e,t,r,n,o){for(;r;)r=CY(e,t,r,n,o);return r}function SY(e,t,r){let n=e._getTarget();t in n||(n[t]={});let o=n[t];return tr(o)&&se(r)?r:o||{}}function kY(e,t,r,n){let o;for(let s of t)if(o=BO(xY(s,e),r),No(o))return rI(e,o)?nI(r,n,e,o):o}function BO(e,t){for(let r of t){if(!r)continue;let n=r[e];if(No(n))return n}}function kO(e){let t=e._keys;return t||(t=e._keys=TY(e._scopes)),t}function TY(e){let t=new Set;for(let r of e)for(let n of Object.keys(r).filter(o=>!o.startsWith("_")))t.add(n);return Array.from(t)}var c0t=Number.EPSILON||1e-14;function Nv(){return typeof window!="undefined"&&typeof document!="undefined"}function Ag(e){let t=e.parentNode;return t&&t.toString()==="[object ShadowRoot]"&&(t=t.host),t}function av(e,t,r){let n;return typeof e=="string"?(n=parseInt(e,10),e.indexOf("%")!==-1&&(n=n/100*t.parentNode[r])):n=e,n}var Iv=e=>e.ownerDocument.defaultView.getComputedStyle(e,null);function VO(e,t){return Iv(e).getPropertyValue(t)}var NY=["top","right","bottom","left"];function Hc(e,t,r){let n={};r=r?"-"+r:"";for(let o=0;o<4;o++){let s=NY[o];n[s]=parseFloat(e[t+"-"+s+r])||0}return n.width=n.left+n.right,n.height=n.top+n.bottom,n}var IY=(e,t,r)=>(e>0||t>0)&&(!r||!r.shadowRoot);function EY(e,t){let r=e.touches,n=r&&r.length?r[0]:e,{offsetX:o,offsetY:s}=n,i=!1,a,l;if(IY(o,s,e.target))a=o,l=s;else{let u=t.getBoundingClientRect();a=n.clientX-u.left,l=n.clientY-u.top,i=!0}return{x:a,y:l,box:i}}function Zi(e,t){if("native"in e)return e;let{canvas:r,currentDevicePixelRatio:n}=t,o=Iv(r),s=o.boxSizing==="border-box",i=Hc(o,"padding"),a=Hc(o,"border","width"),{x:l,y:u,box:c}=EY(e,r),p=i.left+(c&&a.left),f=i.top+(c&&a.top),{width:m,height:d}=t;return s&&(m-=i.width+a.width,d-=i.height+a.height),{x:Math.round((l-p)/m*r.width/n),y:Math.round((u-f)/d*r.height/n)}}function _Y(e,t,r){let n,o;if(t===void 0||r===void 0){let s=Ag(e);if(!s)t=e.clientWidth,r=e.clientHeight;else{let i=s.getBoundingClientRect(),a=Iv(s),l=Hc(a,"border","width"),u=Hc(a,"padding");t=i.width-u.width-l.width,r=i.height-u.height-l.height,n=av(a.maxWidth,s,"clientWidth"),o=av(a.maxHeight,s,"clientHeight")}}return{width:t,height:r,maxWidth:n||wg,maxHeight:o||wg}}var ov=e=>Math.round(e*10)/10;function oI(e,t,r,n){let o=Iv(e),s=Hc(o,"margin"),i=av(o.maxWidth,e,"clientWidth")||wg,a=av(o.maxHeight,e,"clientHeight")||wg,l=_Y(e,t,r),{width:u,height:c}=l;if(o.boxSizing==="content-box"){let f=Hc(o,"border","width"),m=Hc(o,"padding");u-=m.width+f.width,c-=m.height+f.height}return u=Math.max(0,u-s.width),c=Math.max(0,n?Math.floor(u/n):c-s.height),u=ov(Math.min(u,i,l.maxWidth)),c=ov(Math.min(c,a,l.maxHeight)),u&&!c&&(c=ov(u/2)),(t!==void 0||r!==void 0)&&n&&l.height&&c>l.height&&(c=l.height,u=ov(Math.floor(c*n))),{width:u,height:c}}function Ev(e,t,r){let n=t||1,o=Math.floor(e.height*n),s=Math.floor(e.width*n);e.height=o/n,e.width=s/n;let i=e.canvas;return i.style&&(r||!i.style.height&&!i.style.width)&&(i.style.height=`${e.height}px`,i.style.width=`${e.width}px`),e.currentDevicePixelRatio!==n||i.height!==o||i.width!==s?(e.currentDevicePixelRatio=n,i.height=o,i.width=s,e.ctx.setTransform(n,0,0,n,0,0),!0):!1}var sI=function(){let e=!1;try{let t={get passive(){return e=!0,!1}};window.addEventListener("test",null,t),window.removeEventListener("test",null,t)}catch(t){}return e}();function _v(e,t){let r=VO(e,t),n=r&&r.match(/^(\d+)(\.\d+)?px$/);return n?+n[1]:void 0}var AY=function(e,t){return{x(r){return e+e+t-r},setWidth(r){t=r},textAlign(r){return r==="center"?r:r==="right"?"left":"right"},xPlus(r,n){return r-n},leftForLtr(r,n){return r-n}}},DY=function(){return{x(e){return e},setWidth(e){},textAlign(e){return e},xPlus(e,t){return e+t},leftForLtr(e,t){return e}}};function Dg(e,t,r){return e?AY(t,r):DY()}function iI(e,t){let r,n;(t==="ltr"||t==="rtl")&&(r=e.canvas.style,n=[r.getPropertyValue("direction"),r.getPropertyPriority("direction")],r.setProperty("direction",t,"important"),e.prevTextDirection=n)}function aI(e,t){t!==void 0&&(delete e.prevTextDirection,e.canvas.style.setProperty("direction",t[0],t[1]))}var mI=class{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,r,n,o){let s=r.listeners[o],i=r.duration;s.forEach(a=>a({chart:t,initial:r.initial,numSteps:i,currentStep:Math.min(n-r.start,i)}))}_refresh(){this._request||(this._running=!0,this._request=mv.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let r=0;this._charts.forEach((n,o)=>{if(!n.running||!n.items.length)return;let s=n.items,i=s.length-1,a=!1,l;for(;i>=0;--i)l=s[i],l._active?(l._total>n.duration&&(n.duration=l._total),l.tick(t),a=!0):(s[i]=s[s.length-1],s.pop());a&&(o.draw(),this._notify(o,n,t,"progress")),s.length||(n.running=!1,this._notify(o,n,t,"complete"),n.initial=!1),r+=s.length}),this._lastDate=t,r===0&&(this._running=!1)}_getAnims(t){let r=this._charts,n=r.get(t);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},r.set(t,n)),n}listen(t,r,n){this._getAnims(t).listeners[r].push(n)}add(t,r){!r||!r.length||this._getAnims(t).items.push(...r)}has(t){return this._getAnims(t).items.length>0}start(t){let r=this._charts.get(t);!r||(r.running=!0,r.start=Date.now(),r.duration=r.items.reduce((n,o)=>Math.max(n,o._duration),0),this._refresh())}running(t){if(!this._running)return!1;let r=this._charts.get(t);return!(!r||!r.running||!r.items.length)}stop(t){let r=this._charts.get(t);if(!r||!r.items.length)return;let n=r.items,o=n.length-1;for(;o>=0;--o)n[o].cancel();r.items=[],this._notify(t,r,Date.now(),"complete")}remove(t){return this._charts.delete(t)}},Ji=new mI,WO="transparent",jY={boolean(e,t,r){return r>.5?t:e},color(e,t,r){let n=xv(e||WO),o=n.valid&&xv(t||WO);return o&&o.valid?o.mix(n,r).hexString():t},number(e,t,r){return e+(t-e)*r}},dI=class{constructor(t,r,n,o){let s=r[n];o=tm([t.to,o,s,t.from]);let i=tm([t.from,s,o]);this._active=!0,this._fn=t.fn||jY[t.type||typeof i],this._easing=gv[t.easing]||gv.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=r,this._prop=n,this._from=i,this._to=o,this._promises=void 0}active(){return this._active}update(t,r,n){if(this._active){this._notify(!1);let o=this._target[this._prop],s=n-this._start,i=this._duration-s;this._start=n,this._duration=Math.floor(Math.max(i,t.duration)),this._total+=s,this._loop=!!t.loop,this._to=tm([t.to,r,o,t.from]),this._from=tm([t.from,o,r])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){let r=t-this._start,n=this._duration,o=this._prop,s=this._from,i=this._loop,a=this._to,l;if(this._active=s!==a&&(i||r<n),!this._active){this._target[o]=a,this._notify(!0);return}if(r<0){this._target[o]=s;return}l=r/n%2,l=i&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[o]=this._fn(s,a,l)}wait(){let t=this._promises||(this._promises=[]);return new Promise((r,n)=>{t.push({res:r,rej:n})})}_notify(t){let r=t?"res":"rej",n=this._promises||[];for(let o=0;o<n.length;o++)n[o][r]()}},Bv=class{constructor(t,r){this._chart=t,this._properties=new Map,this.configure(r)}configure(t){if(!se(t))return;let r=Object.keys(vr.animation),n=this._properties;Object.getOwnPropertyNames(t).forEach(o=>{let s=t[o];if(!se(s))return;let i={};for(let a of r)i[a]=s[a];(tr(s.properties)&&s.properties||[o]).forEach(a=>{(a===o||!n.has(a))&&n.set(a,i)})})}_animateOptions(t,r){let n=r.options,o=XY(t,n);if(!o)return[];let s=this._createAnimations(o,n);return n.$shared&&KY(t.options.$animations,n).then(()=>{t.options=n},()=>{}),s}_createAnimations(t,r){let n=this._properties,o=[],s=t.$animations||(t.$animations={}),i=Object.keys(r),a=Date.now(),l;for(l=i.length-1;l>=0;--l){let u=i[l];if(u.charAt(0)==="$")continue;if(u==="options"){o.push(...this._animateOptions(t,r));continue}let c=r[u],p=s[u],f=n.get(u);if(p)if(f&&p.active()){p.update(f,c,a);continue}else p.cancel();if(!f||!f.duration){t[u]=c;continue}s[u]=p=new dI(f,t,u,c),o.push(p)}return o}update(t,r){if(this._properties.size===0){Object.assign(t,r);return}let n=this._createAnimations(t,r);if(n.length)return Ji.add(this._chart,n),!0}};function KY(e,t){let r=[],n=Object.keys(t);for(let o=0;o<n.length;o++){let s=e[n[o]];s&&s.active()&&r.push(s.wait())}return Promise.all(r)}function XY(e,t){if(!t)return;let r=e.options;if(!r){e.options=t;return}return r.$shared&&(e.options=r=Object.assign({},r,{$shared:!1,$animations:{}})),r}function GO(e,t){let r=e&&e.options||{},n=r.reverse,o=r.min===void 0?t:0,s=r.max===void 0?t:0;return{start:n?s:o,end:n?o:s}}function YY(e,t,r){if(r===!1)return!1;let n=GO(e,r),o=GO(t,r);return{top:o.end,right:n.end,bottom:o.start,left:n.start}}function QY(e){let t,r,n,o;return se(e)?(t=e.top,r=e.right,n=e.bottom,o=e.left):t=r=n=o=e,{top:t,right:r,bottom:n,left:o,disabled:e===!1}}function TF(e,t){let r=[],n=e._getSortedDatasetMetas(t),o,s;for(o=0,s=n.length;o<s;++o)r.push(n[o].index);return r}function UO(e,t,r,n={}){let o=e.keys,s=n.mode==="single",i,a,l,u;if(t!==null){for(i=0,a=o.length;i<a;++i){if(l=+o[i],l===r){if(n.all)continue;break}u=e.values[l],Nr(u)&&(s||t===0||Yf(t)===Yf(u))&&(t+=u)}return t}}function ZY(e){let t=Object.keys(e),r=new Array(t.length),n,o,s;for(n=0,o=t.length;n<o;++n)s=t[n],r[n]={x:s,y:e[s]};return r}function HO(e,t){let r=e&&e.options.stacked;return r||r===void 0&&t.stack!==void 0}function JY(e,t,r){return`${e.id}.${t.id}.${r.stack||r.type}`}function tQ(e){let{min:t,max:r,minDefined:n,maxDefined:o}=e.getUserBounds();return{min:n?t:Number.NEGATIVE_INFINITY,max:o?r:Number.POSITIVE_INFINITY}}function eQ(e,t,r){let n=e[t]||(e[t]={});return n[r]||(n[r]={})}function qO(e,t,r,n){for(let o of t.getMatchingVisibleMetas(n).reverse()){let s=e[o.index];if(r&&s>0||!r&&s<0)return o.index}return null}function jO(e,t){let{chart:r,_cachedMeta:n}=e,o=r._stacks||(r._stacks={}),{iScale:s,vScale:i,index:a}=n,l=s.axis,u=i.axis,c=JY(s,i,n),p=t.length,f;for(let m=0;m<p;++m){let d=t[m],{[l]:h,[u]:x}=d,g=d._stacks||(d._stacks={});f=g[u]=eQ(o,c,h),f[a]=x,f._top=qO(f,i,!0,n.type),f._bottom=qO(f,i,!1,n.type)}}function lI(e,t){let r=e.scales;return Object.keys(r).filter(n=>r[n].axis===t).shift()}function rQ(e,t){return Qi(e,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}function nQ(e,t,r){return Qi(e,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:r,index:t,mode:"default",type:"data"})}function Rg(e,t){let r=e.controller.index,n=e.vScale&&e.vScale.axis;if(!!n){t=t||e._parsed;for(let o of t){let s=o._stacks;if(!s||s[n]===void 0||s[n][r]===void 0)return;delete s[n][r]}}}var uI=e=>e==="reset"||e==="none",KO=(e,t)=>t?e:Object.assign({},e),oQ=(e,t,r)=>e&&!t.hidden&&t._stacked&&{keys:TF(r,!0),values:null},Ql=class{constructor(t,r){this.chart=t,this._ctx=t.ctx,this.index=r,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){let t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=HO(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(t){this.index!==t&&Rg(this._cachedMeta),this.index=t}linkScales(){let t=this.chart,r=this._cachedMeta,n=this.getDataset(),o=(p,f,m,d)=>p==="x"?f:p==="r"?d:m,s=r.xAxisID=Je(n.xAxisID,lI(t,"x")),i=r.yAxisID=Je(n.yAxisID,lI(t,"y")),a=r.rAxisID=Je(n.rAxisID,lI(t,"r")),l=r.indexAxis,u=r.iAxisID=o(l,s,i,a),c=r.vAxisID=o(l,i,s,a);r.xScale=this.getScaleForId(s),r.yScale=this.getScaleForId(i),r.rScale=this.getScaleForId(a),r.iScale=this.getScaleForId(u),r.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){let r=this._cachedMeta;return t===r.iScale?r.vScale:r.iScale}reset(){this._update("reset")}_destroy(){let t=this._cachedMeta;this._data&&fv(this._data,this),t._stacked&&Rg(t)}_dataCheck(){let t=this.getDataset(),r=t.data||(t.data=[]),n=this._data;if(se(r))this._data=ZY(r);else if(n!==r){if(n){fv(n,this);let o=this._cachedMeta;Rg(o),o._parsed=[]}r&&Object.isExtensible(r)&&UN(r,this),this._syncList=[],this._data=r}}addElements(){let t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){let r=this._cachedMeta,n=this.getDataset(),o=!1;this._dataCheck();let s=r._stacked;r._stacked=HO(r.vScale,r),r.stack!==n.stack&&(o=!0,Rg(r),r.stack=n.stack),this._resyncElements(t),(o||s!==r._stacked)&&jO(this,r._parsed)}configure(){let t=this.chart.config,r=t.datasetScopeKeys(this._type),n=t.getOptionScopes(this.getDataset(),r,!0);this.options=t.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,r){let{_cachedMeta:n,_data:o}=this,{iScale:s,_stacked:i}=n,a=s.axis,l=t===0&&r===o.length?!0:n._sorted,u=t>0&&n._parsed[t-1],c,p,f;if(this._parsing===!1)n._parsed=o,n._sorted=!0,f=o;else{tr(o[t])?f=this.parseArrayData(n,o,t,r):se(o[t])?f=this.parseObjectData(n,o,t,r):f=this.parsePrimitiveData(n,o,t,r);let m=()=>p[a]===null||u&&p[a]<u[a];for(c=0;c<r;++c)n._parsed[c+t]=p=f[c],l&&(m()&&(l=!1),u=p);n._sorted=l}i&&jO(this,f)}parsePrimitiveData(t,r,n,o){let{iScale:s,vScale:i}=t,a=s.axis,l=i.axis,u=s.getLabels(),c=s===i,p=new Array(o),f,m,d;for(f=0,m=o;f<m;++f)d=f+n,p[f]={[a]:c||s.parse(u[d],d),[l]:i.parse(r[d],d)};return p}parseArrayData(t,r,n,o){let{xScale:s,yScale:i}=t,a=new Array(o),l,u,c,p;for(l=0,u=o;l<u;++l)c=l+n,p=r[c],a[l]={x:s.parse(p[0],c),y:i.parse(p[1],c)};return a}parseObjectData(t,r,n,o){let{xScale:s,yScale:i}=t,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,u=new Array(o),c,p,f,m;for(c=0,p=o;c<p;++c)f=c+n,m=r[f],u[c]={x:s.parse(Xf(m,a),f),y:i.parse(Xf(m,l),f)};return u}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,r,n){let o=this.chart,s=this._cachedMeta,i=r[t.axis],a={keys:TF(o,!0),values:r._stacks[t.axis]};return UO(a,i,s.index,{mode:n})}updateRangeFromParsed(t,r,n,o){let s=n[r.axis],i=s===null?NaN:s,a=o&&n._stacks[r.axis];o&&a&&(o.values=a,i=UO(o,s,this._cachedMeta.index)),t.min=Math.min(t.min,i),t.max=Math.max(t.max,i)}getMinMax(t,r){let n=this._cachedMeta,o=n._parsed,s=n._sorted&&t===n.iScale,i=o.length,a=this._getOtherScale(t),l=oQ(r,n,this.chart),u={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:p}=tQ(a),f,m;function d(){m=o[f];let h=m[a.axis];return!Nr(m[t.axis])||c>h||p<h}for(f=0;f<i&&!(!d()&&(this.updateRangeFromParsed(u,t,m,l),s));++f);if(s){for(f=i-1;f>=0;--f)if(!d()){this.updateRangeFromParsed(u,t,m,l);break}}return u}getAllParsedValues(t){let r=this._cachedMeta._parsed,n=[],o,s,i;for(o=0,s=r.length;o<s;++o)i=r[o][t.axis],Nr(i)&&n.push(i);return n}getMaxOverflow(){return!1}getLabelAndValue(t){let r=this._cachedMeta,n=r.iScale,o=r.vScale,s=this.getParsed(t);return{label:n?""+n.getLabelForValue(s[n.axis]):"",value:o?""+o.getLabelForValue(s[o.axis]):""}}_update(t){let r=this._cachedMeta;this.update(t||"default"),r._clip=QY(Je(this.options.clip,YY(r.xScale,r.yScale,this.getMaxOverflow())))}update(t){}draw(){let t=this._ctx,r=this.chart,n=this._cachedMeta,o=n.data||[],s=r.chartArea,i=[],a=this._drawStart||0,l=this._drawCount||o.length-a,u=this.options.drawActiveElementsOnTop,c;for(n.dataset&&n.dataset.draw(t,s,a,l),c=a;c<a+l;++c){let p=o[c];p.hidden||(p.active&&u?i.push(p):p.draw(t,s))}for(c=0;c<i.length;++c)i[c].draw(t,s)}getStyle(t,r){let n=r?"active":"default";return t===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(t||0,n)}getContext(t,r,n){let o=this.getDataset(),s;if(t>=0&&t<this._cachedMeta.data.length){let i=this._cachedMeta.data[t];s=i.$context||(i.$context=nQ(this.getContext(),t,i)),s.parsed=this.getParsed(t),s.raw=o.data[t],s.index=s.dataIndex=t}else s=this.$context||(this.$context=rQ(this.chart.getContext(),this.index)),s.dataset=o,s.index=s.datasetIndex=this.index;return s.active=!!r,s.mode=n,s}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,r){return this._resolveElementOptions(this.dataElementType.id,r,t)}_resolveElementOptions(t,r="default",n){let o=r==="active",s=this._cachedDataOpts,i=t+"-"+r,a=s[i],l=this.enableOptionSharing&&No(n);if(a)return KO(a,l);let u=this.chart.config,c=u.datasetElementScopeKeys(this._type,t),p=o?[`${t}Hover`,"hover",t,""]:[t,""],f=u.getOptionScopes(this.getDataset(),c),m=Object.keys(vr.elements[t]),d=()=>this.getContext(n,o),h=u.resolveNamedOptions(f,m,d,p);return h.$shared&&(h.$shared=l,s[i]=Object.freeze(KO(h,l))),h}_resolveAnimations(t,r,n){let o=this.chart,s=this._cachedDataOpts,i=`animation-${r}`,a=s[i];if(a)return a;let l;if(o.options.animation!==!1){let c=this.chart.config,p=c.datasetAnimationScopeKeys(this._type,r),f=c.getOptionScopes(this.getDataset(),p);l=c.createResolver(f,this.getContext(t,n,r))}let u=new Bv(o,l&&l.animations);return l&&l._cacheable&&(s[i]=Object.freeze(u)),u}getSharedOptions(t){if(!!t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,r){return!r||uI(t)||this.chart._animationsDisabled}_getSharedOptions(t,r){let n=this.resolveDataElementOptions(t,r),o=this._sharedOptions,s=this.getSharedOptions(n),i=this.includeOptions(r,s)||s!==o;return this.updateSharedOptions(s,r,n),{sharedOptions:s,includeOptions:i}}updateElement(t,r,n,o){uI(o)?Object.assign(t,n):this._resolveAnimations(r,o).update(t,n)}updateSharedOptions(t,r,n){t&&!uI(r)&&this._resolveAnimations(void 0,r).update(t,n)}_setStyle(t,r,n,o){t.active=o;let s=this.getStyle(r,o);this._resolveAnimations(r,n,o).update(t,{options:!o&&this.getSharedOptions(s)||s})}removeHoverStyle(t,r,n){this._setStyle(t,n,"active",!1)}setHoverStyle(t,r,n){this._setStyle(t,n,"active",!0)}_removeDatasetHoverStyle(){let t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){let t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){let r=this._data,n=this._cachedMeta.data;for(let[a,l,u]of this._syncList)this[a](l,u);this._syncList=[];let o=n.length,s=r.length,i=Math.min(s,o);i&&this.parse(0,i),s>o?this._insertElements(o,s-o,t):s<o&&this._removeElements(s,o-s)}_insertElements(t,r,n=!0){let o=this._cachedMeta,s=o.data,i=t+r,a,l=u=>{for(u.length+=r,a=u.length-1;a>=i;a--)u[a]=u[a-r]};for(l(s),a=t;a<i;++a)s[a]=new this.dataElementType;this._parsing&&l(o._parsed),this.parse(t,r),n&&this.updateElements(s,t,r,"reset")}updateElements(t,r,n,o){}_removeElements(t,r){let n=this._cachedMeta;if(this._parsing){let o=n._parsed.splice(t,r);n._stacked&&Rg(n,o)}n.data.splice(t,r)}_sync(t){if(this._parsing)this._syncList.push(t);else{let[r,n,o]=t;this[r](n,o)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){let t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,r){r&&this._sync(["_removeElements",t,r]);let n=arguments.length-2;n&&this._sync(["_insertElements",t,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}};Ne(Ql,"defaults",{}),Ne(Ql,"datasetElementType",null),Ne(Ql,"dataElementType",null);function Kc(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}var Bg=class{static override(t){Object.assign(Bg.prototype,t)}constructor(t){this.options=t||{}}init(){}formats(){return Kc()}parse(){return Kc()}format(){return Kc()}add(){return Kc()}diff(){return Kc()}startOf(){return Kc()}endOf(){return Kc()}},sQ={_date:Bg};function iQ(e,t,r,n){let{controller:o,data:s,_sorted:i}=e,a=o._cachedMeta.iScale;if(a&&t===a.axis&&t!=="r"&&i&&s.length){let l=a._reversePixels?WN:Tg;if(n){if(o._sharedOptions){let u=s[0],c=typeof u.getRange=="function"&&u.getRange(t);if(c){let p=l(s,t,r-c),f=l(s,t,r+c);return{lo:p.lo,hi:f.hi}}}}else return l(s,t,r)}return{lo:0,hi:s.length-1}}function Gg(e,t,r,n,o){let s=e.getSortedVisibleDatasetMetas(),i=r[t];for(let a=0,l=s.length;a<l;++a){let{index:u,data:c}=s[a],{lo:p,hi:f}=iQ(s[a],t,i,o);for(let m=p;m<=f;++m){let d=c[m];d.skip||n(d,u,m)}}}function aQ(e){let t=e.indexOf("x")!==-1,r=e.indexOf("y")!==-1;return function(n,o){let s=t?Math.abs(n.x-o.x):0,i=r?Math.abs(n.y-o.y):0;return Math.sqrt(Math.pow(s,2)+Math.pow(i,2))}}function cI(e,t,r,n,o){let s=[];return!o&&!e.isPointInArea(t)||Gg(e,r,t,function(a,l,u){!o&&!wv(a,e.chartArea,0)||a.inRange(t.x,t.y,n)&&s.push({element:a,datasetIndex:l,index:u})},!0),s}function lQ(e,t,r,n){let o=[];function s(i,a,l){let{startAngle:u,endAngle:c}=i.getProps(["startAngle","endAngle"],n),{angle:p}=MN(i,{x:t.x,y:t.y});BN(p,u,c)&&o.push({element:i,datasetIndex:a,index:l})}return Gg(e,r,t,s),o}function uQ(e,t,r,n,o,s){let i=[],a=aQ(r),l=Number.POSITIVE_INFINITY;function u(c,p,f){let m=c.inRange(t.x,t.y,o);if(n&&!m)return;let d=c.getCenterPoint(o);if(!(!!s||e.isPointInArea(d))&&!m)return;let x=a(t,d);x<l?(i=[{element:c,datasetIndex:p,index:f}],l=x):x===l&&i.push({element:c,datasetIndex:p,index:f})}return Gg(e,r,t,u),i}function pI(e,t,r,n,o,s){return!s&&!e.isPointInArea(t)?[]:r==="r"&&!n?lQ(e,t,r,o):uQ(e,t,r,n,o,s)}function XO(e,t,r,n,o){let s=[],i=r==="x"?"inXRange":"inYRange",a=!1;return Gg(e,r,t,(l,u,c)=>{l[i](t[r],o)&&(s.push({element:l,datasetIndex:u,index:c}),a=a||l.inRange(t.x,t.y,o))}),n&&!a?[]:s}var cQ={evaluateInteractionItems:Gg,modes:{index(e,t,r,n){let o=Zi(t,e),s=r.axis||"x",i=r.includeInvisible||!1,a=r.intersect?cI(e,o,s,n,i):pI(e,o,s,!1,n,i),l=[];return a.length?(e.getSortedVisibleDatasetMetas().forEach(u=>{let c=a[0].index,p=u.data[c];p&&!p.skip&&l.push({element:p,datasetIndex:u.index,index:c})}),l):[]},dataset(e,t,r,n){let o=Zi(t,e),s=r.axis||"xy",i=r.includeInvisible||!1,a=r.intersect?cI(e,o,s,n,i):pI(e,o,s,!1,n,i);if(a.length>0){let l=a[0].datasetIndex,u=e.getDatasetMeta(l).data;a=[];for(let c=0;c<u.length;++c)a.push({element:u[c],datasetIndex:l,index:c})}return a},point(e,t,r,n){let o=Zi(t,e),s=r.axis||"xy",i=r.includeInvisible||!1;return cI(e,o,s,n,i)},nearest(e,t,r,n){let o=Zi(t,e),s=r.axis||"xy",i=r.includeInvisible||!1;return pI(e,o,s,r.intersect,n,i)},x(e,t,r,n){let o=Zi(t,e);return XO(e,o,"x",r.intersect,n)},y(e,t,r,n){let o=Zi(t,e);return XO(e,o,"y",r.intersect,n)}}},NF=["left","top","right","bottom"];function $g(e,t){return e.filter(r=>r.pos===t)}function YO(e,t){return e.filter(r=>NF.indexOf(r.pos)===-1&&r.box.axis===t)}function Og(e,t){return e.sort((r,n)=>{let o=t?n:r,s=t?r:n;return o.weight===s.weight?o.index-s.index:o.weight-s.weight})}function pQ(e){let t=[],r,n,o,s,i,a;for(r=0,n=(e||[]).length;r<n;++r)o=e[r],{position:s,options:{stack:i,stackWeight:a=1}}=o,t.push({index:r,box:o,pos:s,horizontal:o.isHorizontal(),weight:o.weight,stack:i&&s+i,stackWeight:a});return t}function fQ(e){let t={};for(let r of e){let{stack:n,pos:o,stackWeight:s}=r;if(!n||!NF.includes(o))continue;let i=t[n]||(t[n]={count:0,placed:0,weight:0,size:0});i.count++,i.weight+=s}return t}function mQ(e,t){let r=fQ(e),{vBoxMaxWidth:n,hBoxMaxHeight:o}=t,s,i,a;for(s=0,i=e.length;s<i;++s){a=e[s];let{fullSize:l}=a.box,u=r[a.stack],c=u&&a.stackWeight/u.weight;a.horizontal?(a.width=c?c*n:l&&t.availableWidth,a.height=o):(a.width=n,a.height=c?c*o:l&&t.availableHeight)}return r}function dQ(e){let t=pQ(e),r=Og(t.filter(u=>u.box.fullSize),!0),n=Og($g(t,"left"),!0),o=Og($g(t,"right")),s=Og($g(t,"top"),!0),i=Og($g(t,"bottom")),a=YO(t,"x"),l=YO(t,"y");return{fullSize:r,leftAndTop:n.concat(s),rightAndBottom:o.concat(l).concat(i).concat(a),chartArea:$g(t,"chartArea"),vertical:n.concat(o).concat(l),horizontal:s.concat(i).concat(a)}}function QO(e,t,r,n){return Math.max(e[r],t[r])+Math.max(e[n],t[n])}function IF(e,t){e.top=Math.max(e.top,t.top),e.left=Math.max(e.left,t.left),e.bottom=Math.max(e.bottom,t.bottom),e.right=Math.max(e.right,t.right)}function hQ(e,t,r,n){let{pos:o,box:s}=r,i=e.maxPadding;if(!se(o)){r.size&&(e[o]-=r.size);let p=n[r.stack]||{size:0,count:1};p.size=Math.max(p.size,r.horizontal?s.height:s.width),r.size=p.size/p.count,e[o]+=r.size}s.getPadding&&IF(i,s.getPadding());let a=Math.max(0,t.outerWidth-QO(i,e,"left","right")),l=Math.max(0,t.outerHeight-QO(i,e,"top","bottom")),u=a!==e.w,c=l!==e.h;return e.w=a,e.h=l,r.horizontal?{same:u,other:c}:{same:c,other:u}}function gQ(e){let t=e.maxPadding;function r(n){let o=Math.max(t[n]-e[n],0);return e[n]+=o,o}e.y+=r("top"),e.x+=r("left"),r("right"),r("bottom")}function xQ(e,t){let r=t.maxPadding;function n(o){let s={left:0,top:0,right:0,bottom:0};return o.forEach(i=>{s[i]=Math.max(t[i],r[i])}),s}return n(e?["left","right"]:["top","bottom"])}function Lg(e,t,r,n){let o=[],s,i,a,l,u,c;for(s=0,i=e.length,u=0;s<i;++s){a=e[s],l=a.box,l.update(a.width||t.w,a.height||t.h,xQ(a.horizontal,t));let{same:p,other:f}=hQ(t,r,a,n);u|=p&&o.length,c=c||f,l.fullSize||o.push(a)}return u&&Lg(o,t,r,n)||c}function Av(e,t,r,n,o){e.top=r,e.left=t,e.right=t+n,e.bottom=r+o,e.width=n,e.height=o}function ZO(e,t,r,n){let o=r.padding,{x:s,y:i}=t;for(let a of e){let l=a.box,u=n[a.stack]||{count:1,placed:0,weight:1},c=a.stackWeight/u.weight||1;if(a.horizontal){let p=t.w*c,f=u.size||l.height;No(u.start)&&(i=u.start),l.fullSize?Av(l,o.left,i,r.outerWidth-o.right-o.left,f):Av(l,t.left+u.placed,i,p,f),u.start=i,u.placed+=p,i=l.bottom}else{let p=t.h*c,f=u.size||l.width;No(u.start)&&(s=u.start),l.fullSize?Av(l,s,o.top,f,r.outerHeight-o.bottom-o.top):Av(l,s,t.top+u.placed,f,p),u.start=s,u.placed+=p,s=l.right}}t.x=s,t.y=i}var Dv={addBox(e,t){e.boxes||(e.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(r){t.draw(r)}}]},e.boxes.push(t)},removeBox(e,t){let r=e.boxes?e.boxes.indexOf(t):-1;r!==-1&&e.boxes.splice(r,1)},configure(e,t,r){t.fullSize=r.fullSize,t.position=r.position,t.weight=r.weight},update(e,t,r,n){if(!e)return;let o=to(e.options.layout.padding),s=Math.max(t-o.width,0),i=Math.max(r-o.height,0),a=dQ(e.boxes),l=a.vertical,u=a.horizontal;ge(e.boxes,h=>{typeof h.beforeLayout=="function"&&h.beforeLayout()});let c=l.reduce((h,x)=>x.box.options&&x.box.options.display===!1?h:h+1,0)||1,p=Object.freeze({outerWidth:t,outerHeight:r,padding:o,availableWidth:s,availableHeight:i,vBoxMaxWidth:s/2/c,hBoxMaxHeight:i/2}),f=Object.assign({},o);IF(f,to(n));let m=Object.assign({maxPadding:f,w:s,h:i,x:o.left,y:o.top},o),d=mQ(l.concat(u),p);Lg(a.fullSize,m,p,d),Lg(l,m,p,d),Lg(u,m,p,d)&&Lg(l,m,p,d),gQ(m),ZO(a.leftAndTop,m,p,d),m.x+=m.w,m.y+=m.h,ZO(a.rightAndBottom,m,p,d),e.chartArea={left:m.left,top:m.top,right:m.left+m.w,bottom:m.top+m.h,height:m.h,width:m.w},ge(a.chartArea,h=>{let x=h.box;Object.assign(x,e.chartArea),x.update(m.w,m.h,{left:0,top:0,right:0,bottom:0})})}},Vv=class{acquireContext(t,r){}releaseContext(t){return!1}addEventListener(t,r,n){}removeEventListener(t,r,n){}getDevicePixelRatio(){return 1}getMaximumSize(t,r,n,o){return r=Math.max(0,r||t.width),n=n||t.height,{width:r,height:Math.max(0,o?Math.floor(r/o):n)}}isAttached(t){return!0}updateConfig(t){}},hI=class extends Vv{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}},Mv="$chartjs",yQ={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},JO=e=>e===null||e==="";function bQ(e,t){let r=e.style,n=e.getAttribute("height"),o=e.getAttribute("width");if(e[Mv]={initial:{height:n,width:o,style:{display:r.display,height:r.height,width:r.width}}},r.display=r.display||"block",r.boxSizing=r.boxSizing||"border-box",JO(o)){let s=_v(e,"width");s!==void 0&&(e.width=s)}if(JO(n))if(e.style.height==="")e.height=e.width/(t||2);else{let s=_v(e,"height");s!==void 0&&(e.height=s)}return e}var EF=sI?{passive:!0}:!1;function vQ(e,t,r){e.addEventListener(t,r,EF)}function wQ(e,t,r){e.canvas.removeEventListener(t,r,EF)}function CQ(e,t){let r=yQ[e.type]||e.type,{x:n,y:o}=Zi(e,t);return{type:r,chart:t,native:e,x:n!==void 0?n:null,y:o!==void 0?o:null}}function Wv(e,t){for(let r of e)if(r===t||r.contains(t))return!0}function SQ(e,t,r){let n=e.canvas,o=new MutationObserver(s=>{let i=!1;for(let a of s)i=i||Wv(a.addedNodes,n),i=i&&!Wv(a.removedNodes,n);i&&r()});return o.observe(document,{childList:!0,subtree:!0}),o}function kQ(e,t,r){let n=e.canvas,o=new MutationObserver(s=>{let i=!1;for(let a of s)i=i||Wv(a.removedNodes,n),i=i&&!Wv(a.addedNodes,n);i&&r()});return o.observe(document,{childList:!0,subtree:!0}),o}var Vg=new Map,tF=0;function _F(){let e=window.devicePixelRatio;e!==tF&&(tF=e,Vg.forEach((t,r)=>{r.currentDevicePixelRatio!==e&&t()}))}function TQ(e,t){Vg.size||window.addEventListener("resize",_F),Vg.set(e,t)}function NQ(e){Vg.delete(e),Vg.size||window.removeEventListener("resize",_F)}function IQ(e,t,r){let n=e.canvas,o=n&&Ag(n);if(!o)return;let s=dv((a,l)=>{let u=o.clientWidth;r(a,l),u<o.clientWidth&&r()},window),i=new ResizeObserver(a=>{let l=a[0],u=l.contentRect.width,c=l.contentRect.height;u===0&&c===0||s(u,c)});return i.observe(o),TQ(e,s),i}function fI(e,t,r){r&&r.disconnect(),t==="resize"&&NQ(e)}function EQ(e,t,r){let n=e.canvas,o=dv(s=>{e.ctx!==null&&r(CQ(s,e))},e);return vQ(n,t,o),o}var gI=class extends Vv{acquireContext(t,r){let n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(bQ(t,r),n):null}releaseContext(t){let r=t.canvas;if(!r[Mv])return!1;let n=r[Mv].initial;["height","width"].forEach(s=>{let i=n[s];ze(i)?r.removeAttribute(s):r.setAttribute(s,i)});let o=n.style||{};return Object.keys(o).forEach(s=>{r.style[s]=o[s]}),r.width=r.width,delete r[Mv],!0}addEventListener(t,r,n){this.removeEventListener(t,r);let o=t.$proxies||(t.$proxies={}),i={attach:SQ,detach:kQ,resize:IQ}[r]||EQ;o[r]=i(t,r,n)}removeEventListener(t,r){let n=t.$proxies||(t.$proxies={}),o=n[r];if(!o)return;({attach:fI,detach:fI,resize:fI}[r]||wQ)(t,r,o),n[r]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,r,n,o){return oI(t,r,n,o)}isAttached(t){let r=Ag(t);return!!(r&&r.isConnected)}};function _Q(e){return!Nv()||typeof OffscreenCanvas!="undefined"&&e instanceof OffscreenCanvas?hI:gI}var ea=class{constructor(){Ne(this,"active",!1)}tooltipPosition(t){let{x:r,y:n}=this.getProps(["x","y"],t);return{x:r,y:n}}hasValue(){return Zf(this.x)&&Zf(this.y)}getProps(t,r){let n=this.$animations;if(!r||!n)return this;let o={};return t.forEach(s=>{o[s]=n[s]&&n[s].active()?n[s]._to:this[s]}),o}};Ne(ea,"defaults",{}),Ne(ea,"defaultRoutes");function AQ(e,t){let r=e.options.ticks,n=DQ(e),o=Math.min(r.maxTicksLimit||n,n),s=r.major.enabled?$Q(t):[],i=s.length,a=s[0],l=s[i-1],u=[];if(i>o)return OQ(t,u,s,i/o),u;let c=RQ(s,t,o);if(i>0){let p,f,m=i>1?Math.round((l-a)/(i-1)):null;for(Rv(t,u,c,ze(m)?0:a-m,a),p=0,f=i-1;p<f;p++)Rv(t,u,c,s[p],s[p+1]);return Rv(t,u,c,l,ze(m)?t.length:l+m),u}return Rv(t,u,c),u}function DQ(e){let t=e.options.offset,r=e._tickSize(),n=e._length/r+(t?0:1),o=e._maxLength/r;return Math.floor(Math.min(n,o))}function RQ(e,t,r){let n=FQ(e),o=t.length/r;if(!n)return Math.max(o,1);let s=PN(n);for(let i=0,a=s.length-1;i<a;i++){let l=s[i];if(l>o)return l}return Math.max(o,1)}function $Q(e){let t=[],r,n;for(r=0,n=e.length;r<n;r++)e[r].major&&t.push(r);return t}function OQ(e,t,r,n){let o=0,s=r[0],i;for(n=Math.ceil(n),i=0;i<e.length;i++)i===s&&(t.push(e[i]),o++,s=r[o*n])}function Rv(e,t,r,n,o){let s=Je(n,0),i=Math.min(Je(o,e.length),e.length),a=0,l,u,c;for(r=Math.ceil(r),o&&(l=o-n,r=l/Math.floor(l/r)),c=s;c<0;)a++,c=Math.round(s+a*r);for(u=Math.max(s,0);u<i;u++)u===c&&(t.push(e[u]),a++,c=Math.round(s+a*r))}function FQ(e){let t=e.length,r,n;if(t<2)return!1;for(n=e[0],r=1;r<t;++r)if(e[r]-e[r-1]!==n)return!1;return n}var PQ=e=>e==="left"?"right":e==="right"?"left":e,eF=(e,t,r)=>t==="top"||t==="left"?e[t]+r:e[t]-r;function rF(e,t){let r=[],n=e.length/t,o=e.length,s=0;for(;s<o;s+=n)r.push(e[Math.floor(s)]);return r}function LQ(e,t,r){let n=e.ticks.length,o=Math.min(t,n-1),s=e._startPixel,i=e._endPixel,a=1e-6,l=e.getPixelForTick(o),u;if(!(r&&(n===1?u=Math.max(l-s,i-l):t===0?u=(e.getPixelForTick(1)-l)/2:u=(l-e.getPixelForTick(o-1))/2,l+=o<t?u:-u,l<s-a||l>i+a)))return l}function MQ(e,t){ge(e,r=>{let n=r.gc,o=n.length/2,s;if(o>t){for(s=0;s<o;++s)delete r.data[n[s]];n.splice(0,o)}})}function Fg(e){return e.drawTicks?e.tickLength:0}function nF(e,t){if(!e.display)return 0;let r=Bn(e.font,t),n=to(e.padding);return(tr(e.text)?e.text.length:1)*r.lineHeight+n.height}function zQ(e,t){return Qi(e,{scale:t,type:"scale"})}function BQ(e,t,r){return Qi(e,{tick:r,index:t,type:"tick"})}function VQ(e,t,r){let n=jN(e);return(r&&t!=="right"||!r&&t==="right")&&(n=PQ(n)),n}function WQ(e,t,r,n){let{top:o,left:s,bottom:i,right:a,chart:l}=e,{chartArea:u,scales:c}=l,p=0,f,m,d,h=i-o,x=a-s;if(e.isHorizontal()){if(m=hv(n,s,a),se(r)){let g=Object.keys(r)[0],y=r[g];d=c[g].getPixelForValue(y)+h-t}else r==="center"?d=(u.bottom+u.top)/2+h-t:d=eF(e,r,t);f=a-s}else{if(se(r)){let g=Object.keys(r)[0],y=r[g];m=c[g].getPixelForValue(y)-x+t}else r==="center"?m=(u.left+u.right)/2-x+t:m=eF(e,r,t);d=hv(n,i,o),p=r==="left"?-Cn:Cn}return{titleX:m,titleY:d,maxWidth:f,rotation:p}}var ra=class extends ea{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,r){return t}getUserBounds(){let{_userMin:t,_userMax:r,_suggestedMin:n,_suggestedMax:o}=this;return t=zn(t,Number.POSITIVE_INFINITY),r=zn(r,Number.NEGATIVE_INFINITY),n=zn(n,Number.POSITIVE_INFINITY),o=zn(o,Number.NEGATIVE_INFINITY),{min:zn(t,n),max:zn(r,o),minDefined:Nr(t),maxDefined:Nr(r)}}getMinMax(t){let{min:r,max:n,minDefined:o,maxDefined:s}=this.getUserBounds(),i;if(o&&s)return{min:r,max:n};let a=this.getMatchingVisibleMetas();for(let l=0,u=a.length;l<u;++l)i=a[l].controller.getMinMax(this,t),o||(r=Math.min(r,i.min)),s||(n=Math.max(n,i.max));return r=s&&r>n?n:r,n=o&&r>n?r:n,{min:zn(r,zn(n,r)),max:zn(n,zn(r,n))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){let t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){er(this.options.beforeUpdate,[this])}update(t,r,n){let{beginAtZero:o,grace:s,ticks:i}=this.options,a=i.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=r,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=eI(this,s,o),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();let l=a<this.ticks.length;this._convertTicksToLabels(l?rF(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),i.display&&(i.autoSkip||i.source==="auto")&&(this.ticks=AQ(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t=this.options.reverse,r,n;this.isHorizontal()?(r=this.left,n=this.right):(r=this.top,n=this.bottom,t=!t),this._startPixel=r,this._endPixel=n,this._reversePixels=t,this._length=n-r,this._alignToPixels=this.options.alignToPixels}afterUpdate(){er(this.options.afterUpdate,[this])}beforeSetDimensions(){er(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){er(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),er(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){er(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){let r=this.options.ticks,n,o,s;for(n=0,o=t.length;n<o;n++)s=t[n],s.label=er(r.callback,[s.value,n,t],this)}afterTickToLabelConversion(){er(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){er(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){let t=this.options,r=t.ticks,n=this.ticks.length,o=r.minRotation||0,s=r.maxRotation,i=o,a,l,u;if(!this._isVisible()||!r.display||o>=s||n<=1||!this.isHorizontal()){this.labelRotation=o;return}let c=this._getLabelSizes(),p=c.widest.width,f=c.highest.height,m=Ko(this.chart.width-p,0,this.maxWidth);a=t.offset?this.maxWidth/n:m/(n-1),p+6>a&&(a=m/(n-(t.offset?.5:1)),l=this.maxHeight-Fg(t.grid)-r.padding-nF(t.title,this.chart.options.font),u=Math.sqrt(p*p+f*f),i=Sg(Math.min(Math.asin(Ko((c.highest.height+6)/a,-1,1)),Math.asin(Ko(l/u,-1,1))-Math.asin(Ko(f/u,-1,1)))),i=Math.max(o,Math.min(s,i))),this.labelRotation=i}afterCalculateLabelRotation(){er(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){er(this.options.beforeFit,[this])}fit(){let t={width:0,height:0},{chart:r,options:{ticks:n,title:o,grid:s}}=this,i=this._isVisible(),a=this.isHorizontal();if(i){let l=nF(o,r.options.font);if(a?(t.width=this.maxWidth,t.height=Fg(s)+l):(t.height=this.maxHeight,t.width=Fg(s)+l),n.display&&this.ticks.length){let{first:u,last:c,widest:p,highest:f}=this._getLabelSizes(),m=n.padding*2,d=pi(this.labelRotation),h=Math.cos(d),x=Math.sin(d);if(a){let g=n.mirror?0:x*p.width+h*f.height;t.height=Math.min(this.maxHeight,t.height+g+m)}else{let g=n.mirror?0:h*p.width+x*f.height;t.width=Math.min(this.maxWidth,t.width+g+m)}this._calculatePadding(u,c,x,h)}}this._handleMargins(),a?(this.width=this._length=r.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=r.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,r,n,o){let{ticks:{align:s,padding:i},position:a}=this.options,l=this.labelRotation!==0,u=a!=="top"&&this.axis==="x";if(this.isHorizontal()){let c=this.getPixelForTick(0)-this.left,p=this.right-this.getPixelForTick(this.ticks.length-1),f=0,m=0;l?u?(f=o*t.width,m=n*r.height):(f=n*t.height,m=o*r.width):s==="start"?m=r.width:s==="end"?f=t.width:s!=="inner"&&(f=t.width/2,m=r.width/2),this.paddingLeft=Math.max((f-c+i)*this.width/(this.width-c),0),this.paddingRight=Math.max((m-p+i)*this.width/(this.width-p),0)}else{let c=r.height/2,p=t.height/2;s==="start"?(c=0,p=t.height):s==="end"&&(c=r.height,p=0),this.paddingTop=c+i,this.paddingBottom=p+i}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){er(this.options.afterFit,[this])}isHorizontal(){let{axis:t,position:r}=this.options;return r==="top"||r==="bottom"||t==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion(),this.generateTickLabels(t);let r,n;for(r=0,n=t.length;r<n;r++)ze(t[r].label)&&(t.splice(r,1),n--,r--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){let r=this.options.ticks.sampleSize,n=this.ticks;r<n.length&&(n=rF(n,r)),this._labelSizes=t=this._computeLabelSizes(n,n.length)}return t}_computeLabelSizes(t,r){let{ctx:n,_longestTextCache:o}=this,s=[],i=[],a=0,l=0,u,c,p,f,m,d,h,x,g,y,b;for(u=0;u<r;++u){if(f=t[u].label,m=this._resolveTickFontOptions(u),n.font=d=m.string,h=o[d]=o[d]||{data:{},gc:[]},x=m.lineHeight,g=y=0,!ze(f)&&!tr(f))g=jf(n,h.data,h.gc,g,f),y=x;else if(tr(f))for(c=0,p=f.length;c<p;++c)b=f[c],!ze(b)&&!tr(b)&&(g=jf(n,h.data,h.gc,g,b),y+=x);s.push(g),i.push(y),a=Math.max(g,a),l=Math.max(y,l)}MQ(o,r);let v=s.indexOf(a),C=i.indexOf(l),S=k=>({width:s[k]||0,height:i[k]||0});return{first:S(0),last:S(r-1),widest:S(v),highest:S(C),widths:s,heights:i}}getLabelForValue(t){return t}getPixelForValue(t,r){return NaN}getValueForPixel(t){}getPixelForTick(t){let r=this.ticks;return t<0||t>r.length-1?null:this.getPixelForValue(r[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);let r=this._startPixel+t*this._length;return VN(this._alignToPixels?Ki(this.chart,r,0):r)}getDecimalForPixel(t){let r=(t-this._startPixel)/this._length;return this._reversePixels?1-r:r}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){let{min:t,max:r}=this;return t<0&&r<0?r:t>0&&r>0?t:0}getContext(t){let r=this.ticks||[];if(t>=0&&t<r.length){let n=r[t];return n.$context||(n.$context=BQ(this.getContext(),t,n))}return this.$context||(this.$context=zQ(this.chart.getContext(),this))}_tickSize(){let t=this.options.ticks,r=pi(this.labelRotation),n=Math.abs(Math.cos(r)),o=Math.abs(Math.sin(r)),s=this._getLabelSizes(),i=t.autoSkipPadding||0,a=s?s.widest.width+i:0,l=s?s.highest.height+i:0;return this.isHorizontal()?l*n>a*o?a/n:l/o:l*o<a*n?l/n:a/o}_isVisible(){let t=this.options.display;return t!=="auto"?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){let r=this.axis,n=this.chart,o=this.options,{grid:s,position:i,border:a}=o,l=s.offset,u=this.isHorizontal(),p=this.ticks.length+(l?1:0),f=Fg(s),m=[],d=a.setContext(this.getContext()),h=d.display?d.width:0,x=h/2,g=function(q){return Ki(n,q,h)},y,b,v,C,S,k,I,D,R,M,U,j;if(i==="top")y=g(this.bottom),k=this.bottom-f,D=y-x,M=g(t.top)+x,j=t.bottom;else if(i==="bottom")y=g(this.top),M=t.top,j=g(t.bottom)-x,k=y+x,D=this.top+f;else if(i==="left")y=g(this.right),S=this.right-f,I=y-x,R=g(t.left)+x,U=t.right;else if(i==="right")y=g(this.left),R=t.left,U=g(t.right)-x,S=y+x,I=this.left+f;else if(r==="x"){if(i==="center")y=g((t.top+t.bottom)/2+.5);else if(se(i)){let q=Object.keys(i)[0],X=i[q];y=g(this.chart.scales[q].getPixelForValue(X))}M=t.top,j=t.bottom,k=y+x,D=k+f}else if(r==="y"){if(i==="center")y=g((t.left+t.right)/2);else if(se(i)){let q=Object.keys(i)[0],X=i[q];y=g(this.chart.scales[q].getPixelForValue(X))}S=y-x,I=S-f,R=t.left,U=t.right}let K=Je(o.ticks.maxTicksLimit,p),W=Math.max(1,Math.ceil(p/K));for(b=0;b<p;b+=W){let q=this.getContext(b),X=s.setContext(q),Q=a.setContext(q),Y=X.lineWidth,nt=X.color,rt=Q.dash||[],at=Q.dashOffset,lt=X.tickWidth,ut=X.tickColor,it=X.tickBorderDash||[],dt=X.tickBorderDashOffset;v=LQ(this,b,l),v!==void 0&&(C=Ki(n,v,Y),u?S=I=R=U=C:k=D=M=j=C,m.push({tx1:S,ty1:k,tx2:I,ty2:D,x1:R,y1:M,x2:U,y2:j,width:Y,color:nt,borderDash:rt,borderDashOffset:at,tickWidth:lt,tickColor:ut,tickBorderDash:it,tickBorderDashOffset:dt}))}return this._ticksLength=p,this._borderValue=y,m}_computeLabelItems(t){let r=this.axis,n=this.options,{position:o,ticks:s}=n,i=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:u,padding:c,mirror:p}=s,f=Fg(n.grid),m=f+c,d=p?-c:m,h=-pi(this.labelRotation),x=[],g,y,b,v,C,S,k,I,D,R,M,U,j="middle";if(o==="top")S=this.bottom-d,k=this._getXAxisLabelAlignment();else if(o==="bottom")S=this.top+d,k=this._getXAxisLabelAlignment();else if(o==="left"){let W=this._getYAxisLabelAlignment(f);k=W.textAlign,C=W.x}else if(o==="right"){let W=this._getYAxisLabelAlignment(f);k=W.textAlign,C=W.x}else if(r==="x"){if(o==="center")S=(t.top+t.bottom)/2+m;else if(se(o)){let W=Object.keys(o)[0],q=o[W];S=this.chart.scales[W].getPixelForValue(q)+m}k=this._getXAxisLabelAlignment()}else if(r==="y"){if(o==="center")C=(t.left+t.right)/2-m;else if(se(o)){let W=Object.keys(o)[0],q=o[W];C=this.chart.scales[W].getPixelForValue(q)}k=this._getYAxisLabelAlignment(f).textAlign}r==="y"&&(l==="start"?j="top":l==="end"&&(j="bottom"));let K=this._getLabelSizes();for(g=0,y=a.length;g<y;++g){b=a[g],v=b.label;let W=s.setContext(this.getContext(g));I=this.getPixelForTick(g)+s.labelOffset,D=this._resolveTickFontOptions(g),R=D.lineHeight,M=tr(v)?v.length:1;let q=M/2,X=W.color,Q=W.textStrokeColor,Y=W.textStrokeWidth,nt=k;i?(C=I,k==="inner"&&(g===y-1?nt=this.options.reverse?"left":"right":g===0?nt=this.options.reverse?"right":"left":nt="center"),o==="top"?u==="near"||h!==0?U=-M*R+R/2:u==="center"?U=-K.highest.height/2-q*R+R:U=-K.highest.height+R/2:u==="near"||h!==0?U=R/2:u==="center"?U=K.highest.height/2-q*R:U=K.highest.height-M*R,p&&(U*=-1),h!==0&&!W.showLabelBackdrop&&(C+=R/2*Math.sin(h))):(S=I,U=(1-M)*R/2);let rt;if(W.showLabelBackdrop){let at=to(W.backdropPadding),lt=K.heights[g],ut=K.widths[g],it=U-at.top,dt=0-at.left;switch(j){case"middle":it-=lt/2;break;case"bottom":it-=lt;break}switch(k){case"center":dt-=ut/2;break;case"right":dt-=ut;break}rt={left:dt,top:it,width:ut+at.width,height:lt+at.height,color:W.backdropColor}}x.push({rotation:h,label:v,font:D,color:X,strokeColor:Q,strokeWidth:Y,textOffset:U,textAlign:nt,textBaseline:j,translation:[C,S],backdrop:rt})}return x}_getXAxisLabelAlignment(){let{position:t,ticks:r}=this.options;if(-pi(this.labelRotation))return t==="top"?"left":"right";let o="center";return r.align==="start"?o="left":r.align==="end"?o="right":r.align==="inner"&&(o="inner"),o}_getYAxisLabelAlignment(t){let{position:r,ticks:{crossAlign:n,mirror:o,padding:s}}=this.options,i=this._getLabelSizes(),a=t+s,l=i.widest.width,u,c;return r==="left"?o?(c=this.right+s,n==="near"?u="left":n==="center"?(u="center",c+=l/2):(u="right",c+=l)):(c=this.right-a,n==="near"?u="right":n==="center"?(u="center",c-=l/2):(u="left",c=this.left)):r==="right"?o?(c=this.left+s,n==="near"?u="right":n==="center"?(u="center",c-=l/2):(u="left",c-=l)):(c=this.left+a,n==="near"?u="left":n==="center"?(u="center",c+=l/2):(u="right",c=this.right)):u="right",{textAlign:u,x:c}}_computeLabelArea(){if(this.options.ticks.mirror)return;let t=this.chart,r=this.options.position;if(r==="left"||r==="right")return{top:0,left:this.left,bottom:t.height,right:this.right};if(r==="top"||r==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:t.width}}drawBackground(){let{ctx:t,options:{backgroundColor:r},left:n,top:o,width:s,height:i}=this;r&&(t.save(),t.fillStyle=r,t.fillRect(n,o,s,i),t.restore())}getLineWidthForValue(t){let r=this.options.grid;if(!this._isVisible()||!r.display)return 0;let o=this.ticks.findIndex(s=>s.value===t);return o>=0?r.setContext(this.getContext(o)).lineWidth:0}drawGrid(t){let r=this.options.grid,n=this.ctx,o=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t)),s,i,a=(l,u,c)=>{!c.width||!c.color||(n.save(),n.lineWidth=c.width,n.strokeStyle=c.color,n.setLineDash(c.borderDash||[]),n.lineDashOffset=c.borderDashOffset,n.beginPath(),n.moveTo(l.x,l.y),n.lineTo(u.x,u.y),n.stroke(),n.restore())};if(r.display)for(s=0,i=o.length;s<i;++s){let l=o[s];r.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),r.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){let{chart:t,ctx:r,options:{border:n,grid:o}}=this,s=n.setContext(this.getContext()),i=n.display?s.width:0;if(!i)return;let a=o.setContext(this.getContext(0)).lineWidth,l=this._borderValue,u,c,p,f;this.isHorizontal()?(u=Ki(t,this.left,i)-i/2,c=Ki(t,this.right,a)+a/2,p=f=l):(p=Ki(t,this.top,i)-i/2,f=Ki(t,this.bottom,a)+a/2,u=c=l),r.save(),r.lineWidth=s.width,r.strokeStyle=s.color,r.beginPath(),r.moveTo(u,p),r.lineTo(c,f),r.stroke(),r.restore()}drawLabels(t){if(!this.options.ticks.display)return;let n=this.ctx,o=this._computeLabelArea();o&&Cv(n,o);let s=this._labelItems||(this._labelItems=this._computeLabelItems(t)),i,a;for(i=0,a=s.length;i<a;++i){let l=s[i],u=l.font,c=l.label,p=l.textOffset;Jf(n,c,0,p,u,l)}o&&Sv(n)}drawTitle(){let{ctx:t,options:{position:r,title:n,reverse:o}}=this;if(!n.display)return;let s=Bn(n.font),i=to(n.padding),a=n.align,l=s.lineHeight/2;r==="bottom"||r==="center"||se(r)?(l+=i.bottom,tr(n.text)&&(l+=s.lineHeight*(n.text.length-1))):l+=i.top;let{titleX:u,titleY:c,maxWidth:p,rotation:f}=WQ(this,l,r,a);Jf(t,n.text,0,0,s,{color:n.color,maxWidth:p,rotation:f,textAlign:VQ(a,r,o),textBaseline:"middle",translation:[u,c]})}draw(t){!this._isVisible()||(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){let t=this.options,r=t.ticks&&t.ticks.z||0,n=Je(t.grid&&t.grid.z,-1),o=Je(t.border&&t.border.z,0);return!this._isVisible()||this.draw!==ra.prototype.draw?[{z:r,draw:s=>{this.draw(s)}}]:[{z:n,draw:s=>{this.drawBackground(),this.drawGrid(s),this.drawTitle()}},{z:o,draw:()=>{this.drawBorder()}},{z:r,draw:s=>{this.drawLabels(s)}}]}getMatchingVisibleMetas(t){let r=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",o=[],s,i;for(s=0,i=r.length;s<i;++s){let a=r[s];a[n]===this.id&&(!t||a.type===t)&&o.push(a)}return o}_resolveTickFontOptions(t){let r=this.options.ticks.setContext(this.getContext(t));return Bn(r.font)}_maxDigits(){let t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}},rm=class{constructor(t,r,n){this.type=t,this.scope=r,this.override=n,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){let r=Object.getPrototypeOf(t),n;HQ(r)&&(n=this.register(r));let o=this.items,s=t.id,i=this.scope+"."+s;if(!s)throw new Error("class does not have id: "+t);return s in o||(o[s]=t,GQ(t,i,n),this.override&&vr.override(t.id,t.overrides)),i}get(t){return this.items[t]}unregister(t){let r=this.items,n=t.id,o=this.scope;n in r&&delete r[n],o&&n in vr[o]&&(delete vr[o][n],this.override&&delete Yl[n])}};function GQ(e,t,r){let n=qc(Object.create(null),[r?vr.get(r):{},vr.get(t),e.defaults]);vr.set(t,n),e.defaultRoutes&&UQ(t,e.defaultRoutes),e.descriptors&&vr.describe(t,e.descriptors)}function UQ(e,t){Object.keys(t).forEach(r=>{let n=r.split("."),o=n.pop(),s=[e].concat(n).join("."),i=t[r].split("."),a=i.pop(),l=i.join(".");vr.route(s,o,l,a)})}function HQ(e){return"id"in e&&"defaults"in e}var xI=class{constructor(){this.controllers=new rm(Ql,"datasets",!0),this.elements=new rm(ea,"elements"),this.plugins=new rm(Object,"plugins"),this.scales=new rm(ra,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,r,n){[...r].forEach(o=>{let s=n||this._getRegistryForType(o);n||s.isForType(o)||s===this.plugins&&o.id?this._exec(t,s,o):ge(o,i=>{let a=n||this._getRegistryForType(i);this._exec(t,a,i)})})}_exec(t,r,n){let o=Cg(t);er(n["before"+o],[],n),r[t](n),er(n["after"+o],[],n)}_getRegistryForType(t){for(let r=0;r<this._typedRegistries.length;r++){let n=this._typedRegistries[r];if(n.isForType(t))return n}return this.plugins}_get(t,r,n){let o=r.get(t);if(o===void 0)throw new Error('"'+t+'" is not a registered '+n+".");return o}},mi=new xI,yI=class{constructor(){this._init=[]}notify(t,r,n,o){r==="beforeInit"&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));let s=o?this._descriptors(t).filter(o):this._descriptors(t),i=this._notify(s,t,r,n);return r==="afterDestroy"&&(this._notify(s,t,"stop"),this._notify(this._init,t,"uninstall")),i}_notify(t,r,n,o){o=o||{};for(let s of t){let i=s.plugin,a=i[n],l=[r,o,s.options];if(er(a,l,i)===!1&&o.cancelable)return!1}return!0}invalidate(){ze(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;let r=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),r}_createDescriptors(t,r){let n=t&&t.config,o=Je(n.options&&n.options.plugins,{}),s=qQ(n);return o===!1&&!r?[]:KQ(t,s,o,r)}_notifyStateChanges(t){let r=this._oldCache||[],n=this._cache,o=(s,i)=>s.filter(a=>!i.some(l=>a.plugin.id===l.plugin.id));this._notify(o(r,n),t,"stop"),this._notify(o(n,r),t,"start")}};function qQ(e){let t={},r=[],n=Object.keys(mi.plugins.items);for(let s=0;s<n.length;s++)r.push(mi.getPlugin(n[s]));let o=e.plugins||[];for(let s=0;s<o.length;s++){let i=o[s];r.indexOf(i)===-1&&(r.push(i),t[i.id]=!0)}return{plugins:r,localIds:t}}function jQ(e,t){return!t&&e===!1?null:e===!0?{}:e}function KQ(e,{plugins:t,localIds:r},n,o){let s=[],i=e.getContext();for(let a of t){let l=a.id,u=jQ(n[l],o);u!==null&&s.push({plugin:a,options:XQ(e.config,{plugin:a,local:r[l]},u,i)})}return s}function XQ(e,{plugin:t,local:r},n,o){let s=e.pluginScopeKeys(t),i=e.getOptionScopes(n,s);return r&&t.defaults&&i.push(t.defaults),e.createResolver(i,o,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function bI(e,t){let r=vr.datasets[e]||{};return((t.datasets||{})[e]||{}).indexAxis||t.indexAxis||r.indexAxis||"x"}function YQ(e,t){let r=e;return e==="_index_"?r=t:e==="_value_"&&(r=t==="x"?"y":"x"),r}function QQ(e,t){return e===t?"_index_":"_value_"}function ZQ(e){if(e==="top"||e==="bottom")return"x";if(e==="left"||e==="right")return"y"}function Gv(e,t){if(e==="x"||e==="y"||e==="r"||(e=t.axis||ZQ(t.position)||e.length>1&&Gv(e[0].toLowerCase(),t),e))return e;throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`)}function JQ(e,t){let r=Yl[e.type]||{scales:{}},n=t.scales||{},o=bI(e.type,t),s=Object.create(null);return Object.keys(n).forEach(i=>{let a=n[i];if(!se(a))return console.error(`Invalid scale configuration for scale: ${i}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${i}`);let l=Gv(i,a),u=QQ(l,o),c=r.scales||{};s[i]=jc(Object.create(null),[{axis:l},a,c[l],c[u]])}),e.data.datasets.forEach(i=>{let a=i.type||e.type,l=i.indexAxis||bI(a,t),c=(Yl[a]||{}).scales||{};Object.keys(c).forEach(p=>{let f=YQ(p,l),m=i[f+"AxisID"]||f;s[m]=s[m]||Object.create(null),jc(s[m],[{axis:f},n[m],c[p]])})}),Object.keys(s).forEach(i=>{let a=s[i];jc(a,[vr.scales[a.type],vr.scale])}),s}function AF(e){let t=e.options||(e.options={});t.plugins=Je(t.plugins,{}),t.scales=JQ(e,t)}function DF(e){return e=e||{},e.datasets=e.datasets||[],e.labels=e.labels||[],e}function tZ(e){return e=e||{},e.data=DF(e.data),AF(e),e}var oF=new Map,RF=new Set;function $v(e,t){let r=oF.get(e);return r||(r=t(),oF.set(e,r),RF.add(r)),r}var Pg=(e,t,r)=>{let n=Xf(t,r);n!==void 0&&e.add(n)},vI=class{constructor(t){this._config=tZ(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=DF(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){let t=this._config;this.clearCache(),AF(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return $v(t,()=>[[`datasets.${t}`,""]])}datasetAnimationScopeKeys(t,r){return $v(`${t}.transition.${r}`,()=>[[`datasets.${t}.transitions.${r}`,`transitions.${r}`],[`datasets.${t}`,""]])}datasetElementScopeKeys(t,r){return $v(`${t}-${r}`,()=>[[`datasets.${t}.elements.${r}`,`datasets.${t}`,`elements.${r}`,""]])}pluginScopeKeys(t){let r=t.id,n=this.type;return $v(`${n}-plugin-${r}`,()=>[[`plugins.${r}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,r){let n=this._scopeCache,o=n.get(t);return(!o||r)&&(o=new Map,n.set(t,o)),o}getOptionScopes(t,r,n){let{options:o,type:s}=this,i=this._cachedScopes(t,n),a=i.get(r);if(a)return a;let l=new Set;r.forEach(c=>{t&&(l.add(t),c.forEach(p=>Pg(l,t,p))),c.forEach(p=>Pg(l,o,p)),c.forEach(p=>Pg(l,Yl[s]||{},p)),c.forEach(p=>Pg(l,vr,p)),c.forEach(p=>Pg(l,yv,p))});let u=Array.from(l);return u.length===0&&u.push(Object.create(null)),RF.has(r)&&i.set(r,u),u}chartOptionScopes(){let{options:t,type:r}=this;return[t,Yl[r]||{},vr.datasets[r]||{},{type:r},vr,yv]}resolveNamedOptions(t,r,n,o=[""]){let s={$shared:!0},{resolver:i,subPrefixes:a}=sF(this._resolverCache,t,o),l=i;if(rZ(i,r)){s.$shared=!1,n=ui(n)?n():n;let u=this.createResolver(t,n,a);l=Xl(i,n,u)}for(let u of r)s[u]=l[u];return s}createResolver(t,r,n=[""],o){let{resolver:s}=sF(this._resolverCache,t,n);return se(r)?Xl(s,r,void 0,o):s}};function sF(e,t,r){let n=e.get(t);n||(n=new Map,e.set(t,n));let o=r.join(),s=n.get(o);return s||(s={resolver:_g(t,r),subPrefixes:r.filter(a=>!a.toLowerCase().includes("hover"))},n.set(o,s)),s}var eZ=e=>se(e)&&Object.getOwnPropertyNames(e).reduce((t,r)=>t||ui(e[r]),!1);function rZ(e,t){let{isScriptable:r,isIndexable:n}=Tv(e);for(let o of t){let s=r(o),i=n(o),a=(i||s)&&e[o];if(s&&(ui(a)||eZ(a))||i&&tr(a))return!0}return!1}var nZ="4.0.1",oZ=["top","bottom","left","right","chartArea"];function iF(e,t){return e==="top"||e==="bottom"||oZ.indexOf(e)===-1&&t==="x"}function aF(e,t){return function(r,n){return r[e]===n[e]?r[t]-n[t]:r[e]-n[e]}}function lF(e){let t=e.chart,r=t.options.animation;t.notifyPlugins("afterRender"),er(r&&r.onComplete,[e],t)}function sZ(e){let t=e.chart,r=t.options.animation;er(r&&r.onProgress,[e],t)}function $F(e){return Nv()&&typeof e=="string"?e=document.getElementById(e):e&&e.length&&(e=e[0]),e&&e.canvas&&(e=e.canvas),e}var zv={},uF=e=>{let t=$F(e);return Object.values(zv).filter(r=>r.canvas===t).pop()};function iZ(e,t,r){let n=Object.keys(e);for(let o of n){let s=+o;if(s>=t){let i=e[o];delete e[o],(r>0||s>t)&&(e[s+r]=i)}}}function aZ(e,t,r,n){return!r||e.type==="mouseout"?null:n?t:e}function lZ(e){let{xScale:t,yScale:r}=e;if(t&&r)return{left:t.left,right:t.right,top:r.top,bottom:r.bottom}}var di=class{static register(...t){mi.add(...t),cF()}static unregister(...t){mi.remove(...t),cF()}constructor(t,r){let n=this.config=new vI(r),o=$F(t),s=uF(o);if(s)throw new Error("Canvas is already in use. Chart with ID '"+s.id+"' must be destroyed before the canvas with ID '"+s.canvas.id+"' can be reused.");let i=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||_Q(o)),this.platform.updateConfig(n);let a=this.platform.acquireContext(o,i.aspectRatio),l=a&&a.canvas,u=l&&l.height,c=l&&l.width;if(this.id=$N(),this.ctx=a,this.canvas=l,this.width=c,this.height=u,this._options=i,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new yI,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=qN(p=>this.update(p),i.resizeDelay||0),this._dataChanges=[],zv[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}Ji.listen(this,"complete",lF),Ji.listen(this,"progress",sZ),this._initialize(),this.attached&&this.update()}get aspectRatio(){let{options:{aspectRatio:t,maintainAspectRatio:r},width:n,height:o,_aspectRatio:s}=this;return ze(t)?r&&s?s:o?n/o:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return mi}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():Ev(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return bv(this.canvas,this.ctx),this}stop(){return Ji.stop(this),this}resize(t,r){Ji.running(this)?this._resizeBeforeDraw={width:t,height:r}:this._resize(t,r)}_resize(t,r){let n=this.options,o=this.canvas,s=n.maintainAspectRatio&&this.aspectRatio,i=this.platform.getMaximumSize(o,t,r,s),a=n.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=i.width,this.height=i.height,this._aspectRatio=this.aspectRatio,Ev(this,a,!0)&&(this.notifyPlugins("resize",{size:i}),er(n.onResize,[this,i],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){let r=this.options.scales||{};ge(r,(n,o)=>{n.id=o})}buildOrUpdateScales(){let t=this.options,r=t.scales,n=this.scales,o=Object.keys(n).reduce((i,a)=>(i[a]=!1,i),{}),s=[];r&&(s=s.concat(Object.keys(r).map(i=>{let a=r[i],l=Gv(i,a),u=l==="r",c=l==="x";return{options:a,dposition:u?"chartArea":c?"bottom":"left",dtype:u?"radialLinear":c?"category":"linear"}}))),ge(s,i=>{let a=i.options,l=a.id,u=Gv(l,a),c=Je(a.type,i.dtype);(a.position===void 0||iF(a.position,u)!==iF(i.dposition))&&(a.position=i.dposition),o[l]=!0;let p=null;if(l in n&&n[l].type===c)p=n[l];else{let f=mi.getScale(c);p=new f({id:l,type:c,ctx:this.ctx,chart:this}),n[p.id]=p}p.init(a,t)}),ge(o,(i,a)=>{i||delete n[a]}),ge(n,i=>{Dv.configure(this,i,i.options),Dv.addBox(this,i)})}_updateMetasets(){let t=this._metasets,r=this.data.datasets.length,n=t.length;if(t.sort((o,s)=>o.index-s.index),n>r){for(let o=r;o<n;++o)this._destroyDatasetMeta(o);t.splice(r,n-r)}this._sortedMetasets=t.slice(0).sort(aF("order","index"))}_removeUnreferencedMetasets(){let{_metasets:t,data:{datasets:r}}=this;t.length>r.length&&delete this._stacks,t.forEach((n,o)=>{r.filter(s=>s===n._dataset).length===0&&this._destroyDatasetMeta(o)})}buildOrUpdateControllers(){let t=[],r=this.data.datasets,n,o;for(this._removeUnreferencedMetasets(),n=0,o=r.length;n<o;n++){let s=r[n],i=this.getDatasetMeta(n),a=s.type||this.config.type;if(i.type&&i.type!==a&&(this._destroyDatasetMeta(n),i=this.getDatasetMeta(n)),i.type=a,i.indexAxis=s.indexAxis||bI(a,this.options),i.order=s.order||0,i.index=n,i.label=""+s.label,i.visible=this.isDatasetVisible(n),i.controller)i.controller.updateIndex(n),i.controller.linkScales();else{let l=mi.getController(a),{datasetElementType:u,dataElementType:c}=vr.datasets[a];Object.assign(l,{dataElementType:mi.getElement(c),datasetElementType:u&&mi.getElement(u)}),i.controller=new l(this,n),t.push(i.controller)}}return this._updateMetasets(),t}_resetElements(){ge(this.data.datasets,(t,r)=>{this.getDatasetMeta(r).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){let r=this.config;r.update();let n=this._options=r.createResolver(r.chartOptionScopes(),this.getContext()),o=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0})===!1)return;let s=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let i=0;for(let u=0,c=this.data.datasets.length;u<c;u++){let{controller:p}=this.getDatasetMeta(u),f=!o&&s.indexOf(p)===-1;p.buildOrUpdateElements(f),i=Math.max(+p.getMaxOverflow(),i)}i=this._minPadding=n.layout.autoPadding?i:0,this._updateLayout(i),o||ge(s,u=>{u.reset()}),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(aF("z","_idx"));let{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){ge(this.scales,t=>{Dv.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){let t=this.options,r=new Set(Object.keys(this._listeners)),n=new Set(t.events);(!lv(r,n)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){let{_hiddenIndices:t}=this,r=this._getUniformDataChanges()||[];for(let{method:n,start:o,count:s}of r){let i=n==="_removeElements"?-s:s;iZ(t,o,i)}}_getUniformDataChanges(){let t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];let r=this.data.datasets.length,n=s=>new Set(t.filter(i=>i[0]===s).map((i,a)=>a+","+i.splice(1).join(","))),o=n(0);for(let s=1;s<r;s++)if(!lv(o,n(s)))return;return Array.from(o).map(s=>s.split(",")).map(s=>({method:s[1],start:+s[2],count:+s[3]}))}_updateLayout(t){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;Dv.update(this,this.width,this.height,t);let r=this.chartArea,n=r.width<=0||r.height<=0;this._layers=[],ge(this.boxes,o=>{n&&o.position==="chartArea"||(o.configure&&o.configure(),this._layers.push(...o._layers()))},this),this._layers.forEach((o,s)=>{o._idx=s}),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})!==!1){for(let r=0,n=this.data.datasets.length;r<n;++r)this.getDatasetMeta(r).controller.configure();for(let r=0,n=this.data.datasets.length;r<n;++r)this._updateDataset(r,ui(t)?t({datasetIndex:r}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,r){let n=this.getDatasetMeta(t),o={meta:n,index:t,mode:r,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",o)!==!1&&(n.controller._update(r),o.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",o))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(Ji.has(this)?this.attached&&!Ji.running(this)&&Ji.start(this):(this.draw(),lF({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){let{width:n,height:o}=this._resizeBeforeDraw;this._resize(n,o),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;let r=this._layers;for(t=0;t<r.length&&r[t].z<=0;++t)r[t].draw(this.chartArea);for(this._drawDatasets();t<r.length;++t)r[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){let r=this._sortedMetasets,n=[],o,s;for(o=0,s=r.length;o<s;++o){let i=r[o];(!t||i.visible)&&n.push(i)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;let t=this.getSortedVisibleDatasetMetas();for(let r=t.length-1;r>=0;--r)this._drawDataset(t[r]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){let r=this.ctx,n=t._clip,o=!n.disabled,s=lZ(t)||this.chartArea,i={meta:t,index:t.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",i)!==!1&&(o&&Cv(r,{left:n.left===!1?0:s.left-n.left,right:n.right===!1?this.width:s.right+n.right,top:n.top===!1?0:s.top-n.top,bottom:n.bottom===!1?this.height:s.bottom+n.bottom}),t.controller.draw(),o&&Sv(r),i.cancelable=!1,this.notifyPlugins("afterDatasetDraw",i))}isPointInArea(t){return wv(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,r,n,o){let s=cQ.modes[r];return typeof s=="function"?s(this,t,n,o):[]}getDatasetMeta(t){let r=this.data.datasets[t],n=this._metasets,o=n.filter(s=>s&&s._dataset===r).pop();return o||(o={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:r&&r.order||0,index:t,_dataset:r,_parsed:[],_sorted:!1},n.push(o)),o}getContext(){return this.$context||(this.$context=Qi(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){let r=this.data.datasets[t];if(!r)return!1;let n=this.getDatasetMeta(t);return typeof n.hidden=="boolean"?!n.hidden:!r.hidden}setDatasetVisibility(t,r){let n=this.getDatasetMeta(t);n.hidden=!r}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,r,n){let o=n?"show":"hide",s=this.getDatasetMeta(t),i=s.controller._resolveAnimations(void 0,o);No(r)?(s.data[r].hidden=!n,this.update()):(this.setDatasetVisibility(t,n),i.update(s,{visible:n}),this.update(a=>a.datasetIndex===t?o:void 0))}hide(t,r){this._updateVisibility(t,r,!1)}show(t,r){this._updateVisibility(t,r,!0)}_destroyDatasetMeta(t){let r=this._metasets[t];r&&r.controller&&r.controller._destroy(),delete this._metasets[t]}_stop(){let t,r;for(this.stop(),Ji.remove(this),t=0,r=this.data.datasets.length;t<r;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");let{canvas:t,ctx:r}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),bv(t,r),this.platform.releaseContext(r),this.canvas=null,this.ctx=null),delete zv[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){let t=this._listeners,r=this.platform,n=(s,i)=>{r.addEventListener(this,s,i),t[s]=i},o=(s,i,a)=>{s.offsetX=i,s.offsetY=a,this._eventHandler(s)};ge(this.options.events,s=>n(s,o))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});let t=this._responsiveListeners,r=this.platform,n=(l,u)=>{r.addEventListener(this,l,u),t[l]=u},o=(l,u)=>{t[l]&&(r.removeEventListener(this,l,u),delete t[l])},s=(l,u)=>{this.canvas&&this.resize(l,u)},i,a=()=>{o("attach",a),this.attached=!0,this.resize(),n("resize",s),n("detach",i)};i=()=>{this.attached=!1,o("resize",s),this._stop(),this._resize(0,0),n("attach",a)},r.isAttached(this.canvas)?a():i()}unbindEvents(){ge(this._listeners,(t,r)=>{this.platform.removeEventListener(this,r,t)}),this._listeners={},ge(this._responsiveListeners,(t,r)=>{this.platform.removeEventListener(this,r,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,r,n){let o=n?"set":"remove",s,i,a,l;for(r==="dataset"&&(s=this.getDatasetMeta(t[0].datasetIndex),s.controller["_"+o+"DatasetHoverStyle"]()),a=0,l=t.length;a<l;++a){i=t[a];let u=i&&this.getDatasetMeta(i.datasetIndex).controller;u&&u[o+"HoverStyle"](i.element,i.datasetIndex,i.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){let r=this._active||[],n=t.map(({datasetIndex:s,index:i})=>{let a=this.getDatasetMeta(s);if(!a)throw new Error("No dataset found at index "+s);return{datasetIndex:s,element:a.data[i],index:i}});!Kf(n,r)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,r))}notifyPlugins(t,r,n){return this._plugins.notify(this,t,r,n)}isPluginEnabled(t){return this._plugins._cache.filter(r=>r.plugin.id===t).length===1}_updateHoverStyles(t,r,n){let o=this.options.hover,s=(l,u)=>l.filter(c=>!u.some(p=>c.datasetIndex===p.datasetIndex&&c.index===p.index)),i=s(r,t),a=n?t:s(t,r);i.length&&this.updateHoverStyle(i,o.mode,!1),a.length&&o.mode&&this.updateHoverStyle(a,o.mode,!0)}_eventHandler(t,r){let n={event:t,replay:r,cancelable:!0,inChartArea:this.isPointInArea(t)},o=i=>(i.options.events||this.options.events).includes(t.native.type);if(this.notifyPlugins("beforeEvent",n,o)===!1)return;let s=this._handleEvent(t,r,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,o),(s||n.changed)&&this.render(),this}_handleEvent(t,r,n){let{_active:o=[],options:s}=this,i=r,a=this._getActiveElements(t,o,n,i),l=FN(t),u=aZ(t,this._lastEvent,n,l);n&&(this._lastEvent=null,er(s.onHover,[t,a,this],this),l&&er(s.onClick,[t,a,this],this));let c=!Kf(a,o);return(c||r)&&(this._active=a,this._updateHoverStyles(a,o,r)),this._lastEvent=u,c}_getActiveElements(t,r,n,o){if(t.type==="mouseout")return[];if(!n)return r;let s=this.options.hover;return this.getElementsAtEventForMode(t,s.mode,s,o)}};Ne(di,"defaults",vr),Ne(di,"instances",zv),Ne(di,"overrides",Yl),Ne(di,"registry",mi),Ne(di,"version",nZ),Ne(di,"getChart",uF);function cF(){return ge(di.instances,e=>e._plugins.invalidate())}var Uv=di;var Mg={average(e){if(!e.length)return!1;let t,r,n=0,o=0,s=0;for(t=0,r=e.length;t<r;++t){let i=e[t].element;if(i&&i.hasValue()){let a=i.tooltipPosition();n+=a.x,o+=a.y,++s}}return{x:n/s,y:o/s}},nearest(e,t){if(!e.length)return!1;let r=t.x,n=t.y,o=Number.POSITIVE_INFINITY,s,i,a;for(s=0,i=e.length;s<i;++s){let l=e[s].element;if(l&&l.hasValue()){let u=l.getCenterPoint(),c=zN(t,u);c<o&&(o=c,a=l)}}if(a){let l=a.tooltipPosition();r=l.x,n=l.y}return{x:r,y:n}}};function fi(e,t){return t&&(tr(t)?Array.prototype.push.apply(e,t):e.push(t)),e}function ta(e){return(typeof e=="string"||e instanceof String)&&e.indexOf(`
`)>-1?e.split(`
`):e}function uZ(e,t){let{element:r,datasetIndex:n,index:o}=t,s=e.getDatasetMeta(n).controller,{label:i,value:a}=s.getLabelAndValue(o);return{chart:e,label:i,parsed:s.getParsed(o),raw:e.data.datasets[n].data[o],formattedValue:a,dataset:s.getDataset(),dataIndex:o,datasetIndex:n,element:r}}function pF(e,t){let r=e.chart.ctx,{body:n,footer:o,title:s}=e,{boxWidth:i,boxHeight:a}=t,l=Bn(t.bodyFont),u=Bn(t.titleFont),c=Bn(t.footerFont),p=s.length,f=o.length,m=n.length,d=to(t.padding),h=d.height,x=0,g=n.reduce((v,C)=>v+C.before.length+C.lines.length+C.after.length,0);if(g+=e.beforeBody.length+e.afterBody.length,p&&(h+=p*u.lineHeight+(p-1)*t.titleSpacing+t.titleMarginBottom),g){let v=t.displayColors?Math.max(a,l.lineHeight):l.lineHeight;h+=m*v+(g-m)*l.lineHeight+(g-1)*t.bodySpacing}f&&(h+=t.footerMarginTop+f*c.lineHeight+(f-1)*t.footerSpacing);let y=0,b=function(v){x=Math.max(x,r.measureText(v).width+y)};return r.save(),r.font=u.string,ge(e.title,b),r.font=l.string,ge(e.beforeBody.concat(e.afterBody),b),y=t.displayColors?i+2+t.boxPadding:0,ge(n,v=>{ge(v.before,b),ge(v.lines,b),ge(v.after,b)}),y=0,r.font=c.string,ge(e.footer,b),r.restore(),x+=d.width,{width:x,height:h}}function cZ(e,t){let{y:r,height:n}=t;return r<n/2?"top":r>e.height-n/2?"bottom":"center"}function pZ(e,t,r,n){let{x:o,width:s}=n,i=r.caretSize+r.caretPadding;if(e==="left"&&o+s+i>t.width||e==="right"&&o-s-i<0)return!0}function fZ(e,t,r,n){let{x:o,width:s}=r,{width:i,chartArea:{left:a,right:l}}=e,u="center";return n==="center"?u=o<=(a+l)/2?"left":"right":o<=s/2?u="left":o>=i-s/2&&(u="right"),pZ(u,e,t,r)&&(u="center"),u}function fF(e,t,r){let n=r.yAlign||t.yAlign||cZ(e,r);return{xAlign:r.xAlign||t.xAlign||fZ(e,t,r,n),yAlign:n}}function mZ(e,t){let{x:r,width:n}=e;return t==="right"?r-=n:t==="center"&&(r-=n/2),r}function dZ(e,t,r){let{y:n,height:o}=e;return t==="top"?n+=r:t==="bottom"?n-=o+r:n-=o/2,n}function mF(e,t,r,n){let{caretSize:o,caretPadding:s,cornerRadius:i}=e,{xAlign:a,yAlign:l}=r,u=o+s,{topLeft:c,topRight:p,bottomLeft:f,bottomRight:m}=Yi(i),d=mZ(t,a),h=dZ(t,l,u);return l==="center"?a==="left"?d+=u:a==="right"&&(d-=u):a==="left"?d-=Math.max(c,f)+o:a==="right"&&(d+=Math.max(p,m)+o),{x:Ko(d,0,n.width-t.width),y:Ko(h,0,n.height-t.height)}}function Ov(e,t,r){let n=to(r.padding);return t==="center"?e.x+e.width/2:t==="right"?e.x+e.width-n.right:e.x+n.left}function dF(e){return fi([],ta(e))}function hZ(e,t,r){return Qi(e,{tooltip:t,tooltipItems:r,type:"tooltip"})}function hF(e,t){let r=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return r?e.override(r):e}var OF={beforeTitle:Os,title(e){if(e.length>0){let t=e[0],r=t.chart.data.labels,n=r?r.length:0;if(this&&this.options&&this.options.mode==="dataset")return t.dataset.label||"";if(t.label)return t.label;if(n>0&&t.dataIndex<n)return r[t.dataIndex]}return""},afterTitle:Os,beforeBody:Os,beforeLabel:Os,label(e){if(this&&this.options&&this.options.mode==="dataset")return e.label+": "+e.formattedValue||e.formattedValue;let t=e.dataset.label||"";t&&(t+=": ");let r=e.formattedValue;return ze(r)||(t+=r),t},labelColor(e){let r=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{borderColor:r.borderColor,backgroundColor:r.backgroundColor,borderWidth:r.borderWidth,borderDash:r.borderDash,borderDashOffset:r.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(e){let r=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{pointStyle:r.pointStyle,rotation:r.rotation}},afterLabel:Os,afterBody:Os,beforeFooter:Os,footer:Os,afterFooter:Os};function eo(e,t,r,n){let o=e[t].call(r,n);return typeof o=="undefined"?OF[t].call(r,n):o}var zg=class extends ea{constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){let t=this._cachedAnimations;if(t)return t;let r=this.chart,n=this.options.setContext(this.getContext()),o=n.enabled&&r.options.animation&&n.animations,s=new Bv(this.chart,o);return o._cacheable&&(this._cachedAnimations=Object.freeze(s)),s}getContext(){return this.$context||(this.$context=hZ(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,r){let{callbacks:n}=r,o=eo(n,"beforeTitle",this,t),s=eo(n,"title",this,t),i=eo(n,"afterTitle",this,t),a=[];return a=fi(a,ta(o)),a=fi(a,ta(s)),a=fi(a,ta(i)),a}getBeforeBody(t,r){return dF(eo(r.callbacks,"beforeBody",this,t))}getBody(t,r){let{callbacks:n}=r,o=[];return ge(t,s=>{let i={before:[],lines:[],after:[]},a=hF(n,s);fi(i.before,ta(eo(a,"beforeLabel",this,s))),fi(i.lines,eo(a,"label",this,s)),fi(i.after,ta(eo(a,"afterLabel",this,s))),o.push(i)}),o}getAfterBody(t,r){return dF(eo(r.callbacks,"afterBody",this,t))}getFooter(t,r){let{callbacks:n}=r,o=eo(n,"beforeFooter",this,t),s=eo(n,"footer",this,t),i=eo(n,"afterFooter",this,t),a=[];return a=fi(a,ta(o)),a=fi(a,ta(s)),a=fi(a,ta(i)),a}_createItems(t){let r=this._active,n=this.chart.data,o=[],s=[],i=[],a=[],l,u;for(l=0,u=r.length;l<u;++l)a.push(uZ(this.chart,r[l]));return t.filter&&(a=a.filter((c,p,f)=>t.filter(c,p,f,n))),t.itemSort&&(a=a.sort((c,p)=>t.itemSort(c,p,n))),ge(a,c=>{let p=hF(t.callbacks,c);o.push(eo(p,"labelColor",this,c)),s.push(eo(p,"labelPointStyle",this,c)),i.push(eo(p,"labelTextColor",this,c))}),this.labelColors=o,this.labelPointStyles=s,this.labelTextColors=i,this.dataPoints=a,a}update(t,r){let n=this.options.setContext(this.getContext()),o=this._active,s,i=[];if(!o.length)this.opacity!==0&&(s={opacity:0});else{let a=Mg[n.position].call(this,o,this._eventPosition);i=this._createItems(n),this.title=this.getTitle(i,n),this.beforeBody=this.getBeforeBody(i,n),this.body=this.getBody(i,n),this.afterBody=this.getAfterBody(i,n),this.footer=this.getFooter(i,n);let l=this._size=pF(this,n),u=Object.assign({},a,l),c=fF(this.chart,n,u),p=mF(n,u,c,this.chart);this.xAlign=c.xAlign,this.yAlign=c.yAlign,s={opacity:1,x:p.x,y:p.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=i,this.$context=void 0,s&&this._resolveAnimations().update(this,s),t&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:r})}drawCaret(t,r,n,o){let s=this.getCaretPosition(t,n,o);r.lineTo(s.x1,s.y1),r.lineTo(s.x2,s.y2),r.lineTo(s.x3,s.y3)}getCaretPosition(t,r,n){let{xAlign:o,yAlign:s}=this,{caretSize:i,cornerRadius:a}=n,{topLeft:l,topRight:u,bottomLeft:c,bottomRight:p}=Yi(a),{x:f,y:m}=t,{width:d,height:h}=r,x,g,y,b,v,C;return s==="center"?(v=m+h/2,o==="left"?(x=f,g=x-i,b=v+i,C=v-i):(x=f+d,g=x+i,b=v-i,C=v+i),y=x):(o==="left"?g=f+Math.max(l,c)+i:o==="right"?g=f+d-Math.max(u,p)-i:g=this.caretX,s==="top"?(b=m,v=b-i,x=g-i,y=g+i):(b=m+h,v=b+i,x=g+i,y=g-i),C=b),{x1:x,x2:g,x3:y,y1:b,y2:v,y3:C}}drawTitle(t,r,n){let o=this.title,s=o.length,i,a,l;if(s){let u=Dg(n.rtl,this.x,this.width);for(t.x=Ov(this,n.titleAlign,n),r.textAlign=u.textAlign(n.titleAlign),r.textBaseline="middle",i=Bn(n.titleFont),a=n.titleSpacing,r.fillStyle=n.titleColor,r.font=i.string,l=0;l<s;++l)r.fillText(o[l],u.x(t.x),t.y+i.lineHeight/2),t.y+=i.lineHeight+a,l+1===s&&(t.y+=n.titleMarginBottom-a)}}_drawColorBox(t,r,n,o,s){let i=this.labelColors[n],a=this.labelPointStyles[n],{boxHeight:l,boxWidth:u,boxPadding:c}=s,p=Bn(s.bodyFont),f=Ov(this,"left",s),m=o.x(f),d=l<p.lineHeight?(p.lineHeight-l)/2:0,h=r.y+d;if(s.usePointStyle){let x={radius:Math.min(u,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},g=o.leftForLtr(m,u)+u/2,y=h+l/2;t.strokeStyle=s.multiKeyBackground,t.fillStyle=s.multiKeyBackground,vv(t,x,g,y),t.strokeStyle=i.borderColor,t.fillStyle=i.backgroundColor,vv(t,x,g,y)}else{t.lineWidth=se(i.borderWidth)?Math.max(...Object.values(i.borderWidth)):i.borderWidth||1,t.strokeStyle=i.borderColor,t.setLineDash(i.borderDash||[]),t.lineDashOffset=i.borderDashOffset||0;let x=o.leftForLtr(m,u-c),g=o.leftForLtr(o.xPlus(m,1),u-c-2),y=Yi(i.borderRadius);Object.values(y).some(b=>b!==0)?(t.beginPath(),t.fillStyle=s.multiKeyBackground,Xi(t,{x,y:h,w:u,h:l,radius:y}),t.fill(),t.stroke(),t.fillStyle=i.backgroundColor,t.beginPath(),Xi(t,{x:g,y:h+1,w:u-2,h:l-2,radius:y}),t.fill()):(t.fillStyle=s.multiKeyBackground,t.fillRect(x,h,u,l),t.strokeRect(x,h,u,l),t.fillStyle=i.backgroundColor,t.fillRect(g,h+1,u-2,l-2))}t.fillStyle=this.labelTextColors[n]}drawBody(t,r,n){let{body:o}=this,{bodySpacing:s,bodyAlign:i,displayColors:a,boxHeight:l,boxWidth:u,boxPadding:c}=n,p=Bn(n.bodyFont),f=p.lineHeight,m=0,d=Dg(n.rtl,this.x,this.width),h=function(I){r.fillText(I,d.x(t.x+m),t.y+f/2),t.y+=f+s},x=d.textAlign(i),g,y,b,v,C,S,k;for(r.textAlign=i,r.textBaseline="middle",r.font=p.string,t.x=Ov(this,x,n),r.fillStyle=n.bodyColor,ge(this.beforeBody,h),m=a&&x!=="right"?i==="center"?u/2+c:u+2+c:0,v=0,S=o.length;v<S;++v){for(g=o[v],y=this.labelTextColors[v],r.fillStyle=y,ge(g.before,h),b=g.lines,a&&b.length&&(this._drawColorBox(r,t,v,d,n),f=Math.max(p.lineHeight,l)),C=0,k=b.length;C<k;++C)h(b[C]),f=p.lineHeight;ge(g.after,h)}m=0,f=p.lineHeight,ge(this.afterBody,h),t.y-=s}drawFooter(t,r,n){let o=this.footer,s=o.length,i,a;if(s){let l=Dg(n.rtl,this.x,this.width);for(t.x=Ov(this,n.footerAlign,n),t.y+=n.footerMarginTop,r.textAlign=l.textAlign(n.footerAlign),r.textBaseline="middle",i=Bn(n.footerFont),r.fillStyle=n.footerColor,r.font=i.string,a=0;a<s;++a)r.fillText(o[a],l.x(t.x),t.y+i.lineHeight/2),t.y+=i.lineHeight+n.footerSpacing}}drawBackground(t,r,n,o){let{xAlign:s,yAlign:i}=this,{x:a,y:l}=t,{width:u,height:c}=n,{topLeft:p,topRight:f,bottomLeft:m,bottomRight:d}=Yi(o.cornerRadius);r.fillStyle=o.backgroundColor,r.strokeStyle=o.borderColor,r.lineWidth=o.borderWidth,r.beginPath(),r.moveTo(a+p,l),i==="top"&&this.drawCaret(t,r,n,o),r.lineTo(a+u-f,l),r.quadraticCurveTo(a+u,l,a+u,l+f),i==="center"&&s==="right"&&this.drawCaret(t,r,n,o),r.lineTo(a+u,l+c-d),r.quadraticCurveTo(a+u,l+c,a+u-d,l+c),i==="bottom"&&this.drawCaret(t,r,n,o),r.lineTo(a+m,l+c),r.quadraticCurveTo(a,l+c,a,l+c-m),i==="center"&&s==="left"&&this.drawCaret(t,r,n,o),r.lineTo(a,l+p),r.quadraticCurveTo(a,l,a+p,l),r.closePath(),r.fill(),o.borderWidth>0&&r.stroke()}_updateAnimationTarget(t){let r=this.chart,n=this.$animations,o=n&&n.x,s=n&&n.y;if(o||s){let i=Mg[t.position].call(this,this._active,this._eventPosition);if(!i)return;let a=this._size=pF(this,t),l=Object.assign({},i,this._size),u=fF(r,t,l),c=mF(t,l,u,r);(o._to!==c.x||s._to!==c.y)&&(this.xAlign=u.xAlign,this.yAlign=u.yAlign,this.width=a.width,this.height=a.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,c))}}_willRender(){return!!this.opacity}draw(t){let r=this.options.setContext(this.getContext()),n=this.opacity;if(!n)return;this._updateAnimationTarget(r);let o={width:this.width,height:this.height},s={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;let i=to(r.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;r.enabled&&a&&(t.save(),t.globalAlpha=n,this.drawBackground(s,t,o,r),iI(t,r.textDirection),s.y+=i.top,this.drawTitle(s,t,r),this.drawBody(s,t,r),this.drawFooter(s,t,r),aI(t,r.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,r){let n=this._active,o=t.map(({datasetIndex:a,index:l})=>{let u=this.chart.getDatasetMeta(a);if(!u)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:u.data[l],index:l}}),s=!Kf(n,o),i=this._positionChanged(o,r);(s||i)&&(this._active=o,this._eventPosition=r,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,r,n=!0){if(r&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;let o=this.options,s=this._active||[],i=this._getActiveElements(t,s,r,n),a=this._positionChanged(i,t),l=r||!Kf(i,s)||a;return l&&(this._active=i,(o.enabled||o.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,r))),l}_getActiveElements(t,r,n,o){let s=this.options;if(t.type==="mouseout")return[];if(!o)return r;let i=this.chart.getElementsAtEventForMode(t,s.mode,s,n);return s.reverse&&i.reverse(),i}_positionChanged(t,r){let{caretX:n,caretY:o,options:s}=this,i=Mg[s.position].call(this,t,r);return i!==!1&&(n!==i.x||o!==i.y)}};Ne(zg,"positioners",Mg);var FF={id:"tooltip",_element:zg,positioners:Mg,afterInit(e,t,r){r&&(e.tooltip=new zg({chart:e,options:r}))},beforeUpdate(e,t,r){e.tooltip&&e.tooltip.initialize(r)},reset(e,t,r){e.tooltip&&e.tooltip.initialize(r)},afterDraw(e){let t=e.tooltip;if(t&&t._willRender()){let r={tooltip:t};if(e.notifyPlugins("beforeTooltipDraw",R0(ae({},r),{cancelable:!0}))===!1)return;t.draw(e.ctx),e.notifyPlugins("afterTooltipDraw",r)}},afterEvent(e,t){if(e.tooltip){let r=t.replay;e.tooltip.handleEvent(t.event,r,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(e,t)=>t.bodyFont.size,boxWidth:(e,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:OF},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:e=>e!=="filter"&&e!=="itemSort"&&e!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};var gZ=(e,t,r,n)=>(typeof t=="string"?(r=e.push(t)-1,n.unshift({index:r,label:t})):isNaN(t)&&(r=null),r);function xZ(e,t,r,n){let o=e.indexOf(t);if(o===-1)return gZ(e,t,r,n);let s=e.lastIndexOf(t);return o!==s?r:o}var yZ=(e,t)=>e===null?null:Ko(Math.round(e),0,t);function gF(e){let t=this.getLabels();return e>=0&&e<t.length?t[e]:e}var nm=class extends ra{constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){let r=this._addedLabels;if(r.length){let n=this.getLabels();for(let{index:o,label:s}of r)n[o]===s&&n.splice(o,1);this._addedLabels=[]}super.init(t)}parse(t,r){if(ze(t))return null;let n=this.getLabels();return r=isFinite(r)&&n[r]===t?r:xZ(n,t,Je(r,t),this._addedLabels),yZ(r,n.length-1)}determineDataLimits(){let{minDefined:t,maxDefined:r}=this.getUserBounds(),{min:n,max:o}=this.getMinMax(!0);this.options.bounds==="ticks"&&(t||(n=0),r||(o=this.getLabels().length-1)),this.min=n,this.max=o}buildTicks(){let t=this.min,r=this.max,n=this.options.offset,o=[],s=this.getLabels();s=t===0&&r===s.length-1?s:s.slice(t,r+1),this._valueRange=Math.max(s.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let i=t;i<=r;i++)o.push({value:i});return o}getLabelForValue(t){return gF.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return typeof t!="number"&&(t=this.parse(t)),t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){let r=this.ticks;return t<0||t>r.length-1?null:this.getPixelForValue(r[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}};Ne(nm,"id","category"),Ne(nm,"defaults",{ticks:{callback:gF}});function bZ(e,t){let r=[],{bounds:o,step:s,min:i,max:a,precision:l,count:u,maxTicks:c,maxDigits:p,includeBounds:f}=e,m=s||1,d=c-1,{min:h,max:x}=t,g=!ze(i),y=!ze(a),b=!ze(u),v=(x-h)/(p+1),C=uv((x-h)/d/m)*m,S,k,I,D;if(C<1e-14&&!g&&!y)return[{value:h},{value:x}];D=Math.ceil(x/C)-Math.floor(h/C),D>d&&(C=uv(D*C/d/m)*m),ze(l)||(S=Math.pow(10,l),C=Math.ceil(C*S)/S),o==="ticks"?(k=Math.floor(h/C)*C,I=Math.ceil(x/C)*C):(k=h,I=x),g&&y&&s&&LN((a-i)/s,C/1e3)?(D=Math.round(Math.min((a-i)/C,c)),C=(a-i)/D,k=i,I=a):b?(k=g?i:k,I=y?a:I,D=u-1,C=(I-k)/D):(D=(I-k)/C,Qf(D,Math.round(D),C/1e3)?D=Math.round(D):D=Math.ceil(D));let R=Math.max(pv(C),pv(k));S=Math.pow(10,ze(l)?R:l),k=Math.round(k*S)/S,I=Math.round(I*S)/S;let M=0;for(g&&(f&&k!==i?(r.push({value:i}),k<i&&M++,Qf(Math.round((k+M*C)*S)/S,i,xF(i,v,e))&&M++):k<i&&M++);M<D;++M)r.push({value:Math.round((k+M*C)*S)/S});return y&&f&&I!==a?r.length&&Qf(r[r.length-1].value,a,xF(a,v,e))?r[r.length-1].value=a:r.push({value:a}):(!y||I===a)&&r.push({value:I}),r}function xF(e,t,{horizontal:r,minRotation:n}){let o=pi(n),s=(r?Math.sin(o):Math.cos(o))||.001,i=.75*t*(""+e).length;return Math.min(t/s,i)}var im=class extends ra{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,r){return ze(t)||(typeof t=="number"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){let{beginAtZero:t}=this.options,{minDefined:r,maxDefined:n}=this.getUserBounds(),{min:o,max:s}=this,i=l=>o=r?o:l,a=l=>s=n?s:l;if(t){let l=Yf(o),u=Yf(s);l<0&&u<0?a(0):l>0&&u>0&&i(0)}if(o===s){let l=s===0?1:Math.abs(s*.05);a(s+l),t||i(o-l)}this.min=o,this.max=s}getTickLimit(){let t=this.options.ticks,{maxTicksLimit:r,stepSize:n}=t,o;return n?(o=Math.ceil(this.max/n)-Math.floor(this.min/n)+1,o>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${o} ticks. Limiting to 1000.`),o=1e3)):(o=this.computeTickLimit(),r=r||11),r&&(o=Math.min(r,o)),o}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){let t=this.options,r=t.ticks,n=this.getTickLimit();n=Math.max(2,n);let o={maxTicks:n,bounds:t.bounds,min:t.min,max:t.max,precision:r.precision,step:r.stepSize,count:r.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:r.minRotation||0,includeBounds:r.includeBounds!==!1},s=this._range||this,i=bZ(o,s);return t.bounds==="ticks"&&cv(i,this,"value"),t.reverse?(i.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),i}configure(){let t=this.ticks,r=this.min,n=this.max;if(super.configure(),this.options.offset&&t.length){let o=(n-r)/Math.max(t.length-1,1)/2;r-=o,n+=o}this._startValue=r,this._endValue=n,this._valueRange=n-r}getLabelForValue(t){return Ig(t,this.chart.options.locale,this.options.ticks.format)}},om=class extends im{determineDataLimits(){let{min:t,max:r}=this.getMinMax(!0);this.min=Nr(t)?t:0,this.max=Nr(r)?r:1,this.handleTickRangeOptions()}computeTickLimit(){let t=this.isHorizontal(),r=t?this.width:this.height,n=pi(this.options.ticks.minRotation),o=(t?Math.sin(n):Math.cos(n))||.001,s=this._resolveTickFontOptions(0);return Math.ceil(r/Math.min(40,s.lineHeight/o))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}};Ne(om,"id","linear"),Ne(om,"defaults",{ticks:{callback:Eg.formatters.numeric}});var Wg=e=>Math.floor(ci(e)),Xc=(e,t)=>Math.pow(10,Wg(e)+t);function yF(e){return e/Math.pow(10,Wg(e))===1}function bF(e,t,r){let n=Math.pow(10,r),o=Math.floor(e/n);return Math.ceil(t/n)-o}function vZ(e,t){let r=t-e,n=Wg(r);for(;bF(e,t,n)>10;)n++;for(;bF(e,t,n)<10;)n--;return Math.min(n,Wg(e))}function wZ(e,{min:t,max:r}){t=zn(e.min,t);let n=[],o=Wg(t),s=vZ(t,r),i=s<0?Math.pow(10,Math.abs(s)):1,a=Math.pow(10,s),l=o>s?Math.pow(10,o):0,u=Math.round((t-l)*i)/i,c=Math.floor((t-l)/a/10)*a*10,p=Math.floor((u-c)/Math.pow(10,s)),f=zn(e.min,Math.round((l+c+p*Math.pow(10,s))*i)/i);for(;f<r;)n.push({value:f,major:yF(f),significand:p}),p>=10?p=p<15?15:20:p++,p>=20&&(s++,p=2,i=s>=0?1:i),f=Math.round((l+c+p*Math.pow(10,s))*i)/i;let m=zn(e.max,f);return n.push({value:m,major:yF(m),significand:p}),n}var Fv=class extends ra{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,r){let n=im.prototype.parse.apply(this,[t,r]);if(n===0){this._zero=!0;return}return Nr(n)&&n>0?n:null}determineDataLimits(){let{min:t,max:r}=this.getMinMax(!0);this.min=Nr(t)?Math.max(0,t):null,this.max=Nr(r)?Math.max(0,r):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Nr(this._userMin)&&(this.min=t===Xc(this.min,0)?Xc(this.min,-1):Xc(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){let{minDefined:t,maxDefined:r}=this.getUserBounds(),n=this.min,o=this.max,s=a=>n=t?n:a,i=a=>o=r?o:a;n===o&&(n<=0?(s(1),i(10)):(s(Xc(n,-1)),i(Xc(o,1)))),n<=0&&s(Xc(o,-1)),o<=0&&i(Xc(n,1)),this.min=n,this.max=o}buildTicks(){let t=this.options,r={min:this._userMin,max:this._userMax},n=wZ(r,this);return t.bounds==="ticks"&&cv(n,this,"value"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}getLabelForValue(t){return t===void 0?"0":Ig(t,this.chart.options.locale,this.options.ticks.format)}configure(){let t=this.min;super.configure(),this._startValue=ci(t),this._valueRange=ci(this.max)-ci(t)}getPixelForValue(t){return(t===void 0||t===0)&&(t=this.min),t===null||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(ci(t)-this._startValue)/this._valueRange)}getValueForPixel(t){let r=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+r*this._valueRange)}};Ne(Fv,"id","logarithmic"),Ne(Fv,"defaults",{ticks:{callback:Eg.formatters.logarithmic,major:{enabled:!0}}});function wI(e){let t=e.ticks;if(t.display&&e.display){let r=to(t.backdropPadding);return Je(t.font&&t.font.size,vr.font.size)+r.height}return 0}function CZ(e,t,r){return r=tr(r)?r:[r],{w:ZN(e,t.string,r),h:r.length*t.lineHeight}}function vF(e,t,r,n,o){return e===n||e===o?{start:t-r/2,end:t+r/2}:e<n||e>o?{start:t-r,end:t}:{start:t,end:t+r}}function SZ(e){let t={l:e.left+e._padding.left,r:e.right-e._padding.right,t:e.top+e._padding.top,b:e.bottom-e._padding.bottom},r=Object.assign({},t),n=[],o=[],s=e._pointLabels.length,i=e.options.pointLabels,a=i.centerPointLabels?Xr/s:0;for(let l=0;l<s;l++){let u=i.setContext(e.getPointLabelContext(l));o[l]=u.padding;let c=e.getPointPosition(l,e.drawingArea+o[l],a),p=Bn(u.font),f=CZ(e.ctx,p,e._pointLabels[l]);n[l]=f;let m=jo(e.getIndexAngle(l)+a),d=Math.round(Sg(m)),h=vF(d,c.x,f.w,0,180),x=vF(d,c.y,f.h,90,270);kZ(r,t,m,h,x)}e.setCenterPoint(t.l-r.l,r.r-t.r,t.t-r.t,r.b-t.b),e._pointLabelItems=TZ(e,n,o)}function kZ(e,t,r,n,o){let s=Math.abs(Math.sin(r)),i=Math.abs(Math.cos(r)),a=0,l=0;n.start<t.l?(a=(t.l-n.start)/s,e.l=Math.min(e.l,t.l-a)):n.end>t.r&&(a=(n.end-t.r)/s,e.r=Math.max(e.r,t.r+a)),o.start<t.t?(l=(t.t-o.start)/i,e.t=Math.min(e.t,t.t-l)):o.end>t.b&&(l=(o.end-t.b)/i,e.b=Math.max(e.b,t.b+l))}function TZ(e,t,r){let n=[],o=e._pointLabels.length,s=e.options,i=wI(s)/2,a=e.drawingArea,l=s.pointLabels.centerPointLabels?Xr/o:0;for(let u=0;u<o;u++){let c=e.getPointPosition(u,a+i+r[u],l),p=Math.round(Sg(jo(c.angle+Cn))),f=t[u],m=EZ(c.y,f.h,p),d=NZ(p),h=IZ(c.x,f.w,d);n.push({x:c.x,y:m,textAlign:d,left:h,top:m,right:h+f.w,bottom:m+f.h})}return n}function NZ(e){return e===0||e===180?"center":e<180?"left":"right"}function IZ(e,t,r){return r==="right"?e-=t:r==="center"&&(e-=t/2),e}function EZ(e,t,r){return r===90||r===270?e-=t/2:(r>270||r<90)&&(e-=t),e}function _Z(e,t){let{ctx:r,options:{pointLabels:n}}=e;for(let o=t-1;o>=0;o--){let s=n.setContext(e.getPointLabelContext(o)),i=Bn(s.font),{x:a,y:l,textAlign:u,left:c,top:p,right:f,bottom:m}=e._pointLabelItems[o],{backdropColor:d}=s;if(!ze(d)){let h=Yi(s.borderRadius),x=to(s.backdropPadding);r.fillStyle=d;let g=c-x.left,y=p-x.top,b=f-c+x.width,v=m-p+x.height;Object.values(h).some(C=>C!==0)?(r.beginPath(),Xi(r,{x:g,y,w:b,h:v,radius:h}),r.fill()):r.fillRect(g,y,b,v)}Jf(r,e._pointLabels[o],a,l+i.lineHeight/2,i,{color:s.color,textAlign:u,textBaseline:"middle"})}}function PF(e,t,r,n){let{ctx:o}=e;if(r)o.arc(e.xCenter,e.yCenter,t,0,To);else{let s=e.getPointPosition(0,t);o.moveTo(s.x,s.y);for(let i=1;i<n;i++)s=e.getPointPosition(i,t),o.lineTo(s.x,s.y)}}function AZ(e,t,r,n,o){let s=e.ctx,i=t.circular,{color:a,lineWidth:l}=t;!i&&!n||!a||!l||r<0||(s.save(),s.strokeStyle=a,s.lineWidth=l,s.setLineDash(o.dash),s.lineDashOffset=o.dashOffset,s.beginPath(),PF(e,r,i,n),s.closePath(),s.stroke(),s.restore())}function DZ(e,t,r){return Qi(e,{label:r,index:t,type:"pointLabel"})}var em=class extends im{constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){let t=this._padding=to(wI(this.options)/2),r=this.width=this.maxWidth-t.width,n=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+r/2+t.left),this.yCenter=Math.floor(this.top+n/2+t.top),this.drawingArea=Math.floor(Math.min(r,n)/2)}determineDataLimits(){let{min:t,max:r}=this.getMinMax(!1);this.min=Nr(t)&&!isNaN(t)?t:0,this.max=Nr(r)&&!isNaN(r)?r:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/wI(this.options))}generateTickLabels(t){im.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((r,n)=>{let o=er(this.options.pointLabels.callback,[r,n],this);return o||o===0?o:""}).filter((r,n)=>this.chart.getDataVisibility(n))}fit(){let t=this.options;t.display&&t.pointLabels.display?SZ(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,r,n,o){this.xCenter+=Math.floor((t-r)/2),this.yCenter+=Math.floor((n-o)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,r,n,o))}getIndexAngle(t){let r=To/(this._pointLabels.length||1),n=this.options.startAngle||0;return jo(t*r+pi(n))}getDistanceFromCenterForValue(t){if(ze(t))return NaN;let r=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*r:(t-this.min)*r}getValueForDistanceFromCenter(t){if(ze(t))return NaN;let r=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-r:this.min+r}getPointLabelContext(t){let r=this._pointLabels||[];if(t>=0&&t<r.length){let n=r[t];return DZ(this.getContext(),t,n)}}getPointPosition(t,r,n=0){let o=this.getIndexAngle(t)-Cn+n;return{x:Math.cos(o)*r+this.xCenter,y:Math.sin(o)*r+this.yCenter,angle:o}}getPointPositionForValue(t,r){return this.getPointPosition(t,this.getDistanceFromCenterForValue(r))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){let{left:r,top:n,right:o,bottom:s}=this._pointLabelItems[t];return{left:r,top:n,right:o,bottom:s}}drawBackground(){let{backgroundColor:t,grid:{circular:r}}=this.options;if(t){let n=this.ctx;n.save(),n.beginPath(),PF(this,this.getDistanceFromCenterForValue(this._endValue),r,this._pointLabels.length),n.closePath(),n.fillStyle=t,n.fill(),n.restore()}}drawGrid(){let t=this.ctx,r=this.options,{angleLines:n,grid:o,border:s}=r,i=this._pointLabels.length,a,l,u;if(r.pointLabels.display&&_Z(this,i),o.display&&this.ticks.forEach((c,p)=>{if(p!==0){l=this.getDistanceFromCenterForValue(c.value);let f=this.getContext(p),m=o.setContext(f),d=s.setContext(f);AZ(this,m,l,i,d)}}),n.display){for(t.save(),a=i-1;a>=0;a--){let c=n.setContext(this.getPointLabelContext(a)),{color:p,lineWidth:f}=c;!f||!p||(t.lineWidth=f,t.strokeStyle=p,t.setLineDash(c.borderDash),t.lineDashOffset=c.borderDashOffset,l=this.getDistanceFromCenterForValue(r.ticks.reverse?this.min:this.max),u=this.getPointPosition(a,l),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(u.x,u.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){let t=this.ctx,r=this.options,n=r.ticks;if(!n.display)return;let o=this.getIndexAngle(0),s,i;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(o),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!r.reverse)return;let u=n.setContext(this.getContext(l)),c=Bn(u.font);if(s=this.getDistanceFromCenterForValue(this.ticks[l].value),u.showLabelBackdrop){t.font=c.string,i=t.measureText(a.label).width,t.fillStyle=u.backdropColor;let p=to(u.backdropPadding);t.fillRect(-i/2-p.left,-s-c.size/2-p.top,i+p.width,c.size+p.height)}Jf(t,a.label,0,-s,c,{color:u.color})}),t.restore()}drawTitle(){}};Ne(em,"id","radialLinear"),Ne(em,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Eg.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(t){return t},padding:5,centerPointLabels:!1}}),Ne(em,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),Ne(em,"descriptors",{angleLines:{_fallback:"grid"}});var Hv={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},ro=Object.keys(Hv);function RZ(e,t){return e-t}function wF(e,t){if(ze(t))return null;let r=e._adapter,{parser:n,round:o,isoWeekday:s}=e._parseOpts,i=t;return typeof n=="function"&&(i=n(i)),Nr(i)||(i=typeof n=="string"?r.parse(i,n):r.parse(i)),i===null?null:(o&&(i=o==="week"&&(Zf(s)||s===!0)?r.startOf(i,"isoWeek",s):r.startOf(i,o)),+i)}function CF(e,t,r,n){let o=ro.length;for(let s=ro.indexOf(e);s<o-1;++s){let i=Hv[ro[s]],a=i.steps?i.steps:Number.MAX_SAFE_INTEGER;if(i.common&&Math.ceil((r-t)/(a*i.size))<=n)return ro[s]}return ro[o-1]}function $Z(e,t,r,n,o){for(let s=ro.length-1;s>=ro.indexOf(r);s--){let i=ro[s];if(Hv[i].common&&e._adapter.diff(o,n,i)>=t-1)return i}return ro[r?ro.indexOf(r):0]}function OZ(e){for(let t=ro.indexOf(e)+1,r=ro.length;t<r;++t)if(Hv[ro[t]].common)return ro[t]}function SF(e,t,r){if(!r)e[t]=!0;else if(r.length){let{lo:n,hi:o}=kg(r,t),s=r[n]>=t?r[n]:r[o];e[s]=!0}}function FZ(e,t,r,n){let o=e._adapter,s=+o.startOf(t[0].value,n),i=t[t.length-1].value,a,l;for(a=s;a<=i;a=+o.add(a,1,n))l=r[a],l>=0&&(t[l].major=!0);return t}function kF(e,t,r){let n=[],o={},s=t.length,i,a;for(i=0;i<s;++i)a=t[i],o[a]=i,n.push({value:a,major:!1});return s===0||!r?n:FZ(e,n,o,r)}var sm=class extends ra{constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,r={}){let n=t.time||(t.time={}),o=this._adapter=new sQ._date(t.adapters.date);o.init(r),jc(n.displayFormats,o.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(t),this._normalized=r.normalized}parse(t,r){return t===void 0?null:wF(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){let t=this.options,r=this._adapter,n=t.time.unit||"day",{min:o,max:s,minDefined:i,maxDefined:a}=this.getUserBounds();function l(u){!i&&!isNaN(u.min)&&(o=Math.min(o,u.min)),!a&&!isNaN(u.max)&&(s=Math.max(s,u.max))}(!i||!a)&&(l(this._getLabelBounds()),(t.bounds!=="ticks"||t.ticks.source!=="labels")&&l(this.getMinMax(!1))),o=Nr(o)&&!isNaN(o)?o:+r.startOf(Date.now(),n),s=Nr(s)&&!isNaN(s)?s:+r.endOf(Date.now(),n)+1,this.min=Math.min(o,s-1),this.max=Math.max(o+1,s)}_getLabelBounds(){let t=this.getLabelTimestamps(),r=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return t.length&&(r=t[0],n=t[t.length-1]),{min:r,max:n}}buildTicks(){let t=this.options,r=t.time,n=t.ticks,o=n.source==="labels"?this.getLabelTimestamps():this._generate();t.bounds==="ticks"&&o.length&&(this.min=this._userMin||o[0],this.max=this._userMax||o[o.length-1]);let s=this.min,i=this.max,a=GN(o,s,i);return this._unit=r.unit||(n.autoSkip?CF(r.minUnit,this.min,this.max,this._getLabelCapacity(s)):$Z(this,a.length,r.minUnit,this.min,this.max)),this._majorUnit=!n.major.enabled||this._unit==="year"?void 0:OZ(this._unit),this.initOffsets(o),t.reverse&&a.reverse(),kF(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(t=>+t.value))}initOffsets(t=[]){let r=0,n=0,o,s;this.options.offset&&t.length&&(o=this.getDecimalForValue(t[0]),t.length===1?r=1-o:r=(this.getDecimalForValue(t[1])-o)/2,s=this.getDecimalForValue(t[t.length-1]),t.length===1?n=s:n=(s-this.getDecimalForValue(t[t.length-2]))/2);let i=t.length<3?.5:.25;r=Ko(r,0,i),n=Ko(n,0,i),this._offsets={start:r,end:n,factor:1/(r+1+n)}}_generate(){let t=this._adapter,r=this.min,n=this.max,o=this.options,s=o.time,i=s.unit||CF(s.minUnit,r,n,this._getLabelCapacity(r)),a=Je(o.ticks.stepSize,1),l=i==="week"?s.isoWeekday:!1,u=Zf(l)||l===!0,c={},p=r,f,m;if(u&&(p=+t.startOf(p,"isoWeek",l)),p=+t.startOf(p,u?"day":i),t.diff(n,r,i)>1e5*a)throw new Error(r+" and "+n+" are too far apart with stepSize of "+a+" "+i);let d=o.ticks.source==="data"&&this.getDataTimestamps();for(f=p,m=0;f<n;f=+t.add(f,a,i),m++)SF(c,f,d);return(f===n||o.bounds==="ticks"||m===1)&&SF(c,f,d),Object.keys(c).sort((h,x)=>h-x).map(h=>+h)}getLabelForValue(t){let r=this._adapter,n=this.options.time;return n.tooltipFormat?r.format(t,n.tooltipFormat):r.format(t,n.displayFormats.datetime)}_tickFormatFunction(t,r,n,o){let s=this.options,i=s.ticks.callback;if(i)return er(i,[t,r,n],this);let a=s.time.displayFormats,l=this._unit,u=this._majorUnit,c=l&&a[l],p=u&&a[u],f=n[r],m=u&&p&&f&&f.major;return this._adapter.format(t,o||(m?p:c))}generateTickLabels(t){let r,n,o;for(r=0,n=t.length;r<n;++r)o=t[r],o.label=this._tickFormatFunction(o.value,r,t)}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){let r=this._offsets,n=this.getDecimalForValue(t);return this.getPixelForDecimal((r.start+n)*r.factor)}getValueForPixel(t){let r=this._offsets,n=this.getDecimalForPixel(t)/r.factor-r.end;return this.min+n*(this.max-this.min)}_getLabelSize(t){let r=this.options.ticks,n=this.ctx.measureText(t).width,o=pi(this.isHorizontal()?r.maxRotation:r.minRotation),s=Math.cos(o),i=Math.sin(o),a=this._resolveTickFontOptions(0).size;return{w:n*s+a*i,h:n*i+a*s}}_getLabelCapacity(t){let r=this.options.time,n=r.displayFormats,o=n[r.unit]||n.millisecond,s=this._tickFormatFunction(t,0,kF(this,[t],this._majorUnit),o),i=this._getLabelSize(s),a=Math.floor(this.isHorizontal()?this.width/i.w:this.height/i.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[],r,n;if(t.length)return t;let o=this.getMatchingVisibleMetas();if(this._normalized&&o.length)return this._cache.data=o[0].controller.getAllParsedValues(this);for(r=0,n=o.length;r<n;++r)t=t.concat(o[r].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){let t=this._cache.labels||[],r,n;if(t.length)return t;let o=this.getLabels();for(r=0,n=o.length;r<n;++r)t.push(wF(this,o[r]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return HN(t.sort(RZ))}};Ne(sm,"id","time"),Ne(sm,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});function Pv(e,t,r){let n=0,o=e.length-1,s,i,a,l;r?(t>=e[n].pos&&t<=e[o].pos&&({lo:n,hi:o}=Tg(e,"pos",t)),{pos:s,time:a}=e[n],{pos:i,time:l}=e[o]):(t>=e[n].time&&t<=e[o].time&&({lo:n,hi:o}=Tg(e,"time",t)),{time:s,pos:a}=e[n],{time:i,pos:l}=e[o]);let u=i-s;return u?a+(l-a)*(t-s)/u:a}var Lv=class extends sm{constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){let t=this._getTimestampsForTable(),r=this._table=this.buildLookupTable(t);this._minPos=Pv(r,this.min),this._tableRange=Pv(r,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){let{min:r,max:n}=this,o=[],s=[],i,a,l,u,c;for(i=0,a=t.length;i<a;++i)u=t[i],u>=r&&u<=n&&o.push(u);if(o.length<2)return[{time:r,pos:0},{time:n,pos:1}];for(i=0,a=o.length;i<a;++i)c=o[i+1],l=o[i-1],u=o[i],Math.round((c+l)/2)!==u&&s.push({time:u,pos:i/(a-1)});return s}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;let r=this.getDataTimestamps(),n=this.getLabelTimestamps();return r.length&&n.length?t=this.normalize(r.concat(n)):t=r.length?r:n,t=this._cache.all=t,t}getDecimalForValue(t){return(Pv(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){let r=this._offsets,n=this.getDecimalForPixel(t)/r.factor-r.end;return Pv(this._table,n*this._tableRange+this._minPos,!0)}};Ne(Lv,"id","timeseries"),Ne(Lv,"defaults",sm.defaults);var PZ="1.3.0",Zl=class extends Ql{initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){let r=this,n=r._cachedMeta;r.updateElements(n.data,0,n.data.length,t)}updateElements(t,r,n,o){let s=this,i=o==="reset",{xScale:a,yScale:l}=s._cachedMeta,u=s.resolveDataElementOptions(r,o),c=s.getSharedOptions(o,t[r],u);for(let p=r;p<r+n;p++){let f=!i&&s.getParsed(p),m=i?a.getBasePixel():a.getPixelForValue(f.x),d=i?l.getBasePixel():l.getPixelForValue(f.y),h=s.resolveDataElementOptions(p,o),{width:x,height:g,anchorX:y,anchorY:b}=h,v={x:LZ(y,m,x),y:MZ(b,d,g),width:x,height:g,options:h};s.updateElement(t[p],p,v,o)}s.updateSharedOptions(c,o)}draw(){let t=this,r=t.getMeta().data||[],n,o;for(n=0,o=r.length;n<o;++n)r[n].draw(t._ctx)}};function LZ(e,t,r){return e==="left"||e==="start"?t:e==="right"||e==="end"?t-r:t-r/2}function MZ(e,t,r){return e==="top"||e==="start"?t:e==="bottom"||e==="end"?t-r:t-r/2}Zl.id="matrix";Zl.version=PZ;Zl.defaults={dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}};Zl.overrides={interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}};function LF(e,t){let{x:r,y:n,width:o,height:s}=e.getProps(["x","y","width","height"],t);return{left:r,top:n,right:r+o,bottom:n+s}}function qv(e,t,r){return Math.max(Math.min(e,r),t)}function zZ(e,t,r){let n=e.options.borderWidth,o,s,i,a;return se(n)?(o=+n.top||0,s=+n.right||0,i=+n.bottom||0,a=+n.left||0):o=s=i=a=+n||0,{t:qv(o,0,r),r:qv(s,0,t),b:qv(i,0,r),l:qv(a,0,t)}}function BZ(e){let t=LF(e),r=t.right-t.left,n=t.bottom-t.top,o=zZ(e,r/2,n/2);return{outer:{x:t.left,y:t.top,w:r,h:n},inner:{x:t.left+o.l,y:t.top+o.t,w:r-o.l-o.r,h:n-o.t-o.b}}}function CI(e,t,r,n){let o=t===null,s=r===null,i=!e||o&&s?!1:LF(e,n);return i&&(o||t>=i.left&&t<=i.right)&&(s||r>=i.top&&r<=i.bottom)}var am=class extends ea{constructor(t){super(),this.options=void 0,this.width=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){let r=this.options,{inner:n,outer:o}=BZ(this),s=Yi(r.borderRadius);t.save(),o.w!==n.w||o.h!==n.h?(t.beginPath(),Xi(t,{x:o.x,y:o.y,w:o.w,h:o.h,radius:s}),Xi(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:s}),t.fillStyle=r.backgroundColor,t.fill(),t.fillStyle=r.borderColor,t.fill("evenodd")):(t.beginPath(),Xi(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:s}),t.fillStyle=r.backgroundColor,t.fill()),t.restore()}inRange(t,r,n){return CI(this,t,r,n)}inXRange(t,r){return CI(this,t,null,r)}inYRange(t,r){return CI(this,null,t,r)}getCenterPoint(t){let{x:r,y:n,width:o,height:s}=this.getProps(["x","y","width","height"],t);return{x:r+o/2,y:n+s/2}}tooltipPosition(){return this.getCenterPoint()}getRange(t){return t==="x"?this.width/2:this.height/2}};am.id="matrix";am.defaults={backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20};var no=Yt(oe(),1);var zF="label";function MF(e,t){typeof e=="function"?e(t):e&&(e.current=t)}function VZ(e,t){let r=e.options;r&&t&&Object.assign(r,t)}function BF(e,t){e.labels=t}function VF(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:zF,n=[];e.datasets=t.map(o=>{let s=e.datasets.find(i=>i[r]===o[r]);return!s||!o.data||n.includes(s)?ae({},o):(n.push(s),Object.assign(s,o),s)})}function WZ(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:zF,r={labels:[],datasets:[]};return BF(r,e.labels),VF(r,e.datasets,t),r}function GZ(e,t){let g=e,{height:r=150,width:n=300,redraw:o=!1,datasetIdKey:s,type:i,data:a,options:l,plugins:u=[],fallbackContent:c,updateMode:p}=g,f=Vl(g,["height","width","redraw","datasetIdKey","type","data","options","plugins","fallbackContent","updateMode"]),m=(0,no.useRef)(null),d=(0,no.useRef)(),h=()=>{!m.current||(d.current=new Uv(m.current,{type:i,data:WZ(a,s),options:l&&ae({},l),plugins:u}),MF(t,d.current))},x=()=>{MF(t,null),d.current&&(d.current.destroy(),d.current=null)};return(0,no.useEffect)(()=>{!o&&d.current&&l&&VZ(d.current,l)},[o,l]),(0,no.useEffect)(()=>{!o&&d.current&&BF(d.current.config.data,a.labels)},[o,a.labels]),(0,no.useEffect)(()=>{!o&&d.current&&a.datasets&&VF(d.current.config.data,a.datasets,s)},[o,a.datasets]),(0,no.useEffect)(()=>{!d.current||(o?(x(),setTimeout(h)):d.current.update(p))},[o,l,a.labels,a.datasets,p]),(0,no.useEffect)(()=>{!d.current||(x(),setTimeout(h))},[i]),(0,no.useEffect)(()=>(h(),()=>x()),[]),no.default.createElement("canvas",Object.assign({ref:m,role:"img",height:r,width:n},f),c)}var WF=(0,no.forwardRef)(GZ);var Qv=Yt(Uc());var UZ={grad:.9,turn:360,rad:360/(2*Math.PI)},na=function(e){return typeof e=="string"?e.length>0:typeof e=="number"},Yr=function(e,t,r){return t===void 0&&(t=0),r===void 0&&(r=Math.pow(10,t)),Math.round(r*e)/r+0},Xo=function(e,t,r){return t===void 0&&(t=0),r===void 0&&(r=1),e>r?r:e>t?e:t},YF=function(e){return(e=isFinite(e)?e%360:0)>0?e:e+360},GF=function(e){return{r:Xo(e.r,0,255),g:Xo(e.g,0,255),b:Xo(e.b,0,255),a:Xo(e.a)}},SI=function(e){return{r:Yr(e.r),g:Yr(e.g),b:Yr(e.b),a:Yr(e.a,3)}},HZ=/^#([0-9a-f]{3,8})$/i,jv=function(e){var t=e.toString(16);return t.length<2?"0"+t:t},QF=function(e){var t=e.r,r=e.g,n=e.b,o=e.a,s=Math.max(t,r,n),i=s-Math.min(t,r,n),a=i?s===t?(r-n)/i:s===r?2+(n-t)/i:4+(t-r)/i:0;return{h:60*(a<0?a+6:a),s:s?i/s*100:0,v:s/255*100,a:o}},ZF=function(e){var t=e.h,r=e.s,n=e.v,o=e.a;t=t/360*6,r/=100,n/=100;var s=Math.floor(t),i=n*(1-r),a=n*(1-(t-s)*r),l=n*(1-(1-t+s)*r),u=s%6;return{r:255*[n,a,i,i,l,n][u],g:255*[l,n,n,a,i,i][u],b:255*[i,i,l,n,n,a][u],a:o}},UF=function(e){return{h:YF(e.h),s:Xo(e.s,0,100),l:Xo(e.l,0,100),a:Xo(e.a)}},HF=function(e){return{h:Yr(e.h),s:Yr(e.s),l:Yr(e.l),a:Yr(e.a,3)}},qF=function(e){return ZF((r=(t=e).s,{h:t.h,s:(r*=((n=t.l)<50?n:100-n)/100)>0?2*r/(n+r)*100:0,v:n+r,a:t.a}));var t,r,n},Ug=function(e){return{h:(t=QF(e)).h,s:(o=(200-(r=t.s))*(n=t.v)/100)>0&&o<200?r*n/100/(o<=100?o:200-o)*100:0,l:o/2,a:t.a};var t,r,n,o},qZ=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,jZ=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,KZ=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,XZ=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,NI={string:[[function(e){var t=HZ.exec(e);return t?(e=t[1]).length<=4?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:e.length===4?Yr(parseInt(e[3]+e[3],16)/255,2):1}:e.length===6||e.length===8?{r:parseInt(e.substr(0,2),16),g:parseInt(e.substr(2,2),16),b:parseInt(e.substr(4,2),16),a:e.length===8?Yr(parseInt(e.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(e){var t=KZ.exec(e)||XZ.exec(e);return t?t[2]!==t[4]||t[4]!==t[6]?null:GF({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:t[7]===void 0?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(e){var t=qZ.exec(e)||jZ.exec(e);if(!t)return null;var r,n,o=UF({h:(r=t[1],n=t[2],n===void 0&&(n="deg"),Number(r)*(UZ[n]||1)),s:Number(t[3]),l:Number(t[4]),a:t[5]===void 0?1:Number(t[5])/(t[6]?100:1)});return qF(o)},"hsl"]],object:[[function(e){var t=e.r,r=e.g,n=e.b,o=e.a,s=o===void 0?1:o;return na(t)&&na(r)&&na(n)?GF({r:Number(t),g:Number(r),b:Number(n),a:Number(s)}):null},"rgb"],[function(e){var t=e.h,r=e.s,n=e.l,o=e.a,s=o===void 0?1:o;if(!na(t)||!na(r)||!na(n))return null;var i=UF({h:Number(t),s:Number(r),l:Number(n),a:Number(s)});return qF(i)},"hsl"],[function(e){var t=e.h,r=e.s,n=e.v,o=e.a,s=o===void 0?1:o;if(!na(t)||!na(r)||!na(n))return null;var i=function(a){return{h:YF(a.h),s:Xo(a.s,0,100),v:Xo(a.v,0,100),a:Xo(a.a)}}({h:Number(t),s:Number(r),v:Number(n),a:Number(s)});return ZF(i)},"hsv"]]},jF=function(e,t){for(var r=0;r<t.length;r++){var n=t[r][0](e);if(n)return[n,t[r][1]]}return[null,void 0]},YZ=function(e){return typeof e=="string"?jF(e.trim(),NI.string):typeof e=="object"&&e!==null?jF(e,NI.object):[null,void 0]};var kI=function(e,t){var r=Ug(e);return{h:r.h,s:Xo(r.s+100*t,0,100),l:r.l,a:r.a}},TI=function(e){return(299*e.r+587*e.g+114*e.b)/1e3/255},KF=function(e,t){var r=Ug(e);return{h:r.h,s:r.s,l:Xo(r.l+100*t,0,100),a:r.a}},II=function(){function e(t){this.parsed=YZ(t)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return e.prototype.isValid=function(){return this.parsed!==null},e.prototype.brightness=function(){return Yr(TI(this.rgba),2)},e.prototype.isDark=function(){return TI(this.rgba)<.5},e.prototype.isLight=function(){return TI(this.rgba)>=.5},e.prototype.toHex=function(){return t=SI(this.rgba),r=t.r,n=t.g,o=t.b,i=(s=t.a)<1?jv(Yr(255*s)):"","#"+jv(r)+jv(n)+jv(o)+i;var t,r,n,o,s,i},e.prototype.toRgb=function(){return SI(this.rgba)},e.prototype.toRgbString=function(){return t=SI(this.rgba),r=t.r,n=t.g,o=t.b,(s=t.a)<1?"rgba("+r+", "+n+", "+o+", "+s+")":"rgb("+r+", "+n+", "+o+")";var t,r,n,o,s},e.prototype.toHsl=function(){return HF(Ug(this.rgba))},e.prototype.toHslString=function(){return t=HF(Ug(this.rgba)),r=t.h,n=t.s,o=t.l,(s=t.a)<1?"hsla("+r+", "+n+"%, "+o+"%, "+s+")":"hsl("+r+", "+n+"%, "+o+"%)";var t,r,n,o,s},e.prototype.toHsv=function(){return t=QF(this.rgba),{h:Yr(t.h),s:Yr(t.s),v:Yr(t.v),a:Yr(t.a,3)};var t},e.prototype.invert=function(){return He({r:255-(t=this.rgba).r,g:255-t.g,b:255-t.b,a:t.a});var t},e.prototype.saturate=function(t){return t===void 0&&(t=.1),He(kI(this.rgba,t))},e.prototype.desaturate=function(t){return t===void 0&&(t=.1),He(kI(this.rgba,-t))},e.prototype.grayscale=function(){return He(kI(this.rgba,-1))},e.prototype.lighten=function(t){return t===void 0&&(t=.1),He(KF(this.rgba,t))},e.prototype.darken=function(t){return t===void 0&&(t=.1),He(KF(this.rgba,-t))},e.prototype.rotate=function(t){return t===void 0&&(t=15),this.hue(this.hue()+t)},e.prototype.alpha=function(t){return typeof t=="number"?He({r:(r=this.rgba).r,g:r.g,b:r.b,a:t}):Yr(this.rgba.a,3);var r},e.prototype.hue=function(t){var r=Ug(this.rgba);return typeof t=="number"?He({h:t,s:r.s,l:r.l,a:r.a}):Yr(r.h)},e.prototype.isEqual=function(t){return this.toHex()===He(t).toHex()},e}(),He=function(e){return e instanceof II?e:new II(e)},XF=[],Kv=function(e){e.forEach(function(t){XF.indexOf(t)<0&&(t(II,NI),XF.push(t))})};var hi=function(e,t,r){return t===void 0&&(t=0),r===void 0&&(r=1),e>r?r:e>t?e:t},EI=function(e){var t=e/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},_I=function(e){return 255*(e>.0031308?1.055*Math.pow(e,.4166666666666667)-.055:12.92*e)},AI=96.422,DI=100,RI=82.521,QZ=function(e){var t,r,n={x:.9555766*(t=e).x+-.0230393*t.y+.0631636*t.z,y:-.0282895*t.x+1.0099416*t.y+.0210077*t.z,z:.0122982*t.x+-.020483*t.y+1.3299098*t.z};return r={r:_I(.032404542*n.x-.015371385*n.y-.004985314*n.z),g:_I(-.00969266*n.x+.018760108*n.y+41556e-8*n.z),b:_I(556434e-9*n.x-.002040259*n.y+.010572252*n.z),a:e.a},{r:hi(r.r,0,255),g:hi(r.g,0,255),b:hi(r.b,0,255),a:hi(r.a)}},ZZ=function(e){var t=EI(e.r),r=EI(e.g),n=EI(e.b);return function(o){return{x:hi(o.x,0,AI),y:hi(o.y,0,DI),z:hi(o.z,0,RI),a:hi(o.a)}}(function(o){return{x:1.0478112*o.x+.0228866*o.y+-.050127*o.z,y:.0295424*o.x+.9904844*o.y+-.0170491*o.z,z:-.0092345*o.x+.0150436*o.y+.7521316*o.z,a:o.a}}({x:100*(.4124564*t+.3575761*r+.1804375*n),y:100*(.2126729*t+.7151522*r+.072175*n),z:100*(.0193339*t+.119192*r+.9503041*n),a:e.a}))},Hg=216/24389,lm=24389/27,JF=function(e){var t=ZZ(e),r=t.x/AI,n=t.y/DI,o=t.z/RI;return r=r>Hg?Math.cbrt(r):(lm*r+16)/116,{l:116*(n=n>Hg?Math.cbrt(n):(lm*n+16)/116)-16,a:500*(r-n),b:200*(n-(o=o>Hg?Math.cbrt(o):(lm*o+16)/116)),alpha:t.a}},JZ=function(e,t,r){var n,o=JF(e),s=JF(t);return function(i){var a=(i.l+16)/116,l=i.a/500+a,u=a-i.b/200;return QZ({x:(Math.pow(l,3)>Hg?Math.pow(l,3):(116*l-16)/lm)*AI,y:(i.l>8?Math.pow((i.l+16)/116,3):i.l/lm)*DI,z:(Math.pow(u,3)>Hg?Math.pow(u,3):(116*u-16)/lm)*RI,a:i.alpha})}({l:hi((n={l:o.l*(1-r)+s.l*r,a:o.a*(1-r)+s.a*r,b:o.b*(1-r)+s.b*r,alpha:o.alpha*(1-r)+s.alpha*r}).l,0,400),a:n.a,b:n.b,alpha:hi(n.alpha)})};function Xv(e){function t(r,n,o){o===void 0&&(o=5);for(var s=[],i=1/(o-1),a=0;a<=o-1;a++)s.push(r.mix(n,i*a));return s}e.prototype.mix=function(r,n){n===void 0&&(n=.5);var o=r instanceof e?r:new e(r),s=JZ(this.toRgb(),o.toRgb(),n);return new e(s)},e.prototype.tints=function(r){return t(this,"#fff",r)},e.prototype.shades=function(r){return t(this,"#000",r)},e.prototype.tones=function(r){return t(this,"#808080",r)}}function Yv(e,t){var r={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},n={};for(var o in r)n[r[o]]=o;var s={};e.prototype.toName=function(i){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var a,l,u=n[this.toHex()];if(u)return u;if(i!=null&&i.closest){var c=this.toRgb(),p=1/0,f="black";if(!s.length)for(var m in r)s[m]=new e(r[m]).toRgb();for(var d in r){var h=(a=c,l=s[d],Math.pow(a.r-l.r,2)+Math.pow(a.g-l.g,2)+Math.pow(a.b-l.b,2));h<p&&(p=h,f=d)}return f}},t.string.push([function(i){var a=i.toLowerCase(),l=a==="transparent"?"#0000":r[a];return l?new e(l).toRgb():null},"name"])}Kv([Xv,Yv]);function Jl(e,t,r,n="red",o="blue"){return e>=0?He(o).mix(He("white"),Math.min(Math.max(1-e/r,0),1)):He(n).mix(He("white"),Math.min(Math.max(1- -e/-t,0),1))}Uv.register(nm,FF,am,Zl,om);var tJ="rgb(200,200,200)";function qg({attention:e,maxValue:t=1,minValue:r=-1,negativeColor:n,positiveColor:o,upperTriColor:s=tJ,showAxisLabels:i=!0,tokens:a}){let l=(0,Yc.useMemo)(()=>a.map((f,m)=>`${f.replace(/\s/g,"")} (${m})`),[a]),c={datasets:[{data:(0,Yc.useMemo)(()=>e.map((f,m)=>f.map((d,h)=>({srcIdx:h,destIdx:m,srcToken:a[h],destToken:a[m],x:l[h],y:l[m],v:d}))).flat(),[e,a,l]),backgroundColor(f){let m=f.dataset.data[f.dataIndex];return m.srcIdx>m.destIdx?He(s).toRgbString():Jl(m.v,r,t,n,o).toRgbString()},width:f=>f.chart.chartArea.width/a.length,height:f=>f.chart.chartArea.height/a.length}]},p={animation:{duration:0},plugins:{tooltip:{enabled:i,yAlign:"bottom",callbacks:{title:()=>"",label({raw:f}){let m=f;return m.destIdx<m.srcIdx?"N/A":[`(${m.destIdx}, ${m.srcIdx})`,`Src: ${m.srcToken}`,`Dest: ${m.destToken} `,`Val: ${m.v}`]}}}},scales:{x:{title:{display:!0,text:"Source Token",padding:1},type:"category",labels:l,offset:!0,ticks:{display:!0,minRotation:45,maxRotation:90},grid:{display:!1},display:i},y:{title:{display:!0,text:"Destination Token",padding:1},type:"category",offset:!0,labels:[...l].reverse(),ticks:{display:!0},grid:{display:!1},display:i}}};return Yc.default.createElement(Qv.Col,null,Yc.default.createElement(Qv.Row,{style:{aspectRatio:i?void 0:"1/1"}},Yc.default.createElement(WF,{type:"matrix",options:p,data:c,width:1e3,height:1e3,updateMode:"none"})))}var $I=Yt(oe());function Qc(e=null){let[t,r]=(0,$I.useState)(null),[n,o]=(0,$I.useState)(e);function s(u){o(u)}function i(u){r(u)}function a(){r(null)}return{focused:t!=null?t:n,onClick:s,onMouseEnter:i,onMouseLeave:a}}function Zv(e,t,r="100%"){return`hsla(${Math.round(e/t*360)}, 70%, 50%,  ${r})`}function eJ({attention:e,attentionHeadNames:t,focused:r,maxValue:n,minValue:o,negativeColor:s,onClick:i,onMouseEnter:a,onMouseLeave:l,positiveColor:u,tokens:c}){return un.default.createElement(oa.Row,{style:{marginBottom:15}},e.map((p,f)=>{let m=r===f;return un.default.createElement(oa.Col,{lg:1,md:2,xs:3,style:{margin:0,padding:0},key:f},un.default.createElement("div",{style:{padding:3},onClick:()=>i(f),onMouseEnter:()=>a(f),onMouseLeave:l},un.default.createElement("div",{style:{position:"relative",borderStyle:"solid",borderWidth:1,borderColor:Zv(f,e.length),boxShadow:m?`0px 0px 4px 3px ${Zv(f,e.length,"60%")}`:void 0}},un.default.createElement("h4",{style:{position:"absolute",top:0,right:0,zIndex:100,margin:0,padding:1,background:Zv(f,e.length),color:"white"}},t[f]),un.default.createElement(qg,{attention:p,tokens:c,showAxisLabels:!1,maxValue:n,minValue:o,negativeColor:s,positiveColor:u}))))}))}function tP({attention:e,attentionHeadNames:t,maxValue:r,minValue:n,negativeColor:o,positiveColor:s,tokens:i}){let{focused:a,onClick:l,onMouseEnter:u,onMouseLeave:c}=Qc(0),p=t||e.map((f,m)=>`Head ${m}`);return un.default.createElement(oa.Container,null,un.default.createElement("h3",{style:{marginBottom:15}},"Head Selector (hover to view, click to lock)"),un.default.createElement(eJ,{attention:e,attentionHeadNames:p,focused:a,maxValue:r,minValue:n,negativeColor:o,onClick:l,onMouseEnter:u,onMouseLeave:c,positiveColor:s,tokens:i}),un.default.createElement(oa.Row,null,un.default.createElement(oa.Col,{xs:12},un.default.createElement("h3",{style:{marginBottom:10}},p[a]," Zoomed"),un.default.createElement("div",{style:{position:"relative",maxWidth:`${Math.max(Math.round(i.length*2.4),20)}em`}},un.default.createElement("h2",{style:{position:"absolute",top:0,right:0,zIndex:1e3,margin:6,padding:"5px 10px",background:Zv(a,e.length),color:"white"}},p[a]),un.default.createElement(qg,{attention:e[a],maxValue:r,minValue:n,negativeColor:o,positiveColor:s,tokens:i})))),un.default.createElement(oa.Row,null))}var Ye=Yt(oe());var Zc=class{constructor(t,r){this.backend=t,this.dataMover=r,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,r){this.dataIdsCount++,this.data.set(t,r)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},sa=class{refCount(t){return oo("refCount")}incRef(t){return oo("incRef")}timerAvailable(){return!0}time(t){return oo("time")}read(t){return oo("read")}readSync(t){return oo("readSync")}readToGPU(t,r){return oo("readToGPU")}numDataIds(){return oo("numDataIds")}disposeData(t,r){return oo("disposeData")}write(t,r,n){return oo("write")}move(t,r,n,o,s){return oo("move")}createTensorFromTexture(t,r,n){return oo("createTensorFromTexture")}memory(){return oo("memory")}floatPrecision(){return oo("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return oo("dispose")}};function oo(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function eP(e){let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Jv(e,t,r)}function rJ(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let r=e.length,n=0;for(;r>0;)n=Math.random()*r|0,r--,Jv(e,r,n),Jv(t,r,n)}function um(e,t,r){return Math.max(e,Math.min(t,r))}function nJ(e){return e%2===0?e:e+1}function Jv(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function oJ(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r];return t}function sJ(e,t){let r=Math.random();return t*r+(1-r)*e}function iJ(e,t){let r=0;for(let n=0;n<e.length;n++){let o=Number(e[n])-Number(t[n]);r+=o*o}return r}function A(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function tw(e,t,r=""){A(eu(e,t),()=>r+` Shapes ${e} and ${t} must match`)}function tp(e){A(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function tu(e,t=[],r=!1){if(t==null&&(t=[]),Array.isArray(e)||so(e)&&!r)for(let n=0;n<e.length;++n)tu(e[n],t,r);else t.push(e);return t}function ee(e){if(e.length===0)return 1;let t=e[0];for(let r=1;r<e.length;r++)t*=e[r];return t}function aJ(e){return e.length===0}function eu(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function ia(e){return e%1===0}function lJ(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function uJ(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function cJ(e){let t=new Uint32Array(e);for(let r=0;r<e;++r)t[r]=r;return eP(t),t}function ep(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function pJ(e,t=o=>0,r,n){return new Promise((o,s)=>{let i=0,a=()=>{if(e()){o();return}i++;let l=t(i);if(r!=null&&i>=r){s();return}n!=null?n(a,l):setTimeout(a,l)};a()})}function fJ(e,t){let r=1,n=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)r*=e[s];else if(e[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==r)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(r===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%r!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);let o=e.slice();return o[n]=t/r,o}function dr(e,t){let r=t.length;return e=e==null?t.map((n,o)=>o):[].concat(e),A(e.every(n=>n>=-r&&n<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${e}`),A(e.every(n=>ia(n)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(n=>n<0?r+n:n)}function OI(e,t){let r=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:dr(t,e).sort(),i=0;for(let a=0;a<e.length;++a){if(s!=null){if(s[i]===a&&e[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(s[i]==null||s[i]>a)&&e[a]===1&&(r.push(e[a]),n.push(a)),s[i]<=a&&i++}e[a]!==1&&(r.push(e[a]),n.push(a))}return{newShape:r,keptDims:n}}function mJ(e,t){let r=null;if(e==null||e==="float32")r=new Float32Array(t);else if(e==="int32")r=new Int32Array(t);else if(e==="bool")r=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return r}function FI(e,t){let r=null;if(e==null||e==="float32")r=new Float32Array(t);else if(e==="int32")r=new Int32Array(t);else if(e==="bool")r=new Uint8Array(t);else if(e==="string")r=new Array(t);else throw new Error(`Unknown data type ${e}`);return r}function PI(e,t){for(let r=0;r<e.length;r++){let n=e[r];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function LI(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function dJ(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function so(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function ew(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function MI(e){if(e==null)return 0;let t=0;return e.forEach(r=>t+=r.length),t}function cm(e){return typeof e=="string"||e instanceof String}function rP(e){return typeof e=="boolean"}function nP(e){return typeof e=="number"}function pm(e){return Array.isArray(e)?pm(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":nP(e)?"float32":cm(e)?"string":rP(e)?"bool":"float32"}function fm(e){return!!(e&&e.constructor&&e.call&&e.apply)}function mm(e,t){for(let r=t;r<e;++r)if(e%r===0)return r;return e}function gi(e){let t=e.length;if(t<2)return[];let r=new Array(t-1);r[t-2]=e[t-1];for(let n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}function oP(e,t,r,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=r[e+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(n?2:1);for(let l=0;l<s;l++)o[l]=oP(e+l*a,i,r,n)}return o}function Jc(e,t,r=!1){if(e.length===0)return t[0];let n=e.reduce((o,s)=>o*s)*(r?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${r?" for a complex tensor":""}.`);return oP(0,e,t,r)}function jg(e,t){let r=dm(e,t);for(let n=0;n<r.length;n++)r[n]=1;return r}function dm(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function hJ(e,t){let r=e.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Jc(e,new Float32Array(r));if(t==="int32")return Jc(e,new Int32Array(r));if(t==="bool")return Jc(e,new Uint8Array(r));throw new Error(`Unknown data type ${t}`)}function Fr(e){e.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function gJ(e,t,r){if(t===0)return 0;if(t===1)return e[0];let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=r[o]*e[o];return n}function xJ(e,t,r){if(t===0)return[];if(t===1)return[e];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(e/r[o]),e-=n[o]*r[o];return n[n.length-1]=e,n}function Kg(e){return e&&e.then&&typeof e.then=="function"}var sP="tfjsflags",Xg=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bJ,this.populateURLFlags()}setPlatform(t,r){this.platform!=null&&(B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=r}registerFlag(t,r,n){if(this.flagRegistry[t]={evaluationFn:r,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}getAsync(t){return H(this,null,function*(){return t in this.flags?this.flags[t]:(this.flags[t]=yield this.evaluateFlag(t),this.flags[t])})}get(t){if(t in this.flags)return this.flags[t];let r=this.evaluateFlag(t);if(Kg(r))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=r,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,r){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=r,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(r)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);sP in t&&t[sP].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=wJ(o,s)})}};function bJ(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(r,...n)=>(vJ(t,n[0],n[1]),n.join("="))),t}function vJ(e,t,r){e[decodeURIComponent(t)]=decodeURIComponent(r||"")}function wJ(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function B(){return zI}var zI=null;function iP(e){zI=e}var BI;function VI(){if(BI==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");BI=e}return BI}function CJ(){let e=VI();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Yg(e,t){let r=CJ();if(r.has(e))return r.get(e);{let n=t();return r.set(e,n),r.get(e)}}var ru="Abs",aa="Acos",la="Acosh",Fs="Add",hm="AddN",gm="All",xm="Any",nu="ArgMax",ou="ArgMin",ua="Asin",ca="Asinh",pa="Atan",fa="Atanh",ma="Atan2",su="AvgPool",ym="AvgPoolGrad",iu="AvgPool3D",bm="AvgPool3DGrad",au="BatchMatMul",lu="BatchToSpaceND",vm="Bincount",aP="BroadcastTo",rw="BroadcastArgs",xi="Cast",da="Ceil",ha="ClipByValue",wm="Complex",uu="ComplexAbs",cu="Concat",pu="Conv2D",Cm="Conv2DBackpropFilter",fu="Conv2DBackpropInput",mu="Conv3D",Sm="Conv3DBackpropFilterV2",km="Conv3DBackpropInputV2",ga="Cos",xa="Cosh",Tm="Cumprod",du="Cumsum",Nm="CropAndResize",Im="DenseBincount",Em="DepthToSpace",hu="DepthwiseConv2dNative",_m="DepthwiseConv2dNativeBackpropFilter",Am="DepthwiseConv2dNativeBackpropInput",nw="Diag",gu="Dilation2D",Qg="Dilation2DBackpropInput",Zg="Dilation2DBackpropFilter",ya="RealDiv",Dm="Einsum",ba="Elu",Rm="EluGrad",va="Erf",rp="Equal",wa="Exp",xu="ExpandDims",Ca="Expm1",$m="FFT",Om="Fill",Fm="FlipLeftRight",Sa="Floor",ka="FloorDiv",yu="FusedBatchNorm",bu="GatherV2",ow="GatherNd",np="Greater",Ta="GreaterEqual",yi="Identity",Pm="IFFT",Lm="Imag",Na="IsFinite",Ia="IsInf",Ea="IsNan",vu="LeakyRelu",op="Less",sp="LessEqual",sw="LinSpace",_a="Log",Aa="Log1p",ip="LogicalAnd",ap="LogicalNot",lp="LogicalOr";var lP="LogSoftmax";var wu="LRN",Mm="LRNGrad",Cu="Max",Da="Maximum",Su="MaxPool",zm="MaxPoolGrad",ku="MaxPool3D",Bm="MaxPool3DGrad",iw="MaxPoolWithArgmax",Tu="Mean",Nu="Min",Ra="Minimum",Iu="MirrorPad",$a="Mod",aw="Multinomial",Oa="Multiply",Eu="Neg",up="NotEqual",Vm="NonMaxSuppressionV3",Wm="NonMaxSuppressionV4",Gm="NonMaxSuppressionV5",_u="OnesLike",Au="OneHot",Du="Pack",Ru="PadV2";var Fa="Pow",$u="Prelu",Ou="Prod",lw="RaggedGather",uw="RaggedRange",cw="RaggedTensorToTensor",Um="Range",Hm="Real",Pa="Reciprocal",La="Relu",Fu="Reshape",Pu="ResizeNearestNeighbor",qm="ResizeNearestNeighborGrad",Lu="ResizeBilinear",jm="ResizeBilinearGrad",Ma="Relu6",Mu="Reverse",za="Round",Ba="Rsqrt",pw="ScatterNd",fw="SearchSorted",zu="Select",Va="Selu",Bu="Slice",Wa="Sin",Ga="Sinh",Ua="Sign",Ha="Sigmoid",qa="Softplus",ja="Sqrt",Vu="Sum",Wu="SpaceToBatchND",Gu="SplitV",Uu="Softmax",mw="SparseFillEmptyRows",dw="SparseReshape",hw="SparseSegmentMean",gw="SparseSegmentSum",xw="SparseToDense",Ka="SquaredDifference",Km="Square",Xm="StridedSlice",yw="StringNGrams",bw="StringSplit",vw="StringToHashBucketFast",Xa="Sub",Ya="Tan",Qa="Tanh",bi="Tile",Ym="TopK",Qm="Transform",vi="Transpose",Zm="Unique",Hu="Unpack",qu="UnsortedSegmentSum";var ju="ZerosLike",Za="Step",Jg="FromPixels",Jm="RotateWithOffset",cp="_FusedMatMul",pp="FusedConv2D",fp="FusedDepthwiseConv2D";function wi(...e){B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(...e)}function SJ(...e){B().getBool("IS_TEST")||B().getBool("PROD")||console.log(...e)}var ww=Yg("kernelRegistry",()=>new Map),WI=Yg("gradRegistry",()=>new Map);function tx(e,t){let r=pP(e,t);return ww.get(r)}function GI(e){return WI.get(e)}function UI(e){let t=ww.entries(),r=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===e&&r.push(i)}return r}function Cw(e){let{kernelName:t,backendName:r}=e,n=pP(t,r);ww.has(n)&&wi(`The kernel '${t}' for backend '${r}' is already registered`),ww.set(n,e)}function cP(e){let{kernelName:t}=e;WI.has(t)&&B().getBool("DEBUG")&&wi(`Overriding the gradient for '${t}'`),WI.set(t,e)}function pP(e,t){return`${t}_${e}`}var w={};Zn(w,{arraysEqual:()=>eu,assert:()=>A,assertNonNegativeIntegerDimensions:()=>Fr,assertNonNull:()=>tp,assertShapesMatch:()=>tw,bytesFromStringArray:()=>MI,bytesPerElement:()=>ew,checkConversionForErrors:()=>PI,clamp:()=>um,computeStrides:()=>gi,createScalarValue:()=>AJ,createShuffledIndices:()=>cJ,decodeString:()=>od,distSquared:()=>iJ,encodeString:()=>nd,fetch:()=>RJ,fingerPrint64:()=>_J,flatten:()=>tu,getArrayFromDType:()=>FI,getTypedArrayFromDType:()=>mJ,hasEncodingLoss:()=>dJ,hexToLong:()=>ex,indexToLoc:()=>xJ,inferDtype:()=>pm,inferFromImplicitShape:()=>fJ,isBoolean:()=>rP,isFunction:()=>fm,isInt:()=>ia,isNumber:()=>nP,isPromise:()=>Kg,isScalarShape:()=>aJ,isString:()=>cm,isTypedArray:()=>so,isValidDtype:()=>LI,locToIndex:()=>gJ,makeOnesTypedArray:()=>jg,makeZerosNestedTypedArray:()=>hJ,makeZerosTypedArray:()=>dm,nearestDivisor:()=>mm,nearestLargerEven:()=>nJ,now:()=>xp,parseAxisParam:()=>dr,randUniform:()=>sJ,repeatedTry:()=>pJ,rightPad:()=>ep,shuffle:()=>eP,shuffleCombo:()=>rJ,sizeFromShape:()=>ee,sizeToSquarishShape:()=>uJ,squeezeShape:()=>OI,sum:()=>oJ,swap:()=>Jv,tanh:()=>lJ,toNestedArray:()=>Jc,toTypedArray:()=>rd});var KI=Yt(CP());var gp=KI.default||KI;function ex(e){return gp.fromString(e,!0,16)}var kP=ex("c3a5c85c97cb3127"),hp=ex("b492b66fbe98f273"),Sn=ex("9ae16a3b2f90404f");function jI(e){return e.xor(e.shru(47))}function TP(e,t,r){let n=e.slice(t,t+r);return gp.fromBytes(Array.from(n),!0,!0)}function $e(e,t){return TP(e,t,8)}function SP(e,t){return TP(e,t,4)}function Pr(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ku(e,t,r=ex("9ddfea08eb382d69")){let n=e.xor(t).mul(r);n=n.xor(n.shru(47));let o=t.xor(n).mul(r);return o=o.xor(o.shru(47)),o=o.mul(r),o}function TJ(e,t,r,n,o,s){o=o.add(e),s=Pr(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(r),s=s.add(Pr(o,44)),[o.add(n),s.add(i)]}function kw(e,t,r,n){return TJ($e(e,t),$e(e,t+8),$e(e,t+16),$e(e,t+24),r,n)}function NJ(e,t=e.length){if(t>=8){let r=Sn.add(t*2),n=$e(e,0).add(Sn),o=$e(e,t-8),s=Pr(o,37).mul(r).add(n),i=Pr(n,25).add(o).mul(r);return Ku(s,i,r)}if(t>=4){let r=Sn.add(t*2),n=SP(e,0);return Ku(n.shl(3).add(t),SP(e,t-4),r)}if(t>0){let r=e[0],n=e[t>>1],o=e[t-1],s=r+(n<<8),i=t+(o<<2);return jI(Sn.mul(s).xor(kP.mul(i))).mul(Sn)}return Sn}function IJ(e,t=e.length){let r=Sn.add(t*2),n=$e(e,0).mul(hp),o=$e(e,8),s=$e(e,t-8).mul(r),i=$e(e,t-16).mul(Sn);return Ku(Pr(n.add(o),43).add(Pr(s,30)).add(i),n.add(Pr(o.add(Sn),18)).add(s),r)}function EJ(e,t=e.length){let r=Sn.add(t*2),n=$e(e,0).mul(Sn),o=$e(e,8),s=$e(e,t-8).mul(r),i=$e(e,t-16).mul(Sn),a=Pr(n.add(o),43).add(Pr(s,30)).add(i),l=Ku(a,n.add(Pr(o.add(Sn),18)).add(s),r),u=$e(e,16).mul(r),c=$e(e,24),p=a.add($e(e,t-32)).mul(r),f=l.add($e(e,t-24)).mul(r);return Ku(Pr(u.add(c),43).add(Pr(p,30)).add(f),u.add(Pr(c.add(n),18)).add(p),r)}function _J(e,t=e.length){let r=gp.fromNumber(81,!0);if(t<=32)return t<=16?NJ(e,t):IJ(e,t);if(t<=64)return EJ(e,t);let n=r,o=r.mul(hp).add(113),s=jI(o.mul(Sn).add(113)).mul(Sn),i=[gp.UZERO,gp.UZERO],a=[gp.UZERO,gp.UZERO];n=n.mul(Sn).add($e(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do n=Pr(n.add(o).add(i[0]).add($e(e,l+8)),37).mul(hp),o=Pr(o.add(i[1]).add($e(e,l+48)),42).mul(hp),n=n.xor(a[1]),o=o.add(i[0]).add($e(e,l+40)),s=Pr(s.add(a[0]),33).mul(hp),i=kw(e,l,i[1].mul(hp),n.add(a[0])),a=kw(e,l+32,s.add(a[1]),o.add($e(e,l+16))),[s,n]=[n,s],l+=64;while(l!==u);let p=hp.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Pr(n.add(o).add(i[0]).add($e(e,l+8)),37).mul(p),o=Pr(o.add(i[1]).add($e(e,l+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add($e(e,l+40))),s=Pr(s.add(a[0]),33).mul(p),i=kw(e,l,i[1].mul(p),n.add(a[0])),a=kw(e,l+32,s.add(a[1]),o.add($e(e,l+16))),[s,n]=[n,s],Ku(Ku(i[0],a[0],p).add(jI(o).mul(kP)).add(s),Ku(i[1],a[1],p).add(n),p)}function AJ(e,t){return t==="string"?nd(e):rd([e],t)}function DJ(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function rd(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=tu(e)),B().getBool("DEBUG")&&PI(e,t),DJ(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let r=new Uint8Array(e.length);for(let n=0;n<r.length;++n)Math.round(e[n])!==0&&(r[n]=1);return r}else throw new Error(`Unknown data type ${t}`)}function xp(){return B().platform.now()}function RJ(e,t){return B().platform.fetch(e,t)}function nd(e,t="utf-8"){return t=t||"utf-8",B().platform.encode(e,t)}function od(e,t="utf-8"){return t=t||"utf-8",B().platform.decode(e,t)}var Tw=class{constructor(t,r){this.backendTimer=t,this.logger=r,r==null&&(this.logger=new XI)}profileKernel(t,r,n){let o,s=()=>{o=n()},i,a=xp();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let u of o)u.dataSync();i=Promise.resolve({kernelMs:xp()-a})}if(B().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<o.length;u++){let c=o[u];c.data().then(p=>{$J(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:r,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:r,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(l=>{this.logger.logKernelProfile(r,a,l[0],l[1],s,l[2])})})}};function $J(e,t,r){if(t!=="float32")return!1;for(let n=0;n<e.length;n++){let o=e[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${r}'`),!0}return!1}var XI=class{logKernelProfile(t,r,n,o,s,i){let a=typeof o=="number"?ep(`${o}ms`,9):o.error,l=ep(t,25),u=r.rank,c=r.size,p=ep(r.shape.toString(),14),f="";for(let m in s){let d=s[m];if(d!=null){let h=d.shape||r.shape,x=h.length;f+=`${m}: ${x}D ${x>0?h:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${p}	%c${c}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function NP(e,t,r){let n={},o={};for(let l=0;l<t.length;l++)n[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let p in c){let f=c[p],m=!1;for(let d=0;d<t.length;d++)if(n[f.id]){u.outputs.forEach(h=>n[h.id]=!0),m=!0,o[u.id]=!0;break}if(m)break}}let s={};s[r.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let f in c)s[c[f].id]=!0,i[u.id]=!0;break}}let a=[];for(let l=0;l<e.length;l++){let u=e[l];if(o[u.id]&&i[u.id]){let c={};for(let f in u.inputs){let m=u.inputs[f];n[m.id]&&(c[f]=m)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,a.push(p)}}return a}function IP(e,t,r,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);let u=r(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!eu(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let p=e[c.id];e[c.id]=n(p,u),p.dispose()}}}}var EP=20,rx=3,YI=7;function _P(e,t,r,n){let o=gi(t),s=OJ(e,t,r,o),i=t.length,a=Nw(e,t,r,o,s),l=["Tensor"];return n&&(l.push(`  dtype: ${r}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function OJ(e,t,r,n){let o=ee(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,l=r==="complex64"?ox(e):e;if(a>1)for(let u=0;u<o/s;u++){let c=u*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],nx(l[c+p],0,r).length)}return i}function nx(e,t,r){let n;return Array.isArray(e)?n=`${parseFloat(e[0].toFixed(YI))} + ${parseFloat(e[1].toFixed(YI))}j`:cm(e)?n=`'${e}'`:r==="bool"?n=AP(e):n=parseFloat(e.toFixed(YI)).toString(),ep(n,t)}function AP(e){return e===0?"false":"true"}function Nw(e,t,r,n,o,s=!0){let i=r==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(r==="complex64"){let h=ox(e);return[nx(h[0],0,r)]}return r==="bool"?[AP(e[0])]:[e[0].toString()]}if(l===1){if(a>EP){let x=rx*i,g=Array.from(e.slice(0,x)),y=Array.from(e.slice((a-rx)*i,a*i));return r==="complex64"&&(g=ox(g),y=ox(y)),["["+g.map((b,v)=>nx(b,o[v],r)).join(", ")+", ..., "+y.map((b,v)=>nx(b,o[a-rx+v],r)).join(", ")+"]"]}return["["+(r==="complex64"?ox(e):Array.from(e)).map((x,g)=>nx(x,o[g],r)).join(", ")+"]"]}let u=t.slice(1),c=n.slice(1),p=n[0]*i,f=[];if(a>EP){for(let h=0;h<rx;h++){let x=h*p,g=x+p;f.push(...Nw(e.slice(x,g),u,r,c,o,!1))}f.push("...");for(let h=a-rx;h<a;h++){let x=h*p,g=x+p;f.push(...Nw(e.slice(x,g),u,r,c,o,h===a-1))}}else for(let h=0;h<a;h++){let x=h*p,g=x+p;f.push(...Nw(e.slice(x,g),u,r,c,o,h===a-1))}let m=l===2?",":"";f[0]="["+f[0]+m;for(let h=1;h<f.length-1;h++)f[h]=" "+f[h]+m;let d=`,
`;for(let h=2;h<l;h++)d+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":d),f}function ox(e){let t=[];for(let r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}var ce=class{constructor(t,r,n){if(this.dtype=r,this.shape=t.slice(),this.size=ee(t),n!=null){let o=n.length;A(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(r==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||FI(r,this.size),this.strides=gi(t)}set(t,...r){r.length===0&&(r=[0]),A(r.length===this.rank,()=>`The number of provided coordinates (${r.length}) must match the rank (${this.rank})`);let n=this.locToIndex(r);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let r=0;for(let o of t){if(o<0||o>=this.shape[r]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}r++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let r=t[t.length-1];for(let n=0;n<t.length-1;++n)r+=this.strides[n]*t[n];return r}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let r=new Array(this.shape.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/this.strides[n]),t-=r[n]*this.strides[n];return r[r.length-1]=t,r}get rank(){return this.shape.length}toTensor(){return Ls().makeTensor(this.values,this.shape,this.dtype)}},Ls=null,sd=null,FJ=null;function DP(e){Ls=e}function RP(e){sd=e}function $P(e){FJ=e}var qt=class{constructor(t,r,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=r||"float32",this.size=ee(t),this.strides=gi(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return H(this,null,function*(){let t=yield this.data();return sd.buffer(this.shape,this.dtype,t)})}bufferSync(){return sd.buffer(this.shape,this.dtype,this.dataSync())}array(){return H(this,null,function*(){let t=yield this.data();return Jc(this.shape,t,this.dtype==="complex64")})}arraySync(){return Jc(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return H(this,null,function*(){this.throwIfDisposed();let t=Ls().read(this.dataId);if(this.dtype==="string"){let r=yield t;try{return r.map(n=>od(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})}dataToGPU(t){return this.throwIfDisposed(),Ls().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Ls().readSync(this.dataId);if(this.dtype==="string")try{return t.map(r=>od(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){return H(this,null,function*(){this.throwIfDisposed();let t=yield Ls().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)})}dispose(){this.isDisposed||(Ls().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return sd.print(this,t)}clone(){return this.throwIfDisposed(),sd.clone(this)}toString(t=!1){let r=this.dataSync();return _P(r,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),sd.cast(this,t)}variable(t=!0,r,n){return this.throwIfDisposed(),Ls().makeVariable(this,t,r,n)}};Object.defineProperty(qt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function O(){return Yg("Tensor",()=>qt)}O();var Ja=class extends qt{constructor(t,r,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=r,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!eu(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ls().disposeTensor(this),this.dataId=t.dataId,Ls().incRef(this,null)}dispose(){Ls().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ja,Symbol.hasInstance,{value:e=>e instanceof qt&&e.assign!=null&&e.assign instanceof Function});var Jo={};Zn(Jo,{assertTypesMatch:()=>LJ,getTensorsInContainer:()=>sx,isTensorInList:()=>MJ,makeTypesMatch:()=>Gt});var QI;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(QI||(QI={}));var ZI;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(ZI||(ZI={}));var JI;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(JI||(JI={}));var tE;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(tE||(tE={}));var eE;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(eE||(eE={}));var PJ={float32:tE,int32:ZI,bool:JI,complex64:eE};function or(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return PJ[e][t]}function yp(e){return or(e,"int32")}function Gt(e,t){if(e.dtype===t.dtype)return[e,t];let r=or(e.dtype,t.dtype);return[e.cast(r),t.cast(r)]}function LJ(e,t){A(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function MJ(e,t){return t.some(r=>r.id===e.id)}function sx(e){let t=[];return OP(e,t,new Set),t}function OP(e,t,r){if(e==null)return;if(e instanceof qt){t.push(e);return}if(!zJ(e))return;let n=e;for(let o in n){let s=n[o];r.has(s)||(r.add(s),OP(s,t,r))}}function zJ(e){return Array.isArray(e)||typeof e=="object"}function rE(e){return e.kernelName!=null}var Iw=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Xu=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Iw}ready(){return H(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let n=t[r];if(yield this.initializeBackend(n).success){yield this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:r}=this.initializeBackend(t);if(r)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,n=1){return t in this.registryFactory?(wi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:n},!0)}setBackend(t){return H(this,null,function*(){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:r,asyncInit:n}=this.initializeBackend(t);if(!(n?yield r:r))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Tw(this.backendInstance),!0})}setupRegisteredKernels(){UI(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){UI(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let r=this.registryFactory[t];if(r==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=r.factory();if(n&&!(n instanceof sa)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,wi(`Initialization of backend ${t} failed`),wi(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return wi(`Initialization of backend ${t} failed`),wi(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let n=t[r],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){let n=this.state.tensorInfo.get(r),o=n.backend,s=this.readSync(r),i=o.refCount(r);o.disposeData(r,!0),n.backend=t,t.move(r,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let n=null;if(r==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");r=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,r,n){t();try{let o=n();return r(),o}catch(o){throw r(),o}}nextTensorId(){return Xu.nextTensorId++}nextVariableId(){return Xu.nextVariableId++}clone(t){let r=E.runKernel(yi,{x:t}),n={x:t},o=i=>({x:()=>{let a="float32",l={x:i},u={dtype:a};return E.runKernel(xi,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[r],o,s,{}),r}runKernel(t,r,n){if(this.backendName==null&&this.backend,!(tx(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,n){let o=this.backend.numDataIds(),s=0;n.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-r-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let r,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l,u=rE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(rE(t)){let{kernelName:d,inputs:h,attrs:x}=t;this.backendName==null&&this.backend;let g=tx(d,this.backendName);A(g!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let y=this.backend.numDataIds();l=g.kernelFunc({inputs:h,attrs:x,backend:this.backend});let b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,y,b);let v=b.map(C=>C.rank!=null?C:this.makeTensorFromTensorInfo(C));if(o){let C=this.getTensorsForGradient(d,h,v);n=this.saveTensorsForBackwardMode(C)}return v}}else{let{forwardFunc:d}=t,h=x=>{!o||(n=x.map(g=>this.keep(this.clone(g))))};a=()=>{let x=this.backend.numDataIds();l=this.tidy(()=>d(this.backend,h));let g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,x,g),g}}let{inputs:c,attrs:p}=t,f=rE(t)?null:t.backwardsFunc,m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=a():(m=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),r=m.outputs)}),o&&this.addTapeNode(u,c,r,f,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:r.map(d=>d.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,r,n){let o=GI(t);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(A(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(r).map(u=>r[u])):a=s.map(u=>r[u]);let l=n.filter((u,c)=>i[c]);return a.concat(l)}return[]}makeTensor(t,r,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&cm(t[0])&&(s=t.map(l=>nd(l)));let i=o.write(s,r,n),a=new qt(r,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let l=this.state.tensorInfo.get(i),u=MI(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(t,r,n,o){n=n||"float32";let s={dataId:t,shape:r,dtype:n};return this.makeTensorFromTensorInfo(s,o)}makeTensorFromTensorInfo(t,r){let{dataId:n,shape:o,dtype:s}=t,i=new qt(o,s,n,this.nextTensorId());return this.trackTensor(i,r),i}makeVariable(t,r=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new Ja(t,r,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,r){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*ew(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Ja||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*ew(t.dtype);this.state.numBytes-=n}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let r=this.state.registeredVariables[t];this.disposeVariable(r)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){return H(this,null,function*(){this.state.profiling=!0;let r=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,r,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:n,saved:s},l=GI(t);l!=null&&(o=l.gradFunc),o!=null&&(a.gradient=u=>(u=u.map((c,p)=>{if(c==null){let f=n[p],m=dm(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return c}),o(u.length>1?u:u[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){let r=sx(t),n=new Set(r.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,r,n,o=!1){if(A(r.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));A(s instanceof qt,()=>"The result y returned by f() must be a tensor.");let i=NP(this.state.activeTape,r,s);if(!o&&i.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?BJ(s.shape):n,IP(a,i,u=>this.tidy(u),VJ);let l=r.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return A(fm(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{A(r.every(a=>a instanceof qt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};r.forEach((a,l)=>{o[l]=a});let s=(a,l)=>(n=t(...r,l),A(n.value instanceof qt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(fm(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,l)=>{let u=n.gradFunc(a,l),c=Array.isArray(u)?u:[u];A(c.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(f=>f instanceof qt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((f,m)=>{p[m]=()=>f}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}time(t){return H(this,null,function*(){let r=xp(),n=yield this.backend.time(t);return n.wallMs=xp()-r,n})}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Iw;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Xu.nextTensorId=0;Xu.nextVariableId=0;function BJ(e){let t=jg(ee(e),"float32");return E.makeTensor(t,e,"float32")}function nE(){let e=VI();if(e._tfengine==null){let t=new Xg(e);e._tfengine=new Xu(t)}return iP(e._tfengine.ENV),DP(()=>e._tfengine),e._tfengine}var E=nE();function VJ(e,t){let r={a:e,b:t};return E.runKernel(Fs,r)}var Yu={};Zn(Yu,{isBrowser:()=>sE,isMobile:()=>UJ,mockIsMobile:()=>GJ});function WJ(){return typeof navigator!="undefined"&&navigator!=null}var oE;function GJ(e){oE=e}function UJ(e){if(oE!==void 0)return oE;if(e||WJ()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let r=e;return r.userAgentData&&r.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function sE(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Io=B();Io.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Io.registerFlag("IS_BROWSER",()=>sE());Io.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Io.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Io.registerFlag("PROD",()=>!1);Io.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Io.getBool("DEBUG"));Io.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Io.registerFlag("IS_TEST",()=>!1);Io.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Io.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Io.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Io.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function tl(e,t){let r=e;if(so(e))return t==="string"?[]:[e.length];if(typeof e=="object"&&"texture"in e){let o=e.channels||"RGBA";return[e.height,e.width*o.length]}if(!Array.isArray(e))return[];let n=[];for(;Array.isArray(r)||so(r)&&t!=="string";)n.push(r.length),r=r[0];return Array.isArray(e)&&B().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&PP(e,n,[]),n}function PP(e,t,r){if(r=r||[],!Array.isArray(e)&&!so(e)){A(t.length===0,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${e.length} elements`),A(e.length===t[0],()=>`Element arr[${r.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let n=t.slice(1);for(let o=0;o<e.length;++o)PP(e[o],n,r.concat(o))}function FP(e,t,r,n){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${r}' passed to '${n}' must be ${e} tensor, but got ${t} tensor`)}}function N(e,t,r,n="numeric"){if(e instanceof qt)return FP(n,e.dtype,t,r),e;let o=pm(e);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),FP(n,o,t,r),e==null||!so(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${l}'`)}let s=tl(e,o);!so(e)&&!Array.isArray(e)&&(e=[e]);let a=o!=="string"?rd(e,o):tu(e,[],!0);return E.makeTensor(a,s,o)}function Ew(e,t,r,n="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,i)=>N(s,`${t}[${i}]`,r,n))}var HJ="__op";function _(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let r=t[0],n=e[r];r.endsWith("_")&&(r=r.substring(0,r.length-1)),r=r+HJ;let o=(...s)=>{E.startScope(r);try{let i=n(...s);return Kg(i)&&console.error("Cannot return a Promise inside of tidy."),E.endScope(i),i}catch(i){throw E.endScope(null),i}};return Object.defineProperty(o,"name",{value:r,configurable:!0}),o}function qJ(e,t){let r=N(e,"real","complex"),n=N(t,"imag","complex");tw(r.shape,n.shape,`real and imag shapes, ${r.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:r,imag:n};return E.runKernel(wm,o)}var Eo=_({complex_:qJ});function Ci(e,t,r,n){if(n==null&&(n=pm(e)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof e=="object"&&"texture"in e){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return e.channels=e.channels||"RGBA",E.backend.createTensorFromTexture(e,t||r,n)}if(!so(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Fr(t);let o=ee(t),s=ee(r);A(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<r.length;++i){let a=r[i],l=i===r.length-1?a!==ee(t.slice(i)):!0;A(r[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `)}}return!so(e)&&!Array.isArray(e)&&(e=[e]),t=t||r,e=n!=="string"?rd(e,n):tu(e,[],!0),E.makeTensor(e,t,n)}function sr(e,t,r){let n=tl(e,r);return Ci(e,t,n,r)}var ix={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var _w=4;function MP(e,t){return H(this,null,function*(){let r=[],n=[],o=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<o.length;++i){let a=o[i],l=Array.isArray(e)?e[i].tensor:e[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);let u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(p=>H(this,null,function*(){let f=yield l.bytes(),m=f.reduce((x,g)=>x+g.length,0)+_w*f.length,d=new Uint8Array(m),h=0;for(let x=0;x<f.length;x++){let g=f[x],y=new Uint8Array(new Uint32Array([g.length]).buffer);d.set(y,h),h+=_w,d.set(g,h),h+=g.length}p(d)}));n.push(c)}else n.push(l.data());t!=null&&(u.group=t),r.push(u)}let s=yield Promise.all(n);return{data:jJ(s),specs:r}})}function Aw(e,t){let r={},n,o=0;for(let s of t){let i=s.name,a=s.dtype,l=s.shape,u=ee(l),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let f=ix[p.dtype],m=e.slice(o,o+u*f),d=p.dtype==="uint8"?new Uint8Array(m):new Uint16Array(m);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let x=d[h];c[h]=x*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=QJ()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let x=d[h];c[h]=Math.round(x*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=u*f}else if(a==="string"){let p=ee(s.shape);c=[];for(let f=0;f<p;f++){let m=new Uint32Array(e.slice(o,o+_w))[0];o+=_w;let d=new Uint8Array(e.slice(o,o+m));c.push(d),o+=m}}else{let p=ix[a],f=e.slice(o,o+u*p);if(a==="float32")c=new Float32Array(f);else if(a==="int32")c=new Int32Array(f);else if(a==="bool")c=new Uint8Array(f);else if(a==="complex64"){c=new Float32Array(f);let m=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let g=0;g<m.length;g++)m[g]=c[g*2],d[g]=c[g*2+1];let h=sr(m,l,"float32"),x=sr(d,l,"float32");r[i]=Eo(h,x),h.dispose(),x.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=u*p}a!=="complex64"&&(r[i]=sr(c,l,a))}return r}function jJ(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,r=[];e.forEach(s=>{if(t+=s.byteLength,r.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return r.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var iE=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function LP(e){return iE?Buffer.byteLength(e):new Blob([e]).size}function zP(e){if(iE)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),r="";for(let n=0,o=t.length;n<o;n++)r+=String.fromCharCode(t[n]);return btoa(r)}function BP(e){if(iE){let n=Buffer.from(e,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;++n)r.set([t.charCodeAt(n)],n);return r.buffer}function id(e){if(e.length===1)return e[0];let t=0;e.forEach(o=>{t+=o.byteLength});let r=new Uint8Array(t),n=0;return e.forEach(o=>{r.set(new Uint8Array(o),n),n+=o.byteLength}),r.buffer}function aE(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let r=e.split(t);return r[r.length-1]}function Dw(e,t){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),r}function lE(e,t,r){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!r)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=r}return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),n}function ad(e,t){return H(this,null,function*(){let r,n;return e.weightsManifest!=null&&([r,n]=yield t(e.weightsManifest)),lE(e,r,n)})}function Si(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:LP(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:LP(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function Rw(e){let t=[];for(let r of e)t.push(...r.weights);return t}function KJ(){let e=r=>{let n=r<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let r=1;r<1024;r++)t[r]=e(r);for(let r=1024;r<2048;r++)t[r]=939524096+(r-1024<<13);return t}function XJ(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function YJ(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function QJ(){let e=KJ(),t=XJ(),r=YJ();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],l=e[r[a>>10]+(a&1023)]+t[a>>10];s[i]=l}return new Float32Array(o)}}var xe=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return xe.instance==null&&(xe.instance=new xe),xe.instance}static registerSaveRouter(t){xe.getInstance().saveRouters.push(t)}static registerLoadRouter(t){xe.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return xe.getHandlers(t,"save")}static getLoadHandlers(t,r){return xe.getHandlers(t,"load",r)}static getHandlers(t,r,n){let o=[];return(r==="load"?xe.getInstance().loadRouters:xe.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},VP=e=>xe.registerSaveRouter(e),WP=e=>xe.registerLoadRouter(e),GP=e=>xe.getSaveHandlers(e),UP=(e,t)=>xe.getLoadHandlers(e,t);var uE="tensorflowjs",cE=1,bp="models_store",Qu="model_info_store";function HP(){if(!B().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pE(e){let t=e.result;t.createObjectStore(bp,{keyPath:"modelPath"}),t.createObjectStore(Qu,{keyPath:"modelPath"})}var ki=class{constructor(t){if(this.indexedDB=HP(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){return H(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)})}load(){return H(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(t,r){return new Promise((n,o)=>{let s=this.indexedDB.open(uE,cE);s.onupgradeneeded=()=>pE(s),s.onsuccess=()=>{let i=s.result;if(r==null){let a=i.transaction(bp,"readonly"),u=a.objectStore(bp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=c=>(i.close(),o(u.error)),a.oncomplete=()=>i.close()}else{let a=Si(r),l=i.transaction(Qu,"readwrite"),u=l.objectStore(Qu),c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(bp,"readwrite");let m=p.objectStore(bp).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:a});m.onsuccess=()=>n({modelArtifactsInfo:a}),m.onerror=d=>{u=l.objectStore(Qu);let h=u.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(m.error)),h.onerror=x=>(i.close(),o(m.error))}},c.onerror=f=>(i.close(),o(c.error)),l.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};ki.URL_SCHEME="indexeddb://";var qP=e=>B().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ki.URL_SCHEME)?ZJ(e.slice(ki.URL_SCHEME.length)):null;xe.registerSaveRouter(qP);xe.registerLoadRouter(qP);function ZJ(e){return new ki(e)}function JJ(e){return e.startsWith(ki.URL_SCHEME)?e.slice(ki.URL_SCHEME.length):e}var $w=class{constructor(){this.indexedDB=HP()}listModels(){return H(this,null,function*(){return new Promise((t,r)=>{let n=this.indexedDB.open(uE,cE);n.onupgradeneeded=()=>pE(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Qu,"readonly"),a=s.objectStore(Qu).getAll();a.onsuccess=()=>{let l={};for(let u of a.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},a.onerror=l=>(o.close(),r(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>r(n.error)})})}removeModel(t){return H(this,null,function*(){return t=JJ(t),new Promise((r,n)=>{let o=this.indexedDB.open(uE,cE);o.onupgradeneeded=()=>pE(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Qu,"readwrite"),a=i.objectStore(Qu),l=a.get(t),u;l.onsuccess=()=>{if(l.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{u=s.transaction(bp,"readwrite");let m=u.objectStore(bp).delete(t);m.onsuccess=()=>r(l.result.modelArtifactsInfo),m.onerror=d=>n(l.error)};c.onsuccess=p,c.onerror=f=>(p(),s.close(),n(l.error))}},l.onerror=c=>(s.close(),n(l.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})})}};var el="/",ld="tensorflowjs_models",jP="info",ttt="model_topology",ett="weight_specs",rtt="weight_data",ntt="model_metadata";function KP(e){return{info:[ld,e,jP].join(el),topology:[ld,e,ttt].join(el),weightSpecs:[ld,e,ett].join(el),weightData:[ld,e,rtt].join(el),modelMetadata:[ld,e,ntt].join(el)}}function XP(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function ott(e){let t=e.split(el);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(el)}function stt(e){return e.startsWith(Ti.URL_SCHEME)?e.slice(Ti.URL_SCHEME.length):e}var Ti=class{constructor(t){if(!B().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=KP(this.modelPath)}save(t){return H(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=Si(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,zP(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw XP(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})}load(){return H(this,null,function*(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);r.format=a.format,r.generatedBy=a.generatedBy,r.convertedBy=a.convertedBy,a.signature!=null&&(r.signature=a.signature),a.userDefinedMetadata!=null&&(r.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(r.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(r.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(r.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=BP(i),r})}};Ti.URL_SCHEME="localstorage://";var YP=e=>B().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ti.URL_SCHEME)?itt(e.slice(Ti.URL_SCHEME.length)):null;xe.registerSaveRouter(YP);xe.registerLoadRouter(YP);function itt(e){return new Ti(e)}var Ow=class{constructor(){A(B().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return H(this,null,function*(){let t={},r=ld+el,n=el+jP;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(r)&&s.endsWith(n)){let i=ott(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t})}removeModel(t){return H(this,null,function*(){t=stt(t);let r=KP(t);if(this.LS.getItem(r.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(r.info));return XP(r),n})}};var ud="://",Lr=class{constructor(){this.managers={}}static getInstance(){return Lr.instance==null&&(Lr.instance=new Lr),Lr.instance}static registerManager(t,r){A(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(ud)&&(t=t.slice(0,t.indexOf(ud))),A(t.length>0,()=>"scheme must not be an empty string.");let n=Lr.getInstance();A(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=r}static getManager(t){let r=Lr.getInstance().managers[t];if(r==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return r}static getSchemes(){return Object.keys(Lr.getInstance().managers)}};function Fw(e){if(e.indexOf(ud)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Lr.getSchemes().join(",")}`);return{scheme:e.split(ud)[0],path:e.split(ud)[1]}}function QP(e,t,r=!1){return H(this,null,function*(){A(e!==t,()=>`Old path and new path are the same: '${e}'`);let n=xe.getLoadHandlers(e);A(n.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),A(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${e}.`);let o=n[0],s=xe.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=Fw(e).scheme,l=Fw(e).path,u=a===Fw(e).scheme,c=yield o.load();r&&u&&(yield Lr.getManager(a).removeModel(l));let p=yield i.save(c);return r&&!u&&(yield Lr.getManager(a).removeModel(l)),p.modelArtifactsInfo})}function ZP(){return H(this,null,function*(){let e=Lr.getSchemes(),t={};for(let r of e){let n=yield Lr.getManager(r).listModels();for(let o in n){let s=r+ud+o;t[s]=n[o]}}return t})}function JP(e){return H(this,null,function*(){let t=Fw(e);return Lr.getManager(t.scheme).removeModel(t.path)})}function tL(e,t){return H(this,null,function*(){return QP(e,t,!1)})}function eL(e,t){return H(this,null,function*(){return QP(e,t,!0)})}var fE=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,r){return fetch(t,r)}now(){return performance.now()}encode(t,r){if(r!=="utf-8"&&r!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${r}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,r){return new TextDecoder(r).decode(t)}setTimeoutCustom(t,r){if(typeof window=="undefined"||!B().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,r);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},r),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let o=this.functionRefs[n.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}};if(B().get("IS_BROWSER")){B().setPlatform("browser",new fE);try{Lr.registerManager(Ti.URL_SCHEME,new Ow)}catch(e){}try{Lr.registerManager(ki.URL_SCHEME,new $w)}catch(e){}}var att={importFetch:()=>rL()},mE;var dE=class{constructor(){this.util=nL(),this.textEncoder=new this.util.TextEncoder}fetch(t,r){return B().global.fetch!=null?B().global.fetch(t,r):(mE==null&&(mE=att.importFetch()),mE(t,r))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,r){if(r!=="utf-8"&&r!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${r}`);return this.textEncoder.encode(t)}decode(t,r){return t.length===0?"":new this.util.TextDecoder(r).decode(t)}};B().get("IS_NODE")&&!B().get("IS_BROWSER")&&B().setPlatform("node",new dE);function Ct(e,t="float32",r){return t=t||"float32",Fr(e),new ce(e,t,r)}function ltt(e,t){let r=N(e,"x","cast");if(!LI(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&r.dtype!=="string"||t!=="string"&&r.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:r},o={dtype:t};return E.runKernel(xi,n,o)}var et=_({cast_:ltt});function utt(e){let r={x:N(e,"x","clone","string_or_numeric")};return E.runKernel(yi,r)}var lo=_({clone_:utt});function oL(e,t=!1){console.log(e.toString(t))}nE();var ctt={buffer:Ct,cast:et,clone:lo,print:oL};RP(ctt);var nl={};Zn(nl,{browserFiles:()=>iL,browserHTTPRequest:()=>uL,concatenateArrayBuffers:()=>id,copyModel:()=>tL,decodeWeights:()=>Aw,encodeWeights:()=>MP,fromMemory:()=>cL,fromMemorySync:()=>vE,getLoadHandlers:()=>UP,getModelArtifactsForJSON:()=>ad,getModelArtifactsForJSONSync:()=>lE,getModelArtifactsInfoForJSON:()=>Si,getSaveHandlers:()=>GP,getWeightSpecs:()=>Rw,http:()=>Lw,isHTTPScheme:()=>Pw,listModels:()=>ZP,loadWeights:()=>aL,moveModel:()=>eL,registerLoadRouter:()=>WP,registerSaveRouter:()=>VP,removeModel:()=>JP,weightsLoaderFactory:()=>yE,withSaveHandler:()=>pL,withSaveHandlerSync:()=>fL});var ptt="model",ftt=".json",mtt=".weights.bin";function sL(e){return new Promise(t=>setTimeout(t)).then(e)}var rl=class{constructor(t){if(!B().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(rl.URL_SCHEME)&&(t=t.slice(rl.URL_SCHEME.length)),(t==null||t.length===0)&&(t=ptt),this.modelJsonFileName=t+ftt,this.weightDataFileName=t+mtt}save(t){return H(this,null,function*(){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=Dw(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,yield sL(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=r,yield sL(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Si(t)}}})}};rl.URL_SCHEME="downloads://";var hE=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){return H(this,null,function*(){return new Promise((t,r)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){r(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){r(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let l=ad(s,u=>this.loadWeights(u));t(l)},n.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})})}loadWeights(t){let r=[],n=[];for(let i of t)r.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[r,id(i)])}loadWeightsFile(t,r){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(r)})}checkManifestAndWeightFiles(t){let r=[],n=this.weightsFiles.map(s=>aE(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=aE(i);if(r.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(r.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(r.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${r.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},dtt=e=>B().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rl.URL_SCHEME)?htt(e.slice(rl.URL_SCHEME.length)):null;xe.registerSaveRouter(dtt);function htt(e="model"){return new rl(e)}function iL(e){return new hE(e)}function gE(e,t,r,n){i(e),r=r==null?0:r,n=n==null?1:n,a(r,n);let o=0,s=l=>(l.then(u=>{let c=r+ ++o/e.length*(n-r);return t(c),u}),l);function i(l){A(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),A(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}function xE(e,t){return H(this,null,function*(){t==null&&(t={});let r=t.fetchFunc==null?B().platform.fetch:t.fetchFunc,n=e.map(p=>r(p,t.requestInit,{isBinary:!0})),o=0,s=.5,a=(t.onProgress==null?yield Promise.all(n):yield gE(n,t.onProgress,o,s)).map(p=>p.arrayBuffer()),l=.5,u=1;return t.onProgress==null?yield Promise.all(a):yield gE(a,t.onProgress,l,u)})}function aL(e,t="",r,n){return H(this,null,function*(){return yE(i=>xE(i,{requestInit:n}))(e,t,r)})}function yE(e){return(t,r="",n)=>H(this,null,function*(){let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((m,d)=>{let h=0;m.weights.forEach(x=>{let g="quantization"in x?x.quantization.dtype:x.dtype,y=ix[g]*ee(x.shape),b=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:x,groupOffset:h,sizeBytes:y})};n!=null?n.forEach((v,C)=>{v===x.name&&(b(),i[C]=!0)}):b(),a.push(x.name),h+=y})}),!i.every(m=>m)){let m=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let l=o.reduce((m,d,h)=>(d&&m.push(h),m),[]),u=[];l.forEach(m=>{t[m].paths.forEach(d=>{let h=r+(r.endsWith("/")?"":"/")+d;u.push(h)})});let c=yield e(u),p={},f=0;return l.forEach(m=>{let d=t[m].paths.length,h=0;for(let v=0;v<d;v++)h+=c[f+v].byteLength;let x=new ArrayBuffer(h),g=new Uint8Array(x),y=0;for(let v=0;v<d;v++){let C=new Uint8Array(c[f+v]);g.set(C,y),y+=C.byteLength}s[m].forEach(v=>{let C=x.slice(v.groupOffset,v.groupOffset+v.sizeBytes),S=Aw(C,[v.manifestEntry]);for(let k in S)p[k]=S[k]}),f+=d}),p})}var gtt="application/octet-stream",xtt="application/json",ax=class{constructor(t,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(A(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=B().platform.fetch,A(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&A(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(t){return H(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=Dw(t,n);r.body.append("model.json",new Blob([JSON.stringify(o)],{type:xtt}),"model.json"),t.weightData!=null&&r.body.append("model.weights.bin",new Blob([t.weightData],{type:gtt}),"model.weights.bin");let s=yield this.fetch(this.path,r);if(s.ok)return{modelArtifactsInfo:Si(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})}load(){return H(this,null,function*(){let t=yield this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=r.modelTopology,o=r.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return ad(r,s=>this.loadWeights(s))})}loadWeights(t){return H(this,null,function*(){let r=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=ytt(r),s=this.weightPathPrefix||n,i=Rw(t),a=[],l=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...yield Promise.all(l));let u=yield xE(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,id(u)]})}};ax.URL_SCHEME_REGEX=/^https?:\/\//;function ytt(e){let t=e.lastIndexOf("/"),r=e.lastIndexOf("?"),n=e.substring(0,t),o=r>t?e.substring(r):"";return[n+"/",o]}function Pw(e){return e.match(ax.URL_SCHEME_REGEX)!=null}var lL=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let r=!0;if(Array.isArray(e)?r=e.every(n=>Pw(n)):r=Pw(e),r)return Lw(e,t)}return null};xe.registerSaveRouter(lL);xe.registerLoadRouter(lL);function Lw(e,t){return new ax(e,t)}function uL(e,t){return Lw(e,t)}var lx=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},Mw=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},bE=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=r=>Promise.resolve(t.save(r)))}};function cL(e,t,r,n){let o=arguments;return new bE(vE(...o))}function vE(e,t,r,n){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new lx(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new lx({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new lx({modelTopology:e,weightSpecs:t,weightData:r,trainingConfig:n}))}function pL(e){return new Mw(e)}function fL(e){return new Mw(e)}function btt(e,t,r=!1,n=!1){let o=N(e,"a","matMul"),s=N(t,"b","matMul");[o,s]=Gt(o,s);let i={a:o,b:s},a={transposeA:r,transposeB:n};return E.runKernel(au,i,a)}var Qt=_({matMul_:btt});function vtt(e,t,r=1,n=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:N(e,"indices","oneHot","int32")},a={dtype:o,depth:t,onValue:r,offValue:n};return E.runKernel(Au,i,a)}var cd=_({oneHot_:vtt});function wtt(e){B().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}$P(wtt);function ts(){return E}function ux(){return E.memory()}function V(e,t){return E.tidy(e,t)}function $t(e){sx(e).forEach(r=>r.dispose())}function Ir(e){return E.keep(e)}function zw(e,t,r=1){return E.registerBackend(e,t,r)}function mL(){return E.backend}function Ctt(e){let r={input:N(e,"input","imag")};return E.runKernel(Lm,r)}var pd=_({imag_:Ctt});function Stt(e){let r={x:N(e,"x","neg")};return E.runKernel(Eu,r)}var Zt=_({neg_:Stt});function ktt(e){let r={input:N(e,"input","real")};return E.runKernel(Hm,r)}var vp=_({real_:ktt});function Ttt(e,t,r){let n=N(e,"x","transpose");if(t==null&&(t=n.shape.map((i,a)=>a).reverse()),A(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(i=>{A(i>=0&&i<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:t};return n.dtype==="complex64"?V(()=>{let i=vp(n),a=pd(n);return i=E.runKernel(vi,{x:i},s),a=E.runKernel(vi,{x:a},s),r&&(a=Zt(a)),Eo(i,a)}):E.runKernel(vi,o,s)}var Lt=_({transpose_:Ttt});var uo={};Zn(uo,{assertAndGetBroadcastShape:()=>Pt,getBroadcastDims:()=>dL,getReductionAxes:()=>pe});function dL(e,t){let r=e.length,n=[];for(let o=0;o<r;o++){let s=r-1-o,i=e[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function pe(e,t){let r=[];for(let n=0;n<t.length;n++){let o=e[e.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&r.unshift(s)}return r}function Pt(e,t){let r=[],n=Math.max(e.length,t.length);for(let o=0;o<n;o++){let s=e[e.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)r.unshift(i);else if(i===1)r.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(a)}else r.unshift(s)}return r}var cx={};Zn(cx,{fromPixels:()=>Rtt,fromPixelsAsync:()=>Att,toPixels:()=>Dtt});function hL(e,t,r){if(tp(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=tl(e,r);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ci(e,t,n,r)}var wp;function gL(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let r=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(e.data instanceof Uint8Array)r=!0;else if(typeof ImageData!="undefined"&&e instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&e instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(tx(Jg,E.backendName)!=null){let d={pixels:e},h={numChannels:t};return E.runKernel(Jg,d,h)}let[u,c]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(i)p=e.getContext("2d").getImageData(0,0,u,c).data;else if(n||r)p=e.data;else if(s||o||a){if(wp==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")wp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else wp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});wp.canvas.width=u,wp.canvas.height=c,wp.drawImage(e,0,0,u,c),p=wp.getImageData(0,0,u,c).data}let f;if(t===4)f=new Int32Array(p);else{let d=u*c;f=new Int32Array(d*t);for(let h=0;h<d;h++)for(let x=0;x<t;++x)f[h*t+x]=p[h*4+x]}return hL(f,[c,u,t],"int32")}function Ntt(e){return e!=null&&e.data instanceof Uint8Array}function Itt(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function Ett(e){return e!=null&&e.width!==0&&e.height!==0}function _tt(e){return Itt()&&!(e instanceof ImageBitmap)&&Ett(e)&&!Ntt(e)}function Att(e,t=3){return H(this,null,function*(){let r=null;if(B().getBool("WRAP_TO_IMAGEBITMAP")&&_tt(e)){let n;try{n=yield createImageBitmap(e,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===e.width&&n.height===e.height?r=n:r=e}else r=e;return gL(r,t)})}function Dtt(e,t){return H(this,null,function*(){let r=N(e,"img","toPixels");if(!(e instanceof qt)){let u=r;r=et(u,"int32"),u.dispose()}if(r.rank!==2&&r.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${r.rank}.`);let[n,o]=r.shape.slice(0,2),s=r.rank===2?1:r.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(r.dtype!=="float32"&&r.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${r.dtype}. Please use float32 or int32 tensors.`);let i=yield r.data(),a=r.dtype==="float32"?255:1,l=new Uint8ClampedArray(o*n*4);for(let u=0;u<n*o;++u){let c=[0,0,0,255];for(let f=0;f<s;f++){let m=i[u*s+f];if(r.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(r.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);s===1?(c[0]=m*a,c[1]=m*a,c[2]=m*a):c[f]=m*a}let p=u*4;l[p+0]=Math.round(c[0]),l[p+1]=Math.round(c[1]),l[p+2]=Math.round(c[2]),l[p+3]=Math.round(c[3])}if(t!=null){t.width=o,t.height=n;let u=t.getContext("2d"),c=new ImageData(l,o,n);u.putImageData(c,0,0)}return r!==e&&r.dispose(),l})}var Rtt=_({fromPixels_:gL});function $tt(e,t){let r=e.shape.length,n=t.shape.length;if(r<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${r}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>r)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${r}`);if(ee(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=e.shape,l=o.slice();l.pop();let u=1;for(let p=s;p<r;++p)u*=a[p],l.push(a[p]);let c=[...gi(e.shape).map(p=>p/u),1].slice(0,s);return[l,i,u,c]}function xL(e,t,r){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${n}, and batchDim: ${o}.`;if(r.rank<o)throw new Error(s+` update.rank < ${o}. `);if(e.length<n+(r.rank-o))throw new Error(s+` Output shape length < ${n+(r.rank-o)}`);if(r.rank!==o+e.length-n)throw new Error(s+` update.rank != ${o+e.length-n}`);for(let i=0;i<o;++i)if(r.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${r.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<r.rank-o;++i)if(r.shape[i+o]!==e[i+n])throw new Error(s+` updates.shape[${i+o}] (${r.shape[i+o]}) != shape[${i+o}] (${e[i+o]})`)}function Ott(e,t,r){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(r.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${r}`);if(r.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}xL(r,t,e)}function Ftt(e,t,r){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=r.length,i=1;for(let p=o;p<s;++p)i*=r[p];let a=o<1?1:o,l=ee(t.shape)/a,u=[...gi(r.slice(0,o)),1],c=ee(r);return{sliceRank:o,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}var Er={};Zn(Er,{assertParamsValid:()=>Ltt,computeFlatOffset:()=>Wtt,computeOutShape:()=>ztt,getNormalizedAxes:()=>Btt,isSliceContinous:()=>Vtt,maskToAxes:()=>Mtt,parseSliceParams:()=>CE,sliceInfo:()=>Gtt,startForAxis:()=>TL,startIndicesWithElidedDims:()=>CL,stopForAxis:()=>NL,stopIndicesWithElidedDims:()=>SL,stridesForAxis:()=>kL,stridesWithElidedDims:()=>bL});var wE=-2,Ptt=-1;function Ltt(e,t,r){let n=e.shape.length;A(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),A(n===r.length,()=>`Error in slice${n}D: Length of size ${r} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)A(t[o]+r[o]<=e.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+r[o]}) would overflow input.shape[${o}] (${e.shape[o]})`)}function Mtt(e){let t=[],r=0;for(;e>0;)e&1&&t.push(r),e/=2,r++;return t}function ztt(e,t,r){let n=[];for(let o=0;o<e.length;o++)n[o]=Math.ceil((t[o]-e[o])/r[o]);return n}function bL(e,t,r,n){let o=[...e];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<r;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function vL(e,t,r){return r<=e?r:r-(t-1)}function wL(e,t){let r=[];for(let n=0;n<e;n++)r.push(t+n);return r}function Btt(e,t,r,n,o,s,i,a,l){let u=e.length,c=new Array(u),p=new Array(u),f=new Array(u);if(t.length&&r>0){let m=t[0],d=r+1;c=CL(i,m,d,n,e),p=SL(a,m,d,o,e),f=bL(s,m,d,e)}else for(let m=0;m<u;m++)c[m]=TL(i,n,s,e,m,l),p[m]=NL(a,o,s,e,m,l),f[m]=kL(s,m,l);return{begin:c,end:p,strides:f}}function CL(e,t,r,n,o){let s=[...o],i=wL(r,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let l=vL(t,r,a),u=n[l];e&1<<l&&(u=0),s[a]=u}return s}function SL(e,t,r,n,o){let s=[...o],i=wL(r,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let l=vL(t,r,a),u=n[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){let l=o[a];s[a]<0&&(s[a]+=l),s[a]=um(0,s[a],o[a])}return s}function kL(e,t,r){let n=e[t];return(r&1<<t||n==null)&&(n=1),n}function TL(e,t,r,n,o,s){let i=t[o],a=r[o]||1;(e&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=n[o];return i<0&&(i+=l),i=um(0,i,l-1),i}function NL(e,t,r,n,o,s){let i=t[o],a=r[o]||1;(e&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=n[o];return i<0&&(i+=l),a>0?i=um(0,i,l):i=um(-1,i,l-1),i}function Vtt(e,t,r){let n=r.length;for(let o=0;o<r.length;o++)if(r[o]>1){n=o;break}for(let o=n+1;o<r.length;o++)if(t[o]>0||r[o]!==e[o])return!1;return!0}function Wtt(e,t){let r=e.length>0?e[e.length-1]:1;for(let n=0;n<e.length-1;n++)r+=e[n]*t[n];return r}function CE(e,t,r){let n,o=e.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return r==null?s=new Array(o).fill(-1):typeof r=="number"?s=[r,...new Array(o-1).fill(-1)]:r.length<o?s=r.concat(new Array(o-r.length).fill(-1)):s=r,s=s.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),e.shape[a]-n[a])),[n,s]}function Gtt(e,t,r,n,o,s,i,a,l){let u;if(n==null?(u=new Array(t.length),u.fill(1)):u=n,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:r.slice(),strides:u.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<p.dims;b++)c&&(1<<b&a)!==0&&p.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Utt(p,f);let m=!0,d=!0,h=!0,x=[],g=[];for(let b=0;b<e.length;++b){if(f.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let v=!!(f.shrinkAxisMask&1<<b),C=e[b];if(C===-1){x.push(v?1:-1);continue}let S=[f.beginMask&1<<b,f.endMask&1<<b],k=[f.strides[b]>0?0:-1,f.strides[b]>0?C:C-1];if(v&&f.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&f.strides[b]===1;let I=!!(f.beginMask&1<<b&&f.endMask&1<<b);if(f.beginValid&&f.endValid){if(v){let U=f.begin[b]<0?C+f.begin[b]:f.begin[b];if(f.begin[b]=U,f.end[b]=f.begin[b]+1,U<0||U>=C)throw Error(`slice index ${f.begin[b]} of dimension ${b} out of bounds.`)}else f.begin[b]=yL(f.begin[b],0,f.strides[b],C,S,k),f.end[b]=yL(f.end[b],1,f.strides[b],C,S,k);let M=f.strides[b]===1&&f.begin[b]===0&&f.end[b]===C;m=m&&M,d=d&&(b===0&&f.strides[b]===1||M)}else m=m&&f.strides[b]===1&&I,d=d&&(b===0&&f.strides[b]===1||I);let D,R=!1;if(f.beginValid&&f.endValid?(D=f.end[b]-f.begin[b],R=!0):v?(D=1,R=!0):I&&C>=0&&(f.strides[b]<0?D=-C:D=C,R=!0),R){let M;D===0||D<0!=f.strides[b]<0?M=0:M=Math.trunc(D/f.strides[b])+(D%f.strides[b]!==0?1:0),x.push(M)}else x.push(-1)}for(let b=0;b<f.finalShapeGatherIndices.length;++b){let v=f.finalShapeGatherIndices[b];v>=0?g.push(x[v]):v===wE&&g.push(1)}return{finalShapeSparse:g.filter((b,v)=>f.finalShapeGatherIndices[v]!==wE),finalShape:g,isIdentity:m,sliceDim0:d,isSimpleSlice:h,begin:f.begin,end:f.end,strides:f.strides}}function Utt(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let r=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<e.dims;n++)if(1<<n&e.ellipsisMask){let o=Math.min(t.dims-(e.dims-n)+1+e.numAddAxisAfterEllipsis,t.dims);for(;r<o;r++)t.begin[r]=0,t.end[r]=0,t.strides[r]=1,t.beginMask|=1<<r,t.endMask|=1<<r,t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[r]=n}else if(1<<n&e.newAxisMask)t.finalShapeGatherIndices.push(wE),t.finalShapeGatherIndicesSparse.push(-1);else{if(r===t.begin.length)throw Error(`Index out of range using input dim ${r}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[r]=e.begin[n]),e.end!=null&&(t.end[r]=e.end[n]),t.strides[r]=e.strides[n],e.beginMask&1<<n&&(t.beginMask|=1<<r),e.endMask&1<<n&&(t.endMask|=1<<r),e.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(Ptt),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<r):(t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[r]=n,r++}}function yL(e,t,r,n,o,s){if(o[t])return r>0?s[t]:s[t+1&1];{let i=e<0?n+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var Z={};Zn(Z,{Serializable:()=>px,SerializationMap:()=>Ni,registerClass:()=>Vn});var px=class{getClassName(){return this.constructor.className}static fromConfig(t,r){return new t(r)}},Ni=class{constructor(){this.classNameMap={}}static getMap(){return Ni.instance==null&&(Ni.instance=new Ni),Ni.instance}static register(t){Ni.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Vn(e){A(e.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),A(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ni.register(e)}function Htt(e,t){let r=N(e,"a","add"),n=N(t,"b","add");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(Fs,o)}var tt=_({add_:Htt});function qtt(e,t){let r=N(e,"a","floorDiv"),n=N(t,"b","floorDiv");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(ka,o)}var Bw=_({floorDiv_:qtt});function jtt(e,t){let r=N(e,"a","div"),n=N(t,"b","div");if([r,n]=Gt(r,n),r.dtype==="int32"&&n.dtype==="int32")return Bw(r,n);let o={a:r,b:n},s={};return E.runKernel(ya,o,s)}var mt=_({div_:jtt});function Ktt(e,t){let r=N(e,"a","mul"),n=N(t,"b","mul");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(Oa,o)}var F=_({mul_:Ktt});function Xtt(e){let t=N(e,"x","abs");if(t.dtype==="complex64"){let r={x:t};return E.runKernel(uu,r)}else{let r={x:t};return E.runKernel(ru,r)}}var ir=_({abs_:Xtt});function Ytt(e){let r={x:N(e,"x","acos")};return E.runKernel(aa,r)}var SE=_({acos_:Ytt});function Qtt(e){let r={x:N(e,"x","acosh")};return E.runKernel(la,r)}var kE=_({acosh_:Qtt});function Ztt(e,t=null,r=!1){let o={x:N(e,"x","all","bool")},s={axis:t,keepDims:r};return E.runKernel(gm,o,s)}var fx=_({all_:Ztt});function Jtt(e,t=null,r=!1){let o={x:N(e,"x","any","bool")},s={axis:t,keepDims:r};return E.runKernel(xm,o,s)}var fd=_({any_:Jtt});function tet(e,t=0){let n={x:N(e,"x","argMax")},o={axis:t};return E.runKernel(nu,n,o)}var ol=_({argMax_:tet});function eet(e,t=0){let n={x:N(e,"x","argMin")},o={axis:t};return E.runKernel(ou,n,o)}var IL=_({argMin_:eet});function ret(e){let r={x:N(e,"x","asin")};return E.runKernel(ua,r)}var TE=_({asin_:ret});function net(e){let r={x:N(e,"x","asinh")};return E.runKernel(ca,r)}var NE=_({asinh_:net});function oet(e){let r={x:N(e,"x","atan")};return E.runKernel(pa,r)}var IE=_({atan_:oet});function set(e,t){let r=N(e,"a","atan2"),n=N(t,"b","atan2");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(ma,o)}var EL=_({atan2_:set});function iet(e){let r={x:N(e,"x","atanh")};return E.runKernel(fa,r)}var EE=_({atanh_:iet});function aet(e,t,r,n,o="NHWC",s){let i=e[3],a=[...t,i],l=AL(o);return Sp(e,a,r,s,n,null,null,l)}function AE(e,t,r,n,o,s,i="channelsLast"){let[a,l]=Vw(t),u;if(i==="channelsLast")u=[a,l,e[3],e[3]];else if(i==="channelsFirst")u=[a,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Sp(e,u,r,n,o,s,!1,i)}function uet(e,t,r,n,o,s,i="NDHWC"){let[a,l,u]=_E(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,l,u,e[4],e[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return _L(e,c,r,n,o,!1,p,s)}function Sp(e,t,r,n,o,s,i=!1,a="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p]=e;else if(a==="channelsFirst")[l,p,u,c]=e;else throw new Error(`Unknown dataFormat ${a}`);let[f,m,,d]=t,[h,x]=Vw(r),[g,y]=Vw(n),b=md(f,g),v=md(m,y),{padInfo:C,outHeight:S,outWidth:k}=fet(o,u,c,h,x,b,v,s,a),I=i?d*p:d,D;return a==="channelsFirst"?D=[l,I,S,k]:a==="channelsLast"&&(D=[l,S,k,I]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:p,outHeight:S,outWidth:k,outChannels:I,padInfo:C,strideHeight:h,strideWidth:x,filterHeight:f,filterWidth:m,effectiveFilterHeight:b,effectiveFilterWidth:v,dilationHeight:g,dilationWidth:y,inShape:e,outShape:D,filterShape:t}}function _L(e,t,r,n,o,s=!1,i="channelsLast",a){let[l,u,c,p,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p,f]=e;else if(i==="channelsFirst")[l,f,u,c,p]=e;else throw new Error(`Unknown dataFormat ${i}`);let[m,d,h,,x]=t,[g,y,b]=_E(r),[v,C,S]=_E(n),k=md(m,v),I=md(d,C),D=md(h,S),{padInfo:R,outDepth:M,outHeight:U,outWidth:j}=met(o,u,c,p,g,y,b,k,I,D,a),K=s?x*f:x,W;return i==="channelsFirst"?W=[l,K,M,U,j]:i==="channelsLast"&&(W=[l,M,U,j,K]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:p,inChannels:f,outDepth:M,outHeight:U,outWidth:j,outChannels:K,padInfo:R,strideDepth:g,strideHeight:y,strideWidth:b,filterDepth:m,filterHeight:d,filterWidth:h,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:D,dilationDepth:v,dilationHeight:C,dilationWidth:S,inShape:e,outShape:W,filterShape:t}}function cet(e,t,r,n,o){n==null&&(n=DE(e,t,r));let s=e[0],i=e[1],a=Cp((s-t+2*n)/r+1,o),l=Cp((i-t+2*n)/r+1,o);return[a,l]}function pet(e,t,r,n,o,s){o==null&&(o=DE(e,t,n));let i=e[0],a=e[1],l=e[2],u=Cp((i-t+2*o)/n+1,s),c=Cp((a-t+2*o)/n+1,s),p=Cp((l-t+2*o)/n+1,s);return[u,c,p,r]}function DE(e,t,r,n=1){let o=md(t,n);return Math.floor((e[0]*(r-1)-r+o)/2)}function Vw(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function _E(e){return typeof e=="number"?[e,e,e]:e}function md(e,t){return t<=1?e:e+(e-1)*(t-1)}function fet(e,t,r,n,o,s,i,a,l){let u,c,p;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let m=cet([t,r],s,n,e,a);c=m[0],p=m[1]}else if(e==="same"){c=Math.ceil(t/n),p=Math.ceil(r/o);let f=Math.max(0,(c-1)*n+s-t),m=Math.max(0,(p-1)*o+i-r),d=Math.floor(f/2),h=f-d,x=Math.floor(m/2),g=m-x;u={top:d,bottom:h,left:x,right:g,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((r-i+1)/o);else if(typeof e=="object"){let f=l==="channelsLast"?e[1][0]:e[2][0],m=l==="channelsLast"?e[1][1]:e[2][1],d=l==="channelsLast"?e[2][0]:e[3][0],h=l==="channelsLast"?e[2][1]:e[3][1];u={top:f,bottom:m,left:d,right:h,type:f===0&&m===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=Cp((t-s+f+m)/n+1,a),p=Cp((r-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:p}}function met(e,t,r,n,o,s,i,a,l,u,c){let p,f,m,d;if(typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let x=pet([t,r,n,1],a,1,o,e,c);f=x[0],m=x[1],d=x[2]}else if(e==="same"){f=Math.ceil(t/o),m=Math.ceil(r/s),d=Math.ceil(n/i);let h=(f-1)*o+a-t,x=(m-1)*s+l-r,g=(d-1)*i+u-n,y=Math.floor(h/2),b=h-y,v=Math.floor(x/2),C=x-v,S=Math.floor(g/2),k=g-S;p={top:v,bottom:C,left:S,right:k,front:y,back:b,type:"SAME"}}else if(e==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((t-a+1)/o),m=Math.ceil((r-l+1)/s),d=Math.ceil((n-u+1)/i);else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:f,outHeight:m,outWidth:d}}function Cp(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function _o(e){let[t,r,n]=Vw(e);return t===1&&r===1&&n===1}function Mr(e,t){return _o(e)||_o(t)}function AL(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ye(e,t,r){if(r!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);if(typeof t=="number")A(ia(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{A(ia(o),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${o}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function det(e,t){let n={x:N(e,"x","reshape","string_or_numeric")},o={shape:t};return E.runKernel(Fu,n,o)}var L=_({reshape_:det});function het(e,t,r,n,o){let s=N(e,"x","avgPool","float32"),i=1;A(Mr(r,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),ye("avgPool",n,o);let u={x:a},c={filterSize:t,strides:r,pad:n,dimRoundingMode:o},p=E.runKernel(su,u,c);return p=et(p,s.dtype),l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var kp=_({avgPool_:het});function get(e,t,r,n,o,s="NDHWC"){let i=N(e,"x","avgPool3d","float32"),a=i,l=!1;i.rank===4&&(l=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ye("avgPool3d",n,o);let u={x:a},c={filterSize:t,strides:r,pad:n,dimRoundingMode:o,dataFormat:s},p=E.runKernel(iu,u,c);return p=et(p,a.dtype),l?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var RE=_({avgPool3d_:get});function xet(e,t=0){A(e.length>=1,()=>"Pass at least one tensor to concat");let r=Ew(e,"tensors","concat","string_or_numeric");if(r[0].dtype==="complex64"&&r.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),r.length===1)return lo(r[0]);let n=r,o={axis:t};return E.runKernel(cu,n,o)}var Ce=_({concat_:xet});function yet(e){let r={x:N(e,"x","sigmoid","float32")};return E.runKernel(Ha,r)}var es=_({sigmoid_:yet});function bet(e,t,r){let n=N(e,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:r};return E.runKernel(Bu,o,s)}var Kt=_({slice_:bet});function vet(e){let r={x:N(e,"x","tanh","float32")};return E.runKernel(Qa,r)}var dd=_({tanh_:vet});function wet(e,t,r){let n=N(e,"x","batchToSpaceND"),o=t.reduce((a,l)=>a*l);A(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),A(r.length===t.length,()=>`crops.length is ${r.length} but should be equal to blockShape.length  ${t.length}`),A(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:r};return E.runKernel(lu,s,i)}var hd=_({batchToSpaceND_:wet});function DL(e){let t;return e.rank===0||e.rank===1?t=L(e,[1,1,1,e.size]):e.rank===2?t=L(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Cet(e,t,r,n,o,s){s==null&&(s=.001);let i=N(e,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(r,"variance","batchNorm"),u;o!=null&&(u=N(o,"scale","batchNorm"));let c;n!=null&&(c=N(n,"offset","batchNorm")),A(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let f={x:DL(i),scale:u,offset:c,mean:a,variance:l},m={varianceEpsilon:s},d=E.runKernel(yu,f,m);return L(d,i.shape)}var Zu=_({batchNorm_:Cet});function ket(e,t,r,n,o,s){let i=N(e,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(r,"variance","batchNorm"),u;o!=null&&(u=N(o,"scale","batchNorm"));let c;return n!=null&&(c=N(n,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Zu(i,a,l,c,u,s)}var $E=_({batchNorm2d_:ket});function Tet(e,t,r,n,o,s){let i=N(e,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(r,"variance","batchNorm"),u;o!=null&&(u=N(o,"scale","batchNorm"));let c;return n!=null&&(c=N(n,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Zu(i,a,l,c,u,s)}var OE=_({batchNorm3d_:Tet});function Net(e,t,r,n,o,s){let i=N(e,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(r,"variance","batchNorm"),u;o!=null&&(u=N(o,"scale","batchNorm"));let c;return n!=null&&(c=N(n,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Zu(i,a,l,c,u,s)}var FE=_({batchNorm4d_:Net});function Iet(e,t,r){let n=N(e,"x","bincount"),o=N(t,"weights","bincount");A(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),A(r>=0,()=>`size must be non-negative, but got ${r}.`),A(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:r};return E.runKernel(vm,s,i)}var RL=_({bincount_:Iet});function Eet(e,t){let r=N(e,"broadcastTo","x"),n=r.shape;if(Fr(t),t.length<r.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${r.rank}.`);if(t.length>r.rank){let u=r.shape.slice();for(;u.length<t.length;)u.unshift(1);r=L(r,u)}let o=r.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(o[u]===t[u])s[u]=1;else if(r.shape[u]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return lo(r);let a={x:r},l={reps:s};return E.runKernel(bi,a,l)}var sl=_({broadcastTo_:Eet});function _et(e){let r={x:N(e,"x","ceil","float32")};return E.runKernel(da,r)}var PE=_({ceil_:_et});function il(e,t,r){Fr(e);let n={shape:e,value:t,dtype:r};return E.runKernel(Om,{},n)}function Aet(e,t,r){let n=N(e,"x","clipByValue");if(A(t<=r,()=>`Error in clip: min (${t}) must be less than or equal to max (${r}).`),t===r)return il(n.shape,t,n.dtype);let o={x:n},s={clipValueMin:t,clipValueMax:r};return E.runKernel(ha,o,s)}var zr=_({clipByValue_:Aet});function Det(e){return Ce(e,0)}var LE=_({concat1d_:Det});function Ret(e,t){return Ce(e,t)}var ME=_({concat2d_:Ret});function $et(e,t){return Ce(e,t)}var zE=_({concat3d_:$et});function Oet(e,t){return Ce(e,t)}var BE=_({concat4d_:Oet});function Fet(e,t,r,n,o="NHWC",s=[1,1],i){let a=N(e,"x","conv2d","float32"),l=N(t,"filter","conv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ye("conv2d",n,i);let p=o==="NHWC"?u.shape[3]:u.shape[1];A(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),A(Mr(r,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`);let f={x:u,filter:l},m={strides:r,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=E.runKernel(pu,f,m);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var co=_({conv2d_:Fet});function Pet(e,t,r,n,o="NWC",s=1,i){let a=N(e,"x","conv1d"),l=N(t,"filter","conv1d"),u=a,c=!1;a.rank===2&&(c=!0,u=L(a,[1,a.shape[0],a.shape[1]])),A(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),A(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ye("conv1d",n,i),A(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),A(Mr(r,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${r} and dilation '${s}'`),A(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=L(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=L(u,[u.shape[0],1,u.shape[1],u.shape[2]]),x=co(f,p,[1,r],n,"NHWC",[1,s],i);return c?L(x,[x.shape[2],x.shape[3]]):L(x,[x.shape[0],x.shape[2],x.shape[3]])}var mx=_({conv1d_:Pet});function Let(e,t,r,n,o,s="NHWC",i){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,l=t,u=!1;t.rank===3&&(u=!0,l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,e[0],e[1],e[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),A(r.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${r.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?l.shape[3]:l.shape[1];A(c===r.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${r.shape[2]}.`),A(p===r.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${r.shape[3]}.`),ye("conv2dDerInput",o,i);let f={dy:l,filter:r},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=E.runKernel(fu,f,m);return u?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var gd=_({conv2DBackpropInput_:Let});function Met(e,t,r,n,o,s){let i=N(e,"x","conv2dTranspose"),a=N(t,"filter","conv2dTranspose");return gd(r,i,a,n,o,"NHWC",s)}var dx=_({conv2dTranspose_:Met});function zet(e,t,r,n,o="NDHWC",s=[1,1,1]){let i=N(e,"x","conv3d"),a=N(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A(Mr(r,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),A(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:l,filter:a},p={strides:r,pad:n,dataFormat:o,dilations:s},f=E.runKernel(mu,c,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var VE=_({conv3d_:zet});function Bet(e,t,r,n,o){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,a=!1;t.rank===4&&(a=!0,i=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(r.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${r.rank}`),A(l===r.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${r.shape[3]}.`),A(u===r.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${r.shape[4]}.`);let c={dy:i,filter:r},p={pad:o,strides:n,inputShape:s},f=E.runKernel(km,c,p);return a?L(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Ww=_({conv3DBackpropInput_:Bet});function Vet(e,t,r,n,o){let s=N(e,"x","conv3dTranspose"),i=N(t,"filter","conv3dTranspose");return Ww(r,s,i,n,o)}var WE=_({conv3dTranspose_:Vet});function Wet(e){let r={x:N(e,"x","cos","float32")};return E.runKernel(ga,r)}var Tp=_({cos_:Wet});function Get(e){let r={x:N(e,"x","cosh","float32")};return E.runKernel(xa,r)}var hx=_({cosh_:Get});function Uet(e,t=0,r=!1,n=!1){let s={x:N(e,"x","cumprod")},i={axis:t,exclusive:r,reverse:n};return E.runKernel(Tm,s,i)}var gx=_({cumprod_:Uet});function Het(e,t=0,r=!1,n=!1){let s={x:N(e,"x","cumsum")},i={axis:t,exclusive:r,reverse:n};return E.runKernel(du,s,i)}var Gw=_({cumsum_:Het});function qet(e,t,r,n=!1){let o=N(e,"x","denseBincount"),s=N(t,"weights","denseBincount");A(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),A(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),A(r>=0,()=>`size must be non-negative, but got ${r}.`),A(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:r,binaryOutput:n};return E.runKernel(Im,i,a)}var Uw=_({denseBincount_:qet});function jet(e,t,r="NHWC"){let n=N(e,"x","depthToSpace","float32"),o=r==="NHWC"?n.shape[1]:n.shape[2],s=r==="NHWC"?n.shape[2]:n.shape[3],i=r==="NHWC"?n.shape[3]:n.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},l={blockSize:t,dataFormat:r};return E.runKernel(Em,a,l)}var $L=_({depthToSpace_:jet});function Ket(e,t,r,n,o="NHWC",s=[1,1],i){let a=N(e,"x","depthwiseConv2d","float32"),l=N(t,"filter","depthwiseConv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p=o==="NHWC"?u.shape[3]:u.shape[1];A(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),ye("depthwiseConv2d",n,i);let f={x:u,filter:l},m={strides:r,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=E.runKernel(hu,f,m);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var al=_({depthwiseConv2d_:Ket});function Xet(e,t,r,n,o=[1,1],s="NHWC"){let i=N(e,"x","dilation2d"),a=N(t,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=L(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);let c={x:l,filter:a},p={strides:r,pad:n,dilations:o},f=E.runKernel(gu,c,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var OL=_({dilation2d_:Xet});function Yet(e,t){let r=N(e,"a","equal","string_or_numeric"),n=N(t,"b","equal","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(rp,o)}var kn=_({equal_:Yet});function Qet(e,t,r){let n=N(t,"a","where"),o=N(r,"b","where"),s=N(e,"condition","where","bool"),i=Pt(Pt(s.shape,n.shape),o.shape),a=sl(s,i),l=sl(n,i),u=sl(o,i),c={condition:a,t:l,e:u};return E.runKernel(zu,c)}var Ie=_({where_:Qet});function Zet(e){let r={x:N(e,"x","zerosLike")};return E.runKernel(ju,r)}var kt=_({zerosLike_:Zet});function Jet(e,t){let r=N(e,"a","div"),n=N(t,"b","div");[r,n]=Gt(r,n);let o=mt(r,n),s=kt(o),i=kn(n,s);return Ie(i,s,o)}var FL=_({divNoNan_:Jet});function trt(e,t){let r=N(e,"t1","dot"),n=N(t,"t2","dot");A((r.rank===1||r.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${r.rank} and ${n.rank}.`);let o=r.rank===1?r.size:r.shape[1],s=n.rank===1?n.size:n.shape[0];if(A(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),r.rank===1&&n.rank===1){let i=L(r,[1,-1]),a=L(n,[-1,1]),l=Qt(i,a);return L(l,[])}else if(r.rank===1&&n.rank===2){let i=L(r,[1,-1]),a=L(n,[n.shape[0],n.shape[1]]),l=Qt(i,a);return L(l,[l.size])}else if(r.rank===2&&n.rank===1){let i=L(n,[-1,1]),a=Qt(r,i);return L(a,[a.size])}else{let i=L(n,[n.shape[0],n.shape[1]]);return Qt(r,i)}}var PL=_({dot_:trt});function ert(e,...t){let r=t.map((o,s)=>N(o,`tensors${s}`,"einsum")),n={equation:e};return E.runKernel(Dm,r,n)}var xx=_({einsum_:ert});function rrt(e){let r={x:N(e,"x","elu","float32")};return E.runKernel(ba,r)}var ll=_({elu_:rrt});function nrt(e){let t=N(e,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=et(t,"float32"));let r={x:t};return E.runKernel(va,r)}var GE=_({erf_:nrt});function UE(e,t){for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0}function LL(e,t,r){let n=e.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)r.indexOf(a)===-1?o.push(e[s++]):o.push(t[i++]);return o}function HE(e,t){let r=[],n=e.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&r.push(e[s]);let o=t.map(s=>e[s]);return[r,o]}function Ii(e,t){let r=t.map(n=>1);return LL(e,r,t)}function ort(e,t,r){A(UE(t,r),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${r} input.`)}function qE(e,t){if(UE(e,t))return null;let r=[];for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);return e.forEach(n=>r.push(n)),r}function yx(e){return e.map((t,r)=>[r,t]).sort((t,r)=>t[1]-r[1]).map(t=>t[0])}function srt(e,t){let r=[];for(let n=t-e;n<t;++n)r.push(n);return r}function irt(e,t=null,r=!1){let o={x:N(e,"x","max")},s={reductionIndices:t,keepDims:r};return E.runKernel(Cu,o,s)}var Br=_({max_:irt});function art(e,t=null,r=!1){let o={x:N(e,"x","min")},s={axis:t,keepDims:r};return E.runKernel(Nu,o,s)}var Ju=_({min_:art});function lrt(e,t){let r=N(e,"base","pow"),n=N(t,"exp","pow");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(Fa,o)}var rs=_({pow_:lrt});function At(e,t){if((so(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&so(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ci(e,[],[],t)}function urt(e){let r={x:N(e,"x","sqrt","float32")};return E.runKernel(ja,r)}var Se=_({sqrt_:urt});function crt(e){let t=N(e,"x","square"),r={};return E.runKernel("Square",{x:t},r)}var Vt=_({square_:crt});function prt(e,t=null,r=!1){let n=N(e,"x","sum");n.dtype==="bool"&&(n=et(n,"int32"));let o={x:n},s={axis:t,keepDims:r};return E.runKernel(Vu,o,s)}var ht=_({sum_:prt});function frt(e,t="euclidean",r=null,n=!1){e=N(e,"x","norm");let o=ML(e,t,r),s=o.shape;if(n){let i=dr(r,e.shape);s=Ii(o.shape,i)}return L(o,s)}function ML(e,t,r=null){if(e.rank===0)return ir(e);if(e.rank!==1&&r===null)return ML(L(e,[-1]),t,r);if(e.rank===1||typeof r=="number"||Array.isArray(r)&&r.length===1){if(t===1)return ht(ir(e),r);if(t===1/0)return Br(ir(e),r);if(t===-1/0)return Ju(ir(e),r);if(t==="euclidean"||t===2)return Se(ht(rs(ir(e),At(2,"int32")),r));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(r)&&r.length===2){if(t===1)return Br(ht(ir(e),r[0]),r[1]-1);if(t===1/0)return Br(ht(ir(e),r[1]),r[0]);if(t===-1/0)return Ju(ht(ir(e),r[1]),r[0]);if(t==="fro"||t==="euclidean")return Se(ht(Vt(e),r));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${r}`)}var tc=_({norm_:frt});function mrt(e,t=null,r=!1){return tc(e,"euclidean",t,r)}var zL=_({euclideanNorm_:mrt});function drt(e){let r={x:N(e,"x","exp")};return E.runKernel(wa,r)}var Qr=_({exp_:drt});function hrt(e,t=0){let r=N(e,"x","expandDims","string_or_numeric");A(t<=r.rank,()=>"Axis must be <= rank of the tensor");let n={input:r},o={dim:t};return E.runKernel(xu,n,o)}var hr=_({expandDims_:hrt});function grt(e){let r={x:N(e,"x","expm1")};return E.runKernel(Ca,r)}var KE=_({expm1_:grt});function xrt(e,t){let r=N(e,"x","tile","string_or_numeric");A(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of reps ${t}.`);let n={x:r},o={reps:t};return E.runKernel(bi,n,o)}var Zr=_({tile_:xrt});function yrt(e,t,r,n="float32"){t==null&&(t=e);let o=Ct([e,t],n),s=e<=t?e:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=L(o.toTensor(),[e,t]);if(r==null)return i;if(r.length===1)return Zr(hr(i,0),[r[0],1,1]);if(r.length===2)return Zr(hr(hr(i,0),0),[r[0],r[1],1,1]);if(r.length===3)return Zr(hr(hr(hr(i,0),0),0),[r[0],r[1],r[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${r.length}D.`)}var xd=_({eye_:yrt});function brt(e){let r={x:N(e,"x","floor","float32")};return E.runKernel(Sa,r)}var ul=_({floor_:brt});function vrt(e,t,r=0,n=0){let o=N(e,"x","gather"),s=N(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:r,batchDims:n};return E.runKernel(bu,i,a)}var Np=_({gather_:vrt});function wrt(e,t){let r=N(e,"a","greater","string_or_numeric"),n=N(t,"b","greater","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(np,o)}var We=_({greater_:wrt});function Crt(e,t){let r=N(e,"a","greaterEqual","string_or_numeric"),n=N(t,"b","greaterEqual","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(Ta,o)}var Wn=_({greaterEqual_:Crt});function Srt(e){let r={x:N(e,"x","isFinite")};return E.runKernel(Na,r)}var XE=_({isFinite_:Srt});function krt(e){let r={x:N(e,"x","isInf")};return E.runKernel(Ia,r)}var YE=_({isInf_:krt});function Trt(e){let r={x:N(e,"x","isNaN")};return E.runKernel(Ea,r)}var QE=_({isNaN_:Trt});function Nrt(e,t=.2){let n={x:N(e,"x","leakyRelu")},o={alpha:t};return E.runKernel(vu,n,o)}var Ip=_({leakyRelu_:Nrt});function Irt(e,t){let r=N(e,"a","less","string_or_numeric"),n=N(t,"b","less","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(op,o)}var Hw=_({less_:Irt});function Ert(e,t){let r=N(e,"a","lessEqual","string_or_numeric"),n=N(t,"b","lessEqual","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(sp,o)}var ns=_({lessEqual_:Ert});function _rt(e,t=5,r=1,n=1,o=.5){let s=N(e,"x","localResponseNormalization");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),A(ia(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:r,alpha:n,beta:o},c=E.runKernel(wu,l,u);return a?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var BL=_({localResponseNormalization_:_rt});function Art(e){let r={x:N(e,"x","log","float32")};return E.runKernel(_a,r)}var Tn=_({log_:Art});function Drt(e){let r={x:N(e,"x","log1p")};return E.runKernel(Aa,r)}var bx=_({log1p_:Drt});function ZE(e,t){A(fm(e),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(u=>u instanceof Ja),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let r=t!=null;if(!r){t=[];for(let u in E.registeredVariables)t.push(E.registeredVariables[u])}let n=r?t.filter(u=>!u.trainable):null,o=t.length;t=t.filter(u=>u.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=E.gradients(e,t,null,s);A(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),n!=null&&n.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Do(e){return E.customGrad(e)}function Rrt(e){let r={x:N(e,"x","softplus")};return E.runKernel(qa,r)}var Ei=_({softplus_:Rrt});function $rt(e){let t=N(e,"x","logSigmoid");return Do(n=>({value:Zt(Ei(Zt(n))),gradFunc:i=>F(i,es(Zt(n)))}))(t)}var JE=_({logSigmoid_:$rt});function Ort(e,t){let r=N(e,"a","sub"),n=N(t,"b","sub");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel(Xa,o)}var yt=_({sub_:Ort});function Frt(e,t=-1){let r=N(e,"logits","logSoftmax");if(t===-1&&(t=r.rank-1),t!==r.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and axis was ${t}`);return Do((o,s)=>{let a=Br(o,t,!0),l=yt(o,a),u=yt(et(l,"float32"),Tn(ht(Qr(l),t,!0)));return s([u]),{value:u,gradFunc:(p,f)=>{let[m]=f,d=!0,h=Qr(m);return yt(p,F(ht(p,t,d),h))}}})(r)}var vx=_({logSoftmax_:Frt});function Prt(e,t=null,r=!1){let n=N(e,"x","logSumExp"),o=dr(t,n.shape),s=Br(n,o,!0),i=yt(n,s),a=Qr(i),l=ht(a,o),u=Tn(l),c=tt(L(s,u.shape),u);if(r){let p=Ii(c.shape,o);return L(c,p)}return c}var VL=_({logSumExp_:Prt});function Lrt(e,t){let r=N(e,"a","logicalAnd","bool"),n=N(t,"b","logicalAnd","bool");Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(ip,o)}var cn=_({logicalAnd_:Lrt});function Mrt(e){let r={x:N(e,"x","logicalNot","bool")};return E.runKernel(ap,r)}var yd=_({logicalNot_:Mrt});function zrt(e,t){let r=N(e,"a","logicalOr","bool"),n=N(t,"b","logicalOr","bool");Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(lp,o)}var qw=_({logicalOr_:zrt});function Brt(e,t){let r=N(e,"a","logicalXor","bool"),n=N(t,"b","logicalXor","bool");return Pt(r.shape,n.shape),cn(qw(e,t),yd(cn(e,t)))}var WL=_({logicalXor_:Brt});function Vrt(e,t,r,n,o){let s=N(e,"x","maxPool"),i=1,a=s,l=!1;s.rank===3&&(l=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A(Mr(r,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`),ye("maxPool",n,o);let u={x:a},c={filterSize:t,strides:r,pad:n,dimRoundingMode:o},p=E.runKernel(Su,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ep=_({maxPool_:Vrt});function Wrt(e,t=[1,1,1],r,n,o,s="NDHWC"){let i=N(e,"x","maxPool3d"),a=i,l=!1;i.rank===4&&(l=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ye("maxPool3d",n,o);let u={x:a},c={filterSize:t,strides:r,pad:n,dimRoundingMode:o,dataFormat:s},p=E.runKernel(ku,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var t_=_({maxPool3d_:Wrt});function Grt(e,t){let r=N(e,"a","maximum"),n=N(t,"b","maximum");[r,n]=Gt(r,n),r.dtype==="bool"&&(r=et(r,"int32"),n=et(n,"int32")),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(Da,o)}var po=_({maximum_:Grt});function Urt(e,t=null,r=!1){let o={x:N(e,"x","mean")},s={axis:t,keepDims:r};return E.runKernel(Tu,o,s)}var Ee=_({mean_:Urt});function ke(e,t="float32"){if(Fr(e),t==="complex64"){let n=ke(e,"float32"),o=ke(e,"float32");return Eo(n,o)}let r=dm(ee(e),t);return E.makeTensor(r,e,t)}function fo(e,t="float32"){if(Fr(e),t==="complex64"){let n=fo(e,"float32"),o=ke(e,"float32");return Eo(n,o)}let r=jg(ee(e),t);return E.makeTensor(r,e,t)}function Hrt(e,t){let r=N(e,"a","minimum"),n=N(t,"b","minimum");[r,n]=Gt(r,n),r.dtype==="bool"&&(r=et(r,"int32"),n=et(n,"int32")),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(Ra,o)}var _p=_({minimum_:Hrt});function qrt(e,t,r){A(r==="reflect"||r==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${r}.`);let n=N(e,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=r==="reflect"?1:0;for(let a=0;a<n.rank;a++)A(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:r},i={x:n};return E.runKernel(Iu,i,s)}var GL=_({mirrorPad_:qrt});function jrt(e,t){let r=N(e,"a","mod"),n=N(t,"b","mod");[r,n]=Gt(r,n);let o={a:r,b:n};return E.runKernel($a,o)}var UL=_({mod_:jrt});function Krt(e,t=null,r=!1){e=N(e,"x","moments");let n=dr(t,e.shape),o=Ee(e,n,r),s=o.shape;r||(s=Ii(o.shape,n));let i=Vt(yt(et(e,"float32"),L(o,s))),a=Ee(i,n,r);return{mean:o,variance:a}}var bd=_({moments_:Krt});function Xrt(e,t){let r=N(e,"a","notEqual","string_or_numeric"),n=N(t,"b","notEqual","string_or_numeric");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n};return E.runKernel(up,o)}var ec=_({notEqual_:Xrt});function Yrt(e){let r={x:N(e,"x","onesLike")};return E.runKernel(_u,r)}var _r=_({onesLike_:Yrt});function Qrt(e,t,r=0){let n=N(e,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:r},s={x:n};return E.runKernel(Ru,s,o)}var Ap=_({pad_:Qrt});function Zrt(e,t,r){let n=N(e,"x","spaceToBatchND");A(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),A(r.length===t.length,()=>`paddings.shape[0] ${r.length} must be equal to [blockShape] ${t.length}`),A(n.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+r[l-1][0]+r[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${r.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:r};return E.runKernel(Wu,o,s)}var vd=_({spaceToBatchND_:Zrt});function Jrt(e,t,r,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=N(e,"x","maxPool"),l=a,u=!1;a.rank===3&&(u=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(Mr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=AE(l.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],f;n==="same"?f=ent([c.filterHeight,c.filterWidth],p):f=[[0,0],[0,0]];let m=p[0]===1&&p[1]===1,[d,h]=tnt([c.inHeight,c.inWidth],p,f),x=m?n:"valid",g=m?l:vd(l,p,d),b=(r==="avg"?()=>kp(g,t,s,x,i):()=>Ep(g,t,s,x,i))(),v=m?b:hd(b,p,h);return u?L(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function tnt(e,t,r){let n=r.map(c=>c[0]),o=r.map(c=>c[1]),s=e.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),l=t.map((c,p)=>[n[p],a[p]]),u=t.map((c,p)=>[0,i[p]]);return[l,u]}function ent(e,t){let n=e.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var HL=_({pool_:Jrt});function rnt(e,t){let r=N(e,"x","prelu"),n=N(t,"alpha","prelu"),o={x:r,alpha:n};return E.runKernel($u,o)}var Dp=_({prelu_:rnt});function nnt(e,t=null,r=!1){let n=N(e,"x","prod");n.dtype==="bool"&&(n=et(n,"int32"));let o={x:n},s={axis:t,keepDims:r};return E.runKernel(Ou,o,s)}var qL=_({prod_:nnt});var a_=Yt(wx());var wd=class{constructor(t,r,n,o,s){this.mean=t,this.stdDev=r,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=a_.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,r,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,r=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(r))&&(this.nextVal=this.convertValue(r)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}};var Kw=class{constructor(t=0,r=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=r-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${r} <= 1 and dtype is not float`);this.random=a_.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function cnt(e,t=0,r=1,n,o){if(Fr(e),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new wd(t,r,n,!1,o),i=Ct(e,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Xw=_({randomNormal_:cnt});function pnt(e,t=0,r=1,n="float32",o){Fr(e);let s=Ct(e,n),i=new Kw(t,r,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var cl=_({randomUniform_:pnt});function pl(e,t,r=1,n="float32"){if(r===0)throw new Error("Cannot have a step of zero");let o={start:e,stop:t,step:r,dtype:n};return E.runKernel(Um,{},o)}function fnt(e){let r={x:N(e,"x","reciprocal")};return E.runKernel(Pa,r)}var l_=_({reciprocal_:fnt});function mnt(e){let r={x:N(e,"x","relu")};return E.runKernel(La,r)}var mo=_({relu_:mnt});function dnt(e){let r={x:N(e,"x","relu6")};return E.runKernel(Ma,r)}var Yw=_({relu6_:dnt});function hnt(e,t){let n={x:N(e,"x","reverse")},o={dims:t};return E.runKernel(Mu,n,o)}var Ro=_({reverse_:hnt});function gnt(e){let r={x:N(e,"x","round")};return E.runKernel(za,r)}var Cx=_({round_:gnt});function xnt(e){let r={x:N(e,"x","rsqrt","float32")};return E.runKernel(Ba,r)}var Sx=_({rsqrt_:xnt});function ynt(e){let r={x:N(e,"x","selu")};return E.runKernel(Va,r)}var kx=_({selu_:ynt});function bnt(e,t,r,n,o,s=[1,1],i="NHWC"){let a=N(e,"x","separableConv2d"),l=N(t,"depthwiseFilter","separableConv2d"),u=N(r,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),A(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let f=l.shape[2],m=l.shape[3];A(u.shape[2]===f*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*m}, but got ${u.shape[2]}.`);let d=al(c,l,n,o,i,s),x=co(d,u,1,"valid",i);return p?L(x,[x.shape[1],x.shape[2],x.shape[3]]):x}var Tx=_({separableConv2d_:bnt});function vnt(e){let r={x:N(e,"x","sign")};return E.runKernel(Ua,r)}var u_=_({sign_:vnt});function wnt(e){let r={x:N(e,"x","sin","float32")};return E.runKernel(Wa,r)}var Nx=_({sin_:wnt});function Cnt(e){let r={x:N(e,"x","sinh")};return E.runKernel(Ga,r)}var Ix=_({sinh_:Cnt});function Snt(e,t,r){let n=N(e,"x","slice1d");return A(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Kt(n,[t],[r])}var Ex=_({slice1d_:Snt});function knt(e,t,r){let n=N(e,"x","slice2d");return A(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Kt(n,t,r)}var Qw=_({slice2d_:knt});function Tnt(e,t,r){let n=N(e,"x","slice3d");return A(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Kt(n,t,r)}var _x=_({slice3d_:Tnt});function Nnt(e,t,r){let n=N(e,"x","slice4d");return A(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Kt(n,t,r)}var Cd=_({slice4d_:Nnt});function Int(e,t=-1){let r=N(e,"logits","softmax","float32");if(t===-1&&(t=r.rank-1),t!==r.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and dim was ${t}`);let n={logits:r},o={dim:t};return E.runKernel(Uu,n,o)}var $p=_({softmax_:Int});function Ent(e){A(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return E.runKernel($m,t)}var Ax=_({fft_:Ent});function _nt(e){A(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return E.runKernel(Pm,t)}var Sd=_({ifft_:_nt});function Ant(e){let t=e.shape[e.shape.length-1],r=e.size/t,n;if(t<=2){let o=L(e,[r,t]);n=Sd(o)}else{let o=[r,2*(t-1)],s=L(vp(e),[r,t]),i=L(pd(e),[r,t]),a=Ro(Kt(s,[0,1],[r,t-2]),1),l=F(Ro(Kt(i,[0,1],[r,t-2]),1),At(-1)),u=Ce([s,a],1),c=Ce([i,l],1),p=L(Eo(u,c),[o[0],o[1]]);n=Sd(p)}if(n=vp(n),e.rank===3&&e.shape[0]!==0){let o=n,s=e.shape[0];n=L(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var c_=_({irfft_:Ant});function Dnt(e,t,r=0){let o={x:N(e,"x","split")},s={numOrSizeSplits:t,axis:r};return E.runKernel(Gu,o,s)}var wr=_({split_:Dnt});function Rnt(e,t){A(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let r=e.shape[e.shape.length-1],n=e.size/r,o;if(t!=null&&t<r){let d=e.shape.map(x=>0),h=e.shape.map(x=>x);h[e.shape.length-1]=t,o=Kt(e,d,h),r=t}else if(t!=null&&t>r){let d=e.shape.map(h=>h);d[e.shape.length-1]=t-r,o=Ce([e,ke(d)],e.shape.length-1),r=t}else o=e;let s=kt(o),i=L(Eo(o,s),[n,r]),a=Ax(i),l=Math.floor(r/2)+1,u=vp(a),c=pd(a),p=wr(u,[l,r-l],u.shape.length-1),f=wr(c,[l,r-l],c.shape.length-1),m=o.shape.slice();return m[o.shape.length-1]=l,L(Eo(p[0],f[0]),m)}var p_=_({rfft_:Rnt});function $nt(e,t){let r=N(e,"a","squaredDifference"),n=N(t,"b","squaredDifference");[r,n]=Gt(r,n),Pt(r.shape,n.shape);let o={a:r,b:n},s={};return E.runKernel(Ka,o,s)}var uM=_({squaredDifference_:$nt});function Ont(e,t){let r=N(e,"x","squeeze","string_or_numeric");return L(r,OI(r.shape,t).newShape)}var Ms=_({squeeze_:Ont});function Fnt(e,t=0){let r=Ew(e,"tensors","stack","string_or_numeric");A(r.length>=1,()=>"Pass at least one tensor to tf.stack"),r.length>0&&A(t<=r[0].rank,()=>"Axis must be <= rank of the tensor");let n=r,o={axis:t};return E.runKernel(Du,n,o)}var Cr=_({stack_:Fnt});function Pnt(e,t=0){let n={x:N(e,"x","step")},o={alpha:t};return E.runKernel(Za,n,o)}var zs=_({step_:Pnt});function Lnt(e,t,r,n,o=0,s=0,i=0,a=0,l=0){let c={x:N(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:r,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return E.runKernel(Xm,c,p)}var f_=_({stridedSlice_:Lnt});function Mnt(e){let r={x:N(e,"x","tan","float32")};return E.runKernel(Ya,r)}var m_=_({tan_:Mnt});function gr(e,t){tp(e);let r=tl(e,t);if(r.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ci(e,null,r,t)}function Dx(e,t,r){if(tp(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=tl(e,r);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ci(e,t,n,r)}function znt(e,t=1,r=!0){let n=N(e,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:r},[a,l]=E.runKernel(Ym,s,i);return{values:a,indices:l}}var cM=_({topk_:znt});function Bnt(e,t=0,r=1,n,o){if(Fr(e),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new wd(t,r,n,!0,o),i=Ct(e,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Rx=_({truncatedNormal_:Bnt});function Vnt(e,t=0){let r=N(e,"x","unique","string_or_numeric");A(r.rank>0,()=>"The input tensor must be at least 1D");let n={x:r},o={axis:t},[s,i]=E.runKernel(Zm,n,o);return{values:s,indices:i}}var pM=_({unique_:Vnt});function Wnt(e,t,r){let n=N(e,"x","unsortedSegmentSum"),o=N(t,"segmentIds","unsortedSegmentSum","int32");A(ia(r),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:r};return E.runKernel(qu,s,i)}var Zw=_({unsortedSegmentSum_:Wnt});function Gnt(e,t=0){let r=N(e,"x","unstack","string_or_numeric");A(t>=-r.shape.length&&t<r.shape.length,()=>`Axis = ${t} is not in [-${r.shape.length}, ${r.shape.length})`);let n={value:r},o={axis:t};return E.runKernel(Hu,n,o)}var pn=_({unstack_:Gnt});function d_(e,t=!0,r,n){return E.makeVariable(e,t,r,n)}function fM(e,t){let r=[];for(let s=0;s<t.length;s++)t[s]&&r.push(s);let n=Ct(e,"int32"),o=Ct([r.length,e.length],"int32");for(let s=0;s<r.length;s++){let i=n.indexToLoc(r[s]),a=s*e.length;o.values.set(i,a)}return o.toTensor()}function mM(e,t){if(t==null)return e.shape.slice();if(eu(e.shape,t))return t;if(e.shape.length===t.length){let r=[];for(let n=0;n<e.shape.length;n++)t[n]==null&&e.shape[n]!=null?r.push(e.shape[n]):r.push(t[n]);return r}return t}function Unt(e,t,r,n){let o=N(e,"x","dropout");if(A(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof qt?o.clone():o;let s=mM(o,r),i=1-t,a=mt(ul(tt(cl(s,0,1,"float32",n),i)),i);return F(o,a)}var dM=_({dropout_:Unt});var Mp={};Zn(Mp,{conv2d:()=>hM,depthwiseConv2d:()=>gM,matMul:()=>xM});function Hnt(e,t,r,n,o,s="NHWC",i){let a=e;e.rank===3&&(a=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),A(r.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${r}.`);let u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];A(u===r[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${r[2]}.`),A(c===r[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${r[3]}).`),ye("conv2dDerFilter",o,i);let p={x:a,dy:l},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:r};return E.runKernel(Cm,p,f)}var kd=_({conv2DBackpropFilter_:Hnt});function Op(e,t,r){if(r==null||r==="linear")return e;if(r==="relu")return F(e,zs(t));throw new Error(`Cannot compute gradient for fused activation ${r}.`)}function Fp(e,t){let r=t,n=pe(e.shape,t.shape);return n.length>0&&(r=ht(r,n)),L(r,e.shape)}function Pp(e,t,r,n){if(t==="linear")return e;if(t==="relu")return mo(e);if(t==="elu")return ll(e);if(t==="relu6")return Yw(e);if(t==="prelu")return Dp(e,r);if(t==="leakyrelu")return Ip(e,n);if(t==="sigmoid")return es(e);throw new Error(`Unknown fused activation ${t}.`)}var Lp=(e,t)=>!(e>0)||t==="linear";function qnt({x:e,filter:t,strides:r,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Lp(E.state.gradientDepth,l)===!1){A(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=co(e,t,r,n,o,s,i);return a!=null&&(S=tt(S,a)),Pp(S,l,u,c)}let p=N(e,"x","conv2d","float32"),f=N(t,"filter","conv2d","float32"),m=p,d=!1;p.rank===3&&(d=!0,m=L(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),A(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),ye("fused conv2d",n,i);let h=o==="NHWC"?m.shape[3]:m.shape[1];A(f.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${f.shape[2]}.`),A(Mr(r,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`);let x=Sp(m.shape,f.shape,r,s,n,i),g;a!=null&&(g=N(a,"bias","fused conv2d"),[g]=Gt(g,p),o==="NHWC"?Pt(x.outShape,g.shape):(A(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),A(g.shape.length===0||g.shape[0]===x.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let y;if(u!=null){let S=u.shape;if(A(S.length<=1||S.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),S.length===1)A(S[0]===1||S[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${x.outChannels}).`);else if(S.length===3)try{Pt(S,x.outShape)}catch(k){let I=`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(I)}y=N(u,"prelu weights","fused conv2d")}let b=(S,k)=>{A(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[I,D,R,M]=k,U=Op(S,R,l);A(_o(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let j=gd(D.shape,U,I,r,n),K=kd(D,U,I.shape,r,n),W=[j,K];if(M!=null){let q=Fp(M,U);W.push(q)}return W},v={x:m,filter:f,bias:g,preluActivationWeights:y},C={strides:r,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Do((k,I,D)=>{let R=E.runKernel(pp,v,C);return D([I,k,R]),d&&(R=L(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(m,f):Do((k,I,D,R)=>{let M=E.runKernel(pp,v,C);return R([I,k,M,D]),d&&(M=L(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(m,f,g)}var hM=_({fusedConv2d_:qnt});function jnt(e,t,r,n,o,s=[1,1],i){let a=e;e.rank===3&&(a=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:a,dy:l},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:r};return E.runKernel(_m,u,c)}var Jw=_({depthwiseConv2dNativeBackpropFilter_:jnt});function Knt(e,t,r,n,o,s=[1,1],i){let a=t,l=!1;t.rank===3&&(l=!0,a=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:a,filter:r},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:e},p=E.runKernel(Am,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var t1=_({depthwiseConv2dNativeBackpropInput_:Knt});function Xnt({x:e,filter:t,strides:r,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Lp(E.state.gradientDepth,l)===!1){let C=al(e,t,r,n,o,s,i);return a!=null&&(C=tt(C,a)),Pp(C,l,u,c)}let p=N(e,"x","depthwiseConv2d","float32"),f=N(t,"filter","depthwiseConv2d","float32"),m=p,d=!1;p.rank===3&&(d=!0,m=L(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),A(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),A(m.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),A(Mr(r,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),ye("fused depthwiseConv2d",n,i);let h=Sp(m.shape,f.shape,r,s,n,i,!0),x;a!=null&&(x=N(a,"bias","fused conv2d"),[x]=Gt(x,p),Pt(h.outShape,x.shape));let g;u!=null&&(g=N(u,"prelu weights","fused depthwiseConv2d"));let y=(C,S)=>{A(_o(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[k,I,D,R]=S,M=Op(C,D,l),U=t1(I.shape,M,k,r,n,s,i),j=Jw(I,M,k.shape,r,n,s,i);if(R!=null){let K=Fp(x,M);return[U,j,K]}return[U,j]},b={x:m,filter:f,bias:x,preluActivationWeights:g},v={strides:r,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Do((S,k,I)=>{let D=E.runKernel(fp,b,v);return I([k,S,D]),d&&(D=L(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:y}})(m,f):Do((S,k,I,D)=>{let R=E.runKernel(fp,b,v);return D([k,S,R,I]),d&&(R=L(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:y}})(m,f,x)}var gM=_({fusedDepthwiseConv2d_:Xnt});function Ynt({a:e,b:t,transposeA:r=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Lp(E.state.gradientDepth,s)===!1){let M=Qt(e,t,r,n);return o!=null&&(M=tt(M,o)),Pp(M,s,i,a)}let l=N(e,"a","fused matMul"),u=N(t,"b","fused matMul");[l,u]=Gt(l,u);let c=r?l.shape[l.rank-2]:l.shape[l.rank-1],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],f=r?l.shape[l.rank-1]:l.shape[l.rank-2],m=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=l.shape.slice(0,-2),h=u.shape.slice(0,-2),x=ee(d),g=ee(h);A(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${r} and transposeB=${n} must match.`);let b=Pt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,m]),v=r?L(l,[x,c,f]):L(l,[x,f,c]),C=n?L(u,[g,m,p]):L(u,[g,p,m]),S;o!=null&&(S=N(o,"bias","fused matMul"),[S]=Gt(S,l),Pt(b,S.shape));let k;i!=null&&(k=N(i,"prelu weights","fused matMul"));let I=(M,U)=>{let[j,K,W,q]=U,X=Op(L(M,W.shape),W,s),Q,Y;if(!r&&!n?(Q=Qt(X,K,!1,!0),Y=Qt(j,X,!0,!1)):!r&&n?(Q=Qt(X,K,!1,!1),Y=Qt(X,j,!0,!1)):r&&!n?(Q=Qt(K,X,!1,!0),Y=Qt(j,X,!1,!1)):(Q=Qt(K,X,!0,!0),Y=Qt(X,j,!0,!0)),o!=null){let nt=Fp(q,X);return[Q,Y,nt]}else return[Q,Y]},D={a:v,b:C,bias:S,preluActivationWeights:k},R={transposeA:r,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?Do((U,j,K)=>{let W=E.runKernel(cp,D,R);return K([U,j,W]),{value:L(W,b),gradFunc:I}})(v,C):Do((U,j,K,W)=>{let q=E.runKernel(cp,D,R);return W([U,j,q,K]),{value:L(q,b),gradFunc:I}})(v,C,S)}var xM=_({fusedMatMul_:Ynt});function Qnt(e,t,r,n,o="bilinear",s=0){let i=N(e,"image","cropAndResize"),a=N(t,"boxes","cropAndResize","float32"),l=N(r,"boxInd","cropAndResize","int32"),u=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),A(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),A(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),A(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),A(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:l},p={method:o,extrapolationValue:s,cropSize:n};return E.runKernel(Nm,c,p)}var yM=_({cropAndResize_:Qnt});function Znt(e){let t=N(e,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let r={image:t};return E.runKernel(Fm,r,{})}var bM=_({flipLeftRight_:Znt});function Jnt(e){let t=N(e,"image","grayscaleToRGB"),r=t.rank-1,n=t.shape[r];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,r),o[r]=3,Zr(t,o)}var vM=_({grayscaleToRGB_:Jnt});function tot(e,t,r=0,n=.5){let o=N(e,"image","rotateWithOffset","float32");A(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:r,center:n};return E.runKernel(Jm,s,i)}var wM=_({rotateWithOffset_:tot});function os(e,t,r,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return r=Math.min(r,i),A(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),A(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),A(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:r,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function eot(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY){let s=N(e,"boxes","nonMaxSuppression","float32"),i=N(t,"scores","nonMaxSuppression","float32"),a=os(s,i,r,n,o);r=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let l={maxOutputSize:r,iouThreshold:n,scoreThreshold:o};return E.runKernel(Vm,{boxes:s,scores:i},l)}var CM=_({nonMaxSuppression_:eot});function SM(e,t,r){let n=rot(e,t,r),o=n<0?-(n+1):n;e.splice(o,0,t)}function rot(e,t,r){return oot(e,t,r||not)}function not(e,t){return e>t?1:e<t?-1:0}function oot(e,t,r){let n=0,o=e.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=r(t,e[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function e1(e,t,r,n,o){return h_(e,t,r,n,o,0)}function r1(e,t,r,n,o,s){return h_(e,t,r,n,o,0,!1,s,!0)}function n1(e,t,r,n,o,s){return h_(e,t,r,n,o,s,!0)}function h_(e,t,r,n,o,s,i=!1,a=!1,l=!1){let u=[];for(let x=0;x<t.length;x++)t[x]>o&&u.push({score:t[x],boxIndex:x,suppressBeginIndex:0});u.sort(kM);let c=s>0?-.5/s:0,p=[],f=[];for(;p.length<r&&u.length>0;){let x=u.pop(),{score:g,boxIndex:y,suppressBeginIndex:b}=x;if(g<o)break;let v=!1;for(let C=p.length-1;C>=b;--C){let S=sot(e,y,p[C]);if(S>=n){v=!0;break}if(x.score=x.score*iot(n,c,S),x.score<=o)break}x.suppressBeginIndex=p.length,v||(x.score===g?(p.push(y),f.push(x.score)):x.score>o&&SM(u,x,kM))}let m=p.length,d=r-m;a&&d>0&&(p.push(...new Array(d).fill(0)),f.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=f),l&&(h.validOutputs=m),h}function sot(e,t,r){let n=e.subarray(t*4,t*4+4),o=e.subarray(r*4,r*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),u=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),m=(a-s)*(l-i),d=(p-u)*(f-c);if(m<=0||d<=0)return 0;let h=Math.max(s,u),x=Math.max(i,c),g=Math.min(a,p),y=Math.min(l,f),b=Math.max(g-h,0)*Math.max(y-x,0);return b/(m+d-b)}function iot(e,t,r){let n=Math.exp(t*r*r);return r<=e?n:0}function kM(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function aot(s,i,a){return H(this,arguments,function*(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY){let l=N(e,"boxes","nonMaxSuppressionAsync"),u=N(t,"scores","nonMaxSuppressionAsync"),c=os(l,u,r,n,o);r=c.maxOutputSize,n=c.iouThreshold,o=c.scoreThreshold;let p=yield Promise.all([l.data(),u.data()]),f=p[0],m=p[1],{selectedIndices:d}=e1(f,m,r,n,o);return l!==e&&l.dispose(),u!==t&&u.dispose(),gr(d,"int32")})}var TM=aot;function lot(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=N(e,"boxes","nonMaxSuppression"),a=N(t,"scores","nonMaxSuppression"),l=os(i,a,r,n,o,s);r=l.maxOutputSize,n=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:a},c={maxOutputSize:r,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=E.runKernel(Gm,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var NM=_({nonMaxSuppressionWithScore_:lot});function uot(i,a,l){return H(this,arguments,function*(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let u=N(e,"boxes","nonMaxSuppressionAsync"),c=N(t,"scores","nonMaxSuppressionAsync"),p=os(u,c,r,n,o,s);r=p.maxOutputSize,n=p.iouThreshold,o=p.scoreThreshold,s=p.softNmsSigma;let f=yield Promise.all([u.data(),c.data()]),m=f[0],d=f[1],{selectedIndices:h,selectedScores:x}=n1(m,d,r,n,o,s);return u!==e&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:gr(h,"int32"),selectedScores:gr(x)}})}var IM=uot;function cot(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=N(e,"boxes","nonMaxSuppression"),a=N(t,"scores","nonMaxSuppression"),l=os(i,a,r,n,o,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,f={boxes:i,scores:a},m={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=E.runKernel(Wm,f,m);return{selectedIndices:d[0],validOutputs:d[1]}}var EM=_({nonMaxSuppressionPadded_:cot});function pot(i,a,l){return H(this,arguments,function*(e,t,r,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let u=N(e,"boxes","nonMaxSuppressionAsync"),c=N(t,"scores","nonMaxSuppressionAsync"),p=os(u,c,r,n,o,null),f=p.maxOutputSize,m=p.iouThreshold,d=p.scoreThreshold,[h,x]=yield Promise.all([u.data(),c.data()]),{selectedIndices:g,validOutputs:y}=r1(h,x,f,m,d,s);return u!==e&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:gr(g,"int32"),validOutputs:At(y,"int32")}})}var _M=pot;function fot(e,t,r=!1,n=!1){let o=N(e,"images","resizeBilinear");A(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(n===!1||r===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},l={alignCorners:r,halfPixelCenters:n,size:t},u=E.runKernel(Lu,a,l);return i?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var o1=_({resizeBilinear_:fot});function mot(e,t,r=!1,n=!1){let o=N(e,"images","resizeNearestNeighbor");A(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(n===!1||r===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},l={alignCorners:r,halfPixelCenters:n,size:t},u=E.runKernel(Pu,a,l);return i?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var s1=_({resizeNearestNeighbor_:mot});function dot(e,t="binary",r=!1,n=.5){let o=N(e,"image","threshold"),s=.2989,i=.587,a=.114,l=o.shape[0]*o.shape[1],u=F(gr([n]),255),c,p,f,m;if(A(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),A(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),A(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,f]=wr(o,[1,1,1],-1);let x=F(c,s),g=F(p,i),y=F(f,a);m=tt(tt(x,g),y)}else m=e;if(t==="otsu"){let x=RL(et(Cx(m),"int32"),sr([]),256);u=hot(x,l)}let d=r?ns(m,u):We(m,u);return et(F(d,255),"int32")}function hot(e,t){let r=gr([-1]),n=gr([0]),o=gr([0]),s,i,a,l,u,c;for(let p=0;p<e.size-1;p++){s=Kt(e,0,p+1),i=Kt(e,p+1),u=mt(ht(s),t),c=mt(ht(i),t);let f=ht(F(s,pl(0,s.size)));a=mt(f,ht(s));let m=il(i.shape,s.size),d=tt(pl(0,i.size),m),h=F(i,d);l=mt(ht(h),ht(i));let x=yt(a,l),g=yt(a,l),y=F(u,c);o=F(F(y,x),g);let b=We(o,n);n=Ie(b,o,n),r=Ie(b,gr([p]),r)}return r}var AM=_({threshold_:dot});function got(e,t,r="nearest",n="constant",o=0,s){let i=N(e,"image","transform","float32"),a=N(t,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:a},u={interpolation:r,fillMode:n,fillValue:o,outputShape:s};return E.runKernel(Qm,l,u)}var DM=_({transform_:got});function xot(e,t,r){A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(r%1===0,()=>`bandPart(): numUpper must be an integer, got ${r}.`);let n=N(e,"a","bandPart");A(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(r<=i))throw new Error(`bandPart(): numUpper (${r}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),r<0&&(r=i);let a=L(pl(0,s,1,"int32"),[-1,1]),l=pl(0,i,1,"int32"),u=yt(a,l),c=cn(ns(u,At(+t,"int32")),Wn(u,At(-r,"int32"))),p=ke([s,i],n.dtype);return L(Cr(pn(L(n,[-1,s,i])).map(f=>Ie(c,f,p))),o)}var RM=_({bandPart_:xot});function yot(e){let t;if(Array.isArray(e)){t=!1,A(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=e[0].shape[0];for(let s=1;s<e.length;++s)A(e[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${o})`)}else t=!0,e=wr(e,e.shape[0],0).map(o=>Ms(o,[0]));A(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let r=[],n=e;for(let o=0;o<e.length;++o)r.push(E.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=F(ht(F(r[i],s)),r[i]);s=yt(s,a)}return mt(s,tc(s,"euclidean"))}));return t?Cr(r,0):r}var $M=_({gramSchmidt_:yot});function bot(e,t=!1){if(A(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return OM(e,t);{let r=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),n=pn(L(e,[r,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),o=[],s=[];n.forEach(l=>{let[u,c]=OM(l,t);o.push(u),s.push(c)});let i=L(Cr(o,0),e.shape),a=L(Cr(s,0),e.shape);return[i,a]}}function OM(e,t=!1){return E.tidy(()=>{A(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let r=e.shape[0],n=e.shape[1],o=xd(r),s=lo(e),i=Dx([[1]],[1,1]),a=lo(i),l=r>=n?n:r;for(let u=0;u<l;++u){let c=s,p=a,f=o;[a,s,o]=E.tidy(()=>{let m=Kt(s,[u,u],[r-u,1]),d=tc(m),h=Kt(s,[u,u],[1,1]),x=Ie(We(h,0),Dx([[-1]]),Dx([[1]])),g=yt(h,F(x,d)),y=mt(m,g);y.shape[0]===1?a=lo(i):a=Ce([i,Kt(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let b=Zt(mt(Qt(x,g),d)),v=Kt(s,[u,0],[r-u,n]),C=F(b,a),S=Lt(a);if(u===0)s=yt(v,Qt(C,Qt(S,v)));else{let D=yt(v,Qt(C,Qt(S,v)));s=Ce([Kt(s,[0,0],[u,n]),D],0)}let k=Lt(C),I=Kt(o,[0,u],[r,o.shape[1]-u]);if(u===0)o=yt(I,Qt(Qt(I,a),k));else{let D=yt(I,Qt(Qt(I,a),k));o=Ce([Kt(o,[0,0],[r,u]),D],1)}return[a,s,o]}),$t([c,p,f])}return!t&&r>n&&(o=Kt(o,[0,0],[r,n]),s=Kt(s,[0,0],[n,n])),[o,s]})}var FM=_({qr_:bot});var Bs={flipLeftRight:bM,grayscaleToRGB:vM,resizeNearestNeighbor:s1,resizeBilinear:o1,rotateWithOffset:wM,cropAndResize:yM,nonMaxSuppression:CM,nonMaxSuppressionAsync:TM,nonMaxSuppressionWithScore:NM,nonMaxSuppressionWithScoreAsync:IM,nonMaxSuppressionPadded:EM,nonMaxSuppressionPaddedAsync:_M,threshold:AM,transform:DM},PM={bandPart:RM,gramSchmidt:$M,qr:FM};var Jr=class extends px{minimize(t,r=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return $t(s),r?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,r){return ZE(t,r)}dispose(){this.iterations_!=null&&$t(this.iterations_)}saveIterations(){return H(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:At(this.iterations_,"int32")}})}getWeights(){return H(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(t){return H(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(t){return H(this,null,function*(){return this.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})}};Object.defineProperty(Jr,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Td=class extends Jr{constructor(t,r,n=null){super(),this.learningRate=t,this.rho=r,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=E.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:V(()=>kt(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:V(()=>kt(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let l=this.accumulatedGrads[o].variable,u=this.accumulatedUpdates[o].variable;V(()=>{let c=tt(F(l,this.rho),F(Vt(a),1-this.rho)),p=F(mt(Se(tt(u,this.epsilon)),Se(tt(l,this.epsilon))),a),f=tt(F(u,this.rho),F(Vt(p),1-this.rho));l.assign(c),u.assign(f);let m=tt(F(p,-this.learningRate),s);s.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&($t(this.accumulatedGrads.map(t=>t.variable)),$t(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){return H(this,null,function*(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})}setWeights(t){return H(this,null,function*(){t=yield this.extractIterations(t);let r=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(r,r*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,r){return new t(r.learningRate,r.rho,r.epsilon)}};Td.className="Adadelta";Vn(Td);var Nd=class extends Jr{constructor(t,r=.1){super(),this.learningRate=t,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=E.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:V(()=>il(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;V(()=>{let l=tt(a,Vt(i));a.assign(l);let u=tt(F(mt(i,Se(tt(l,E.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&$t(this.accumulatedGrads.map(t=>t.variable))}getWeights(){return H(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return H(this,null,function*(){t=yield this.extractIterations(t);let r=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,r){return new t(r.learningRate,r.initialAccumulatorValue)}};Nd.className="Adagrad";Vn(Nd);var Id=class extends Jr{constructor(t,r,n,o=null){super(),this.learningRate=t,this.beta1=r,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],V(()=>{this.accBeta1=At(r).variable(),this.accBeta2=At(n).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){let r=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);V(()=>{let n=yt(1,this.accBeta1),o=yt(1,this.accBeta2);r.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:V(()=>kt(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:V(()=>kt(a).variable(l))});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,f=tt(F(c,this.beta1),F(u,1-this.beta1)),m=tt(F(p,this.beta2),F(Vt(u),1-this.beta2)),d=mt(f,n),h=mt(m,o);c.assign(f),p.assign(m);let x=tt(F(mt(d,tt(Se(h),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(F(this.accBeta1,this.beta1)),this.accBeta2.assign(F(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&$t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&$t(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){return H(this,null,function*(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})}setWeights(t){return H(this,null,function*(){t=yield this.extractIterations(t),V(()=>{this.accBeta1.assign(rs(this.beta1,this.iterations_+1)),this.accBeta2.assign(rs(this.beta2,this.iterations_+1))});let r=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(r,r*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,r){return new t(r.learningRate,r.beta1,r.beta2,r.epsilon)}};Id.className="Adam";Vn(Id);var Ed=class extends Jr{constructor(t,r,n,o=null,s=0){super(),this.learningRate=t,this.beta1=r,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],V(()=>{this.iteration=At(0).variable(),this.accBeta1=At(r).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){let r=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);V(()=>{let n=yt(1,this.accBeta1),o=mt(-this.learningRate,tt(F(this.iteration,this.decay),1));r.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:kt(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:kt(a).variable(l)});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,f=tt(F(c,this.beta1),F(u,1-this.beta1)),m=F(p,this.beta2),d=ir(u),h=po(m,d);c.assign(f),p.assign(h);let x=tt(F(mt(o,n),mt(f,tt(h,this.epsilon))),a);a.assign(x)}),this.iteration.assign(tt(this.iteration,1)),this.accBeta1.assign(F(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&$t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&$t(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return H(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(t){return H(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,r){return new t(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}};Ed.className="Adamax";Vn(Ed);var rc=class extends Jr{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=E.registeredVariables[n];V(()=>{let a=tt(F(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ir(At(-t))}dispose(){this.c.dispose()}getWeights(){return H(this,null,function*(){return[yield this.saveIterations()]})}setWeights(t){return H(this,null,function*(){if(t=yield this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,r){return new t(r.learningRate)}};rc.className="SGD";Vn(rc);var _d=class extends rc{constructor(t,r,n=!1){super(t),this.learningRate=t,this.momentum=r,this.useNesterov=n,this.accumulations=[],this.m=At(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=E.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:V(()=>kt(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&V(()=>{let l,u=tt(F(this.m,i),a);this.useNesterov?l=tt(F(this.c,tt(a,F(u,this.m))),s):l=tt(F(this.c,u),s),i.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&$t(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){return H(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return H(this,null,function*(){t=yield this.extractIterations(t);let r=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,r){return new t(r.learningRate,r.momentum,r.useNesterov)}};_d.className="Momentum";Vn(_d);var Ad=class extends Jr{constructor(t,r=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=r,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=E.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=E.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:V(()=>kt(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:V(()=>kt(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:V(()=>kt(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let l=this.accumulatedMeanSquares[o].variable,u=this.accumulatedMoments[o].variable;V(()=>{let c=tt(F(l,this.decay),F(Vt(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,f=tt(F(p,this.decay),F(a,1-this.decay)),m=mt(F(a,this.learningRate),Se(yt(c,tt(Vt(f),this.epsilon)))),d=tt(F(u,this.momentum),m);l.assign(c),p.assign(f),u.assign(d);let h=yt(s,d);s.assign(h)}else{let p=tt(F(l,this.decay),F(Vt(a),1-this.decay)),f=tt(F(u,this.momentum),mt(F(a,this.learningRate),Se(tt(p,this.epsilon))));l.assign(p),u.assign(f);let m=yt(s,f);s.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&$t(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&$t(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&$t(this.accumulatedMoments.map(t=>t.variable))}getWeights(){return H(this,null,function*(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})}setWeights(t){return H(this,null,function*(){t=yield this.extractIterations(t);let r=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(r,r*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(r*2,r*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,r){return new t(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}};Ad.className="RMSProp";Vn(Ad);var _i=class{static sgd(t){return new rc(t)}static momentum(t,r,n=!1){return new _d(t,r,n)}static rmsprop(t,r=.9,n=0,o=null,s=!1){return new Ad(t,r,n,o,s)}static adam(t=.001,r=.9,n=.999,o=null){return new Id(t,r,n,o)}static adadelta(t=.001,r=.95,n=null){return new Td(t,r,n)}static adamax(t=.002,r=.9,n=.999,o=null,s=0){return new Ed(t,r,n,o,s)}static adagrad(t,r=.1){return new Nd(t,r)}};var zp={sgd:_i.sgd,momentum:_i.momentum,adadelta:_i.adadelta,adagrad:_i.adagrad,rmsprop:_i.rmsprop,adamax:_i.adamax,adam:_i.adam};var vot=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e())();function $x(){return new Promise(e=>vot(()=>e()))}var T={};Zn(T,{ERF_A1:()=>Fot,ERF_A2:()=>Pot,ERF_A3:()=>Lot,ERF_A4:()=>Mot,ERF_A5:()=>zot,ERF_P:()=>Oot,PARALLELIZE_THRESHOLD:()=>i1,RowPartitionType:()=>Ai,SELU_SCALE:()=>x_,SELU_SCALEALPHA:()=>g_,applyActivation:()=>Pp,assertAndGetBroadcastShape:()=>Pt,assertAxesAreInnerMostDims:()=>ort,assertParamsConsistent:()=>wot,assignToTypedArray:()=>Hot,axesAreInnerMostDims:()=>UE,calculateShapes:()=>Ftt,checkEinsumDimSizes:()=>Qot,checkPadOnDimRoundingMode:()=>ye,combineLocations:()=>LL,combineRaggedTensorToTensorShapes:()=>Sot,complexWithEvenIndex:()=>Wot,complexWithOddIndex:()=>Got,computeConv2DInfo:()=>Sp,computeConv3DInfo:()=>_L,computeDefaultPad:()=>DE,computeDilation2DInfo:()=>aet,computeOptimalWindowSize:()=>Iot,computeOutAndReduceShapes:()=>HE,computeOutShape:()=>Cot,computePool2DInfo:()=>AE,computePool3DInfo:()=>uet,convertConv2DDataFormat:()=>AL,decodeEinsumEquation:()=>Xot,eitherStridesOrDilationsAreOne:()=>Mr,expandShapeToKeepDim:()=>Ii,exponent:()=>jot,exponents:()=>qot,fromStringArrayToUint8:()=>yst,fromUint8ToStringArray:()=>xst,getAxesPermutation:()=>qE,getBroadcastDims:()=>dL,getComplexWithIndex:()=>Uot,getEinsumComputePath:()=>Zot,getEinsumPermutation:()=>Yot,getFusedBiasGradient:()=>Fp,getFusedDyActivation:()=>Op,getImageCenter:()=>Eot,getInnerMostAxes:()=>srt,getPermuted:()=>Aot,getRaggedRank:()=>Tot,getReductionAxes:()=>pe,getReshaped:()=>_ot,getReshapedPermuted:()=>Dot,getRowPartitionTypesHelper:()=>kot,getSliceBeginCoords:()=>Rot,getSliceSize:()=>$ot,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>rst,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>nst,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>ost,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>ast,getSparseReshapeInputOutputMismatchErrorMessage:()=>ust,getSparseReshapeInputOutputMultipleErrorMessage:()=>lst,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>sst,getSparseReshapeNegativeOutputDimErrorMessage:()=>ist,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>mst,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>cst,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>pst,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>fst,getUndoAxesPermutation:()=>yx,isIdentityPermutation:()=>Jot,log:()=>SJ,mergeRealAndImagArrays:()=>Bot,prepareAndValidate:()=>$tt,prepareSplitSize:()=>est,segment_util:()=>b_,shouldFuse:()=>Lp,slice_util:()=>Er,splitRealAndImagArrays:()=>Vot,tupleValuesAreOne:()=>_o,upcastType:()=>or,validateDefaultValueShape:()=>Not,validateInput:()=>Ott,validateUpdateShape:()=>xL,warn:()=>wi});function wot(e,t){let r=e[0].length;e.forEach((o,s)=>{A(o.length===r,()=>`Error in concat${r}D: rank of tensors[${s}] must be the same as the rank of the rest (${r})`)}),A(t>=0&&t<r,()=>`Error in concat${r}D: axis must be between 0 and ${r-1}.`);let n=e[0];e.forEach((o,s)=>{for(let i=0;i<r;i++)A(i===t||o[i]===n[i],()=>`Error in concat${r}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function Cot(e,t){let r=e[0].slice();for(let n=1;n<e.length;n++)r[t]+=e[n][t];return r}var Ai;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Ai||(Ai={}));function Sot(e,t,r){let n=new Array;if(r==null&&t==null)return n;if(t==null)for(;n.length<e+r.length;)n.push(-1);else n=t.slice();if(r==null)return n;if(e+r.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+r.length}, but shape.rank = ${n.length}`);for(let o=1;o<r.length;++o){let s=r[o],i=n[n.length-r.length+o],a=n[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+e}] = ${s} but shape[${o+e}] = ${a}`)}else n[i]=s}return n}function kot(e){let t={FIRST_DIM_SIZE:Ai.FIRST_DIM_SIZE,VALUE_ROWIDS:Ai.VALUE_ROWIDS,ROW_LENGTHS:Ai.ROW_LENGTHS,ROW_SPLITS:Ai.ROW_SPLITS,ROW_LIMITS:Ai.ROW_LIMITS,ROW_STARTS:Ai.ROW_STARTS},r=[];for(let n of e)if(n in t)r.push(t[n]);else break;return r}function Tot(e){return e.length===0?0:e[0]===Ai.FIRST_DIM_SIZE?e.length-1:e.length}function Not(e,t){if(e==null||t==null)return;let r=e.length,n=t.length;if(r>=n)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(r,n-1);++o){let s=e[o],i=t[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-e.length}] = ${s} but ragged tensor input.flatValues.shape[${o-e.length}] = ${i}`)}}var i1=30;function Iot(e){return e<=i1?e:mm(e,Math.floor(Math.sqrt(e)))}function Eot(e,t,r){let n=r*(typeof e=="number"?e:e[0]),o=t*(typeof e=="number"?e:e[1]);return[n,o]}function _ot(e,t,r,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(e[0]/r),o=o.concat(e.slice(1));else{o=o.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([e[i+1]/t[i],t[i]]);o=o.concat(e.slice(s+1))}return o}function Aot(e,t,r=!0){let n=[];if(r){n.push(t);for(let o=t+1;o<e;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function Dot(e,t,r,n=!0){let o=[];n?o.push(e[0]/r):o.push(e[0]*r);for(let s=1;s<e.length;++s)s<=t.length?n?o.push(t[s-1]*e[s]):o.push(e[s]/t[s-1]):o.push(e[s]);return o}function Rot(e,t){let r=[0];for(let n=0;n<t;++n)r.push(e[n][0]);return r}function $ot(e,t,r){let n=e.slice(0,1);for(let o=0;o<r;++o)n.push(e[o+1]-t[o][0]-t[o][1]);return n}var g_=1.7580993408473768,x_=1.0507009873554805;var Oot=.3275911,Fot=.254829592,Pot=-.284496736,Lot=1.421413741,Mot=-1.453152027,zot=1.061405429;function Bot(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let r=new Float32Array(e.length*2);for(let n=0;n<r.length;n+=2)r[n]=e[n/2],r[n+1]=t[n/2];return r}function Vot(e){let t=new Float32Array(e.length/2),r=new Float32Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=e[n],r[n/2]=e[n+1];return{real:t,imag:r}}function Wot(e){let t=Math.ceil(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<e.length;o+=4)r[Math.floor(o/4)]=e[o],n[Math.floor(o/4)]=e[o+1];return{real:r,imag:n}}function Got(e){let t=Math.floor(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<e.length;o+=4)r[Math.floor(o/4)]=e[o],n[Math.floor(o/4)]=e[o+1];return{real:r,imag:n}}function Uot(e,t){let r=e[t*2],n=e[t*2+1];return{real:r,imag:n}}function Hot(e,t,r,n){e[n*2]=t,e[n*2+1]=r}function qot(e,t){let r=new Float32Array(e/2),n=new Float32Array(e/2);for(let o=0;o<Math.ceil(e/2);o++){let s=(t?2:-2)*Math.PI*(o/e);r[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:r,imag:n}}function jot(e,t,r){let n=(r?2:-2)*Math.PI*(e/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var y_="->",Kot=/->/g,LM=",",MM="...";function Xot(e,t){e=e.replace(/\s/g,"");let r=(e.length-e.replace(Kot,"").length)/y_.length;if(r<1)throw new Error("Equations without an arrow are not supported.");if(r>1)throw new Error(`Equation must contain exactly one arrow ("${y_}").`);let[n,o]=e.split(y_);A(n.indexOf(MM)===-1,()=>`The ellipsis notation ("${MM}") is not supported yet.`);let s=n.split(LM),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let f=0;f<o.length;++f){let m=o[f];if(!s.some(d=>d.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);a.indexOf(m)===-1&&a.push(m)}for(let f=0;f<n.length;++f){let m=n[f];a.indexOf(m)===-1&&m!==LM&&a.push(m)}let l=new Array(s.length);for(let f=0;f<i;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let m=0;m<s[f].length;++m)l[f].push(a.indexOf(s[f][m]))}let u=a.length,c=o.length,p=[];for(let f=c;f<u;++f)p.push(f);return{allDims:a,summedDims:p,idDims:l}}function Yot(e,t){let r=new Array(e);r.fill(-1);for(let o=0;o<t.length;++o)r[t[o]]=o;let n=[];for(let o=0;o<e;++o)r[o]===-1&&n.push(o);return r=r.filter(o=>o!==-1),{permutationIndices:r,expandDims:n}}function Qot(e,t,r){let n=new Array(e);for(let o=0;o<r.length;++o){let s=r[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:A(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function Zot(e,t){let r=e,n=[],o=0;e.length===0&&r.push(-1),o=e.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<r.length;++i){let a=r[i],l=tst(t,a);for(let u of l)s.indexOf(u)===-1&&(n[i].push(u),s.push(u))}return{path:r,steps:n}}function Jot(e){return e.every((t,r)=>t===r)}function tst(e,t){let r=[];for(let n=0;n<e.length;++n)(e[n].length===0||e[n].indexOf(t)!==-1||t===-1)&&r.push(n);return r}function est(e,t,r=0){let n=[];if(typeof t=="number")A(e.shape[r]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(e.shape[r]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,l)=>l>0?a+l:a);t[s]=e.shape[r]-i}A(e.shape[r]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function rst(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function nst(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function ost(e,t,r){return`indices(${e}, 0) is invalid: ${t} >= ${r}`}function sst(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function ist(e,t){return`size ${e} must be non-negative, not ${t}`}function ast(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function lst(e,t){let r=ee(e),n=ee(t);return`Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${e} outputShape= ${t}`}function ust(e,t){let r=ee(e),n=ee(t);return`Input to reshape is a tensor with ${r} dense values, but the requested shape has ${n}. inputShape=${e} outputShape=${t}`}function cst(){return"segment ids must be >= 0"}function pst(){return"segment ids are not increasing"}function fst(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function mst(e,t,r){return`Bad: indices[${e}] == ${t} out of range [0, ${r})`}var b_={};Zn(b_,{collectGatherOpShapeInfo:()=>gst,computeOutShape:()=>hst,segOpComputeOptimalWindowSize:()=>dst});function dst(e,t){let r=!1,n;for(e<=i1?(n=e,r=!0):n=mm(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=mm(e,n+1);return n}function hst(e,t,r){let n=[],o=e.length;for(let s=0;s<o;s++)s!==t?n.push(e[s]):n.push(r);return n}function gst(e,t,r,n){let o=t.shape.length,s=e.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(r<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${r}).`);for(let p=0;p<n;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=e.shape[r],a=[],l=1,u=1,c=1;for(let p=0;p<n;++p)a.push(e.shape[p]),l*=e.shape[p];for(let p=n;p<r;p++)a.push(e.shape[p]),u*=e.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=r+1;p<s;p++)a.push(e.shape[p]),c*=e.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function xst(e){try{return e.map(t=>od(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function yst(e){return e.map(t=>nd(t))}var tn={};Zn(tn,{nonMaxSuppressionV3Impl:()=>e1,nonMaxSuppressionV4Impl:()=>r1,nonMaxSuppressionV5Impl:()=>n1,whereImpl:()=>fM});var a1={kernelName:ru,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,zs(et(r,"float32"),-1))}}};var zM={kernelName:aa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let n=Vt(et(r,"float32")),o=Se(yt(At(1),n));return Zt(mt(e,o))}}}};var BM={kernelName:la,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let n=Se(yt(Vt(et(r,"float32")),1));return mt(e,n)}}}};var VM={kernelName:Fs,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=e,l=pe(r.shape,o);return l.length>0&&(a=ht(a,l)),L(a,r.shape)},b:()=>{let a=e,l=pe(n.shape,o);return l.length>0&&(a=ht(a,l)),L(a,n.shape)}}}};var WM={kernelName:hm,saveAllInputs:!0,gradFunc:(e,t)=>{let r={};return t.forEach((n,o)=>{r[o]=()=>e.clone()}),r}};var GM={kernelName:nu,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>kt(r)}}};var UM={kernelName:ou,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>kt(r)}}};var HM={kernelName:ua,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,Se(yt(At(1),Vt(et(r,"float32")))))}}};var qM={kernelName:ca,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let n=Se(tt(At(1),Vt(et(r,"float32"))));return mt(e,n)}}}};var jM={kernelName:ma,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=tt(Vt(r),Vt(n)),l=F(e,mt(n,a)),u=pe(r.shape,o);return u.length>0&&(l=ht(l,u)),L(l,r.shape)},b:()=>{let a=tt(Vt(r),Vt(n)),l=Zt(F(e,mt(r,a))),u=pe(n.shape,o);return u.length>0&&(l=ht(l,u)),L(l,n.shape)}}}};var KM={kernelName:pa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,tt(Vt(et(r,"float32")),1))}}};var XM={kernelName:fa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,yt(At(1),Vt(et(r,"float32"))))}}};function bst(e,t,r,n,o,s){let i=N(e,"dy","avgPool3dGrad"),a=N(t,"input","avgPool3dGrad"),l=i,u=a,c=!1;a.rank===4&&(c=!0,l=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),A(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),ye("avgPool3dGrad",o,s);let p={dy:l,input:u},f={filterSize:r,strides:n,pad:o,dimRoundingMode:s},m=E.runKernel(bm,p,f);return c?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var YM=_({avgPool3dGrad_:bst});var QM={kernelName:iu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=r;return{x:()=>YM(e,n,o,s,i,a)}}};function vst(e,t,r,n,o){let s=N(e,"dy","avgPoolGrad"),i=N(t,"input","avgPoolGrad");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,l=s,u=!1;i.rank===3&&(u=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:l,input:a},p={filterSize:r,strides:n,pad:o},f=E.runKernel(ym,c,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var ZM=_({avgPoolGrad_:vst});var JM={kernelName:su,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=r;return{x:()=>ZM(e,n,o,s,i)}}};var tz={kernelName:au,inputsToSave:["a","b"],gradFunc:(e,t,r)=>{let[n,o]=t,{transposeA:s,transposeB:i}=r;return!s&&!i?{a:()=>Qt(e,o,!1,!0),b:()=>Qt(n,e,!0,!1)}:!s&&i?{a:()=>Qt(e,o,!1,!1),b:()=>Qt(e,n,!0,!1)}:s&&!i?{a:()=>Qt(o,e,!1,!0),b:()=>Qt(n,e,!1,!1)}:{a:()=>Qt(o,e,!0,!0),b:()=>Qt(e,n,!0,!0)}}};var ez={kernelName:lu,gradFunc:(e,t,r)=>{let{blockShape:n,crops:o}=r;return{x:()=>vd(e,n,o)}}};var rz={kernelName:aP,gradFunc:(e,t,r)=>{let n=r,o=n.inputShape,s=n.shape,i=Array.from(s);for(let l=o.length-1;l>=0;l--)if(o[l]===s[l])i[l]=1;else if(o[l]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>ht(e,a,!0)}}};var nz={kernelName:xi,gradFunc:e=>({x:()=>e.clone()})};var oz={kernelName:da,gradFunc:e=>({x:()=>kt(e)})};var sz={kernelName:ha,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=r;return{x:()=>Ie(cn(Wn(n,o),ns(n,s)),e,kt(e))}}};var iz={kernelName:uu,inputsToSave:["x"],gradFunc:a1.gradFunc};var az={kernelName:cu,saveAllInputs:!0,gradFunc:(e,t,r)=>{let n=t.map(l=>l.shape),{axis:o}=r,s=dr(o,t[0].shape)[0],i=n.map(l=>l[s]);return wr(e,i,s).map(l=>()=>l)}};var lz={kernelName:pu,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:l}=r;return A(_o(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>gd(n.shape,e,o,i,a,l),filter:()=>kd(n,e,o.shape,i,a,l)}}};var uz={kernelName:fu,inputsToSave:["dy","filter"],gradFunc:(e,t,r)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:l}=r;return{dy:()=>co(e,o,s,i,a,1,l),filter:()=>kd(e,n,o.shape,s,i,a,l)}}};function wst(e,t,r,n,o){let s=e;e.rank===4&&(s=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(r.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${r}.`),A(s.shape[4]===r[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${r[3]}.`),A(i.shape[4]===r[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${r[4]}).`);let a={x:s,dy:i},l={strides:n,pad:o,filterShape:r};return E.runKernel(Sm,a,l)}var cz=_({conv3DBackpropFilter_:wst});var pz={kernelName:mu,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let{dilations:n,strides:o,pad:s}=r;A(_o(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>Ww(i.shape,e,a,o,s),filter:()=>cz(i,e,a.shape,o,s)}}};var fz={kernelName:ga,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(Zt(Nx(et(r,"float32"))),e)}}};var mz={kernelName:xa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(Ix(et(r,"float32")),e)}}};var dz={kernelName:du,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=r;return{x:()=>{let a=qE([o],n.rank),l=Gw(e,o,s,!i);return a!=null&&(l=Lt(l,a)),l}}}};var hz={kernelName:hu,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=r,a=n==null?[1,1]:n;A(_o(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[l,u]=t;return A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),A(Mr(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),ye("depthwiseConv2d",s,i),{x:()=>t1(l.shape,e,u,o,s,a,i),filter:()=>Jw(l,e,u.shape,o,s,a,i)}}};var gz={kernelName:gu,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let[n,o]=t,s={x:n,filter:o,dy:e},i={x:n,filter:o,dy:e};return{x:()=>E.runKernel(Qg,s,r),filter:()=>E.runKernel(Zg,i,r)}}};var xz={kernelName:ba,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t,n={dy:e,y:r};return{x:()=>E.runKernel(Rm,n)}}};var yz={kernelName:va,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t,n=F(Qr(Zt(Vt(r))),2/Math.sqrt(Math.PI));return{x:()=>F(e,n)}}};var bz={kernelName:wa,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,r)}}};var vz={kernelName:xu,inputsToSave:["input"],gradFunc:(e,t)=>{let[r]=t;return{input:()=>L(e,r.shape)}}};var wz={kernelName:Ca,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,Qr(r))}}};var Cz={kernelName:Sa,gradFunc:e=>({x:()=>kt(e)})};var Sz={kernelName:ka,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=mt(e,et(n,"float32")),l=pe(r.shape,o);return l.length>0?L(ht(a,l),r.shape):a},b:()=>{let a=F(e,et(r,"float32")),l=pe(n.shape,o);l.length>0&&(a=L(ht(a,l),n.shape));let u=Vt(n);return Zt(mt(a,et(u,"float32")))}}}};var kz={kernelName:yu,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,r)=>{let{varianceEpsilon:n}=r,[o,s,i,a]=t,l=a==null?At(1):a,u=pe(s.shape,o.shape),c=[];if(s.rank===1){for(let v=0;v<o.shape.length-1;++v)c.push(o.shape[v]);c.push(1)}let p=yt(o,s),f=F(e,l),m=Sx(tt(i,At(n))),d=F(F(F(m,m),m),At(-.5));return{x:()=>s.rank===1?L(F(F(e,Zr(L(m,[1,1,1,s.shape[0]]),c)),l),o.shape):L(F(F(e,m),l),o.shape),mean:()=>{let v=F(F(m,At(-1)),f);return s.rank===1&&(v=ht(v,u)),L(v,s.shape)},variance:()=>{let v=F(F(d,p),f);return s.rank===1&&(v=ht(v,u)),L(v,s.shape)},scale:()=>{let v=F(p,m),C=F(e,v);return s.rank===1&&(C=ht(C,u)),L(C,s.shape)},offset:()=>{let v=e;return s.rank===1&&(v=ht(v,u)),L(v,s.shape)}}}};var Iz={kernelName:bu,inputsToSave:["x","indices"],gradFunc:(e,t,r)=>{let[n,o]=t,{axis:s}=r,i=dr(s,n.shape)[0];return{x:()=>{let l=n.shape,u=o.size,c=l.slice(0,i),p=c.length,f=l.slice(s,l.length).slice(1),m=f.length,d=Tz(0,p),h=Tz(p+1,p+1+m),x=Nz([c,[u],f]),g=L(e,x),y=L(o,[u]),b=Nz([[p],d,h]),v=Lt(g,b),C=Zw(v,y,n.shape[i]),S=yx(b);return C=Lt(C,S),C},indices:()=>o}}};function Tz(e,t){let r=[];for(let n=e;n<t;++n)r.push(n);return r}function Nz(e){let t=[];for(let r=0;r<e.length;++r)for(let n=0;n<e[r].length;++n)t.push(e[r][n]);return t}var Ez={kernelName:Ta,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>kt(r),b:()=>kt(n)}}};var _z={kernelName:yi,gradFunc:e=>({x:()=>et(e,"float32")})};var Az={kernelName:Na,gradFunc:e=>({x:()=>kt(e)})};var Dz={kernelName:Ia,gradFunc:e=>({x:()=>kt(e)})};var Rz={kernelName:Ea,gradFunc:e=>({x:()=>kt(e)})};var $z={kernelName:vu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{alpha:o}=r,s=We(n,0);return{x:()=>Ie(s,e,F(e,o))}}};var Oz={kernelName:Aa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,tt(r,1))}}};var Fz={kernelName:_a,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,et(r,"float32"))}}};var Pz={kernelName:lP,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n]=t,{axis:o}=r;return{logits:()=>{let i=Qr(n);return yt(e,F(ht(e,o,!0),i))}}}};function Cst(e,t,r,n=5,o=1,s=1,i=.5){let a={x:e,y:t,dy:r},l={depthRadius:n,bias:o,alpha:s,beta:i};return E.runKernel(Mm,a,l)}var Lz=_({localResponseNormalizationBackprop_:Cst});var Mz={kernelName:wu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:l}=r;return{x:()=>Lz(n,o,e,s,i,a,l)}}};function l1(e,t,r,n){return t.rank<r.rank&&(t=L(t,Ii(t.shape,n))),e.rank<r.rank&&(e=L(e,Ii(e.shape,n))),{x:()=>F(e,et(kn(r,t),e.dtype))}}var v_={kernelName:Cu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let n=r,{reductionIndices:o}=n,s=t[0],i=t[1],a=dr(o,s.shape),l=l1(e,i,s,a);return{x:()=>l.x()}}};var zz={kernelName:Da,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>F(e,et(Wn(r,n),"float32")),b:()=>F(e,et(Hw(r,n),"float32"))}}};function Sst(e,t,r,n,o,s,i){let a=N(e,"dy","maxPool3dGrad"),l=N(t,"input","maxPool3dGrad"),u=N(r,"output","maxPool3dGrad"),c=a,p=l,f=u,m=!1;l.rank===4&&(m=!0,c=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=L(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),ye("maxPool3dGrad",s,i);let d={dy:c,input:p,output:f},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},x=E.runKernel(Bm,d,h);return m?L(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}var Bz=_({maxPool3dGrad_:Sst});var Vz={kernelName:ku,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r;return{x:()=>Bz(e,n,o,s,i,a,l)}}};function kst(e,t,r,n,o,s,i){let a=N(e,"dy","maxPoolGrad"),l=N(t,"input","maxPoolGrad"),u=N(r,"output","maxPoolGrad");A(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ye("maxPoolGrad",s,i);let c={dy:a,input:l,output:u},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return E.runKernel(zm,c,p)}var Wz=_({maxPoolGrad_:kst});var Gz={kernelName:Su,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=r;return{x:()=>Wz(e,n,o,s,i,a)}}};var Uz={kernelName:Tu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:o}=r,s=dr(o,n.shape),a=HE(n.shape,s)[1],l=ee(a);return{x:()=>{let c=n.shape.slice();s.forEach(m=>{c[m]=1});let p=L(e,c);return mt(F(p,fo(n.shape,"float32")),l)}}}};var Hz={kernelName:Nu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let n=r,{axis:o}=n,[s,i]=t,a=dr(o,s.shape),l=l1(e,i,s,a);return{x:()=>l.x()}}};var qz={kernelName:Ra,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>F(e,et(ns(r,n),"float32")),b:()=>F(e,et(We(r,n),"float32"))}}};var jz={kernelName:Iu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let n=t[0],{paddings:o}=r,s=o.map(i=>i[0]);return{x:()=>Kt(e,s,n.shape)}}};var Kz={kernelName:$a,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=pe(r.shape,o);return a.length>0?L(ht(e,a),r.shape):e},b:()=>{let a=F(e,Zt(ul(mt(r,n)))),l=pe(n.shape,o);return l.length>0?L(ht(a,l),n.shape):a}}}};var Xz={kernelName:Oa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=F(e,et(n,"float32")),l=pe(r.shape,o);return l.length>0?L(ht(a,l),r.shape):a},b:()=>{let a=F(e,et(r,"float32")),l=pe(n.shape,o);return l.length>0?L(ht(a,l),n.shape):a}}}};var Yz={kernelName:Eu,gradFunc:e=>({x:()=>Zt(e)})};var Qz={kernelName:Au,inputsToSave:["indices"],gradFunc:(e,t)=>{let r=t[0];return{indices:()=>ke(r.shape,"float32")}}};var Zz={kernelName:_u,gradFunc:e=>({x:()=>kt(e)})};var Jz={kernelName:Du,saveAllInputs:!0,gradFunc:(e,t,r)=>{let{axis:n}=r;return pn(e,n).map(s=>()=>s)}};var w_={kernelName:Ru,inputsToSave:["x"],gradFunc:(e,t,r)=>{let n=t[0],{paddings:o}=r,s=o.map(i=>i[0]);return{x:()=>Kt(e,s,n.shape)}}};var t3={kernelName:Fa,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[r,n,o]=t,s=r,i=n,a=Pt(s.shape,i.shape);return{a:()=>{let c=et(i,"float32"),p=F(e,F(c,rs(s,yt(c,At(1))))),f=pe(s.shape,a);return f.length>0&&(p=ht(p,f)),L(p,s.shape)},b:()=>{let c=We(s,0),p=Ie(c,Tn(s),kt(s)),f=F(e,F(o,p)),m=pe(i.shape,a);return m.length>0&&(f=ht(f,m)),L(f,i.shape)}}}};var e3={kernelName:$u,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[r,n]=t,o=We(r,0);return{x:()=>Ie(o,e,F(e,n)),alpha:()=>{let s=Ie(o,kt(e),F(e,r)),i=pe(n.shape,e.shape);return i.length>0&&(s=ht(s,i)),L(s,n.shape)}}}};function Tst(e,t,r){let n=e.shape.slice();n[r]=1;let o=L(t,n),s=gx(e,r,!0,!1),i=gx(e,r,!0,!0),a=F(s,i);return F(o,a)}function Nst(e,t,r){let n=e.shape.length,o=n-r.length,s=T.getAxesPermutation(r,n),i=e;s!=null&&(i=Lt(e,s));let a=i.shape.slice(),u=a.splice(n-r.length,r.length).reduce((f,m)=>f*m,1);a.push(u);let c=i.reshape(a),p=Tst(c,t,o);if(p=p.reshape(i.shape),s!=null){let f=T.getUndoAxesPermutation(s);p=Lt(p,f)}return p}var r3={kernelName:Ou,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:o}=r,s=[];return o==null?s=n.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>Nst(n,e,s)}}};var n3={kernelName:ya,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=mt(e,et(n,"float32")),l=pe(r.shape,o);return l.length>0?L(ht(a,l),r.shape):a},b:()=>{let a=F(e,et(r,"float32")),l=pe(n.shape,o);l.length>0&&(a=L(ht(a,l),n.shape));let u=Vt(n);return Zt(mt(a,et(u,"float32")))}}}};var o3={kernelName:Pa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,Zt(Vt(r)))}}};var s3={kernelName:Ma,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t,n=F(ns(r,6),zs(r));return{x:()=>F(e,et(n,"float32"))}}};var i3={kernelName:La,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,et(zs(r),"float32"))}}};var a3={kernelName:Fu,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>L(e,r.shape)}}};var l3={kernelName:Lu,inputsToSave:["images"],gradFunc:(e,t,r)=>{let[n]=t,o={dy:e,images:n};return{images:()=>E.runKernel(jm,o,r)}}};var u3={kernelName:Pu,inputsToSave:["images"],gradFunc:(e,t,r)=>{let[n]=t,o={dy:e,images:n};return{images:()=>E.runKernel(qm,o,r)}}};var c3={kernelName:Mu,gradFunc:(e,t,r)=>{let{dims:n}=r,o=dr(n,e.shape);return{x:()=>Ro(e,o)}}};var p3={kernelName:za,gradFunc:e=>({x:()=>kt(e)})};var f3={kernelName:Ba,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>Zt(mt(e,F(rs(r,1.5),2)))}}};var m3={kernelName:zu,inputsToSave:["condition"],gradFunc:(e,t)=>{let[r]=t;return{condition:()=>et(kt(r),"float32"),t:()=>F(e,et(r,e.dtype)),e:()=>F(e,et(yd(r),e.dtype))}}};var d3={kernelName:Va,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let n=We(r,At(0)),o=At(g_),s=At(x_),i=F(e,s),a=F(F(e,o),Qr(et(r,"float32")));return Ie(n,i,a)}}}};var h3={kernelName:Ha,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,F(r,yt(At(1),r)))}}};var g3={kernelName:Ua,gradFunc:e=>({x:()=>kt(e)})};var x3={kernelName:Wa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(Tp(et(r,"float32")),e)}}};var y3={kernelName:Ga,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(hx(et(r,"float32")),e)}}};var b3={kernelName:Bu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{begin:o,size:s}=r,i=n.shape,[a,l]=CE(n,o,s),u=[];for(let c=0;c<e.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>Ap(e,u)}}};var v3={kernelName:Uu,outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n]=t,{dim:o}=r,s=!0,i=F(e,n);return{logits:()=>yt(i,F(ht(i,[o],s),n))}}};var w3={kernelName:qa,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,es(r))}}};var C_={kernelName:Wu,gradFunc:(e,t,r)=>{let{blockShape:n,paddings:o}=r;return{x:()=>hd(e,n,o)}}};var S_={kernelName:Gu,gradFunc:(e,t,r)=>{let{axis:n}=r;return{x:()=>Ce(e,n)}}};var C3={kernelName:ja,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,F(Se(et(r,"float32")),2))}}};var S3={kernelName:Km,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(e,F(et(r,"float32"),2))}}};var k3={kernelName:Ka,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=At(2);return{a:()=>F(e,F(o,yt(r,n))),b:()=>F(e,F(o,yt(n,r)))}}};var T3={kernelName:Za,gradFunc:e=>({x:()=>kt(e)})};var N3={kernelName:Xa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,o=Pt(r.shape,n.shape);return{a:()=>{let a=e,l=pe(r.shape,o);return l.length>0&&(a=ht(a,l)),L(a,r.shape)},b:()=>{let a=e,l=pe(n.shape,o);return l.length>0&&(a=ht(a,l)),L(Zt(a),n.shape)}}}};var I3={kernelName:Vu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,o=n.shape.slice(),{axis:s}=r;dr(s,n.shape).forEach(u=>{o[u]=1});let a=L(e,o),l=F(a,fo(n.shape,"float32"));return{x:()=>l}}};var E3={kernelName:Ya,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>mt(e,Vt(Tp(r)))}}};var _3={kernelName:Qa,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>F(yt(At(1),Vt(r)),e)}}};var A3={kernelName:bi,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{reps:o}=r;return{x:()=>{let i=kt(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=tt(i,Kt(e,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)i=tt(i,Kt(e,[a*n.shape[0],l*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)i=tt(i,Kt(e,[a*n.shape[0],l*n.shape[1],u*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)for(let c=0;c<o[3];++c)i=tt(i,Kt(e,[a*n.shape[0],l*n.shape[1],u*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var D3={kernelName:vi,gradFunc:(e,t,r)=>{let n=r,{perm:o}=n,s=yx(o);return{x:()=>Lt(e,s)}}};var R3={kernelName:Hu,gradFunc:(e,t,r)=>{let n=r,{axis:o}=n;return{value:()=>Cr(e,o)}}};var $3={kernelName:qu,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>Ist(e,r)}}};function Ist(e,t){let r=po(t,kt(t)),n=Np(e,r),o=Wn(t,At(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=hr(o,a+1);o=cn(o,fo(n.shape,"bool"));let i=kt(n);return Ie(o,n,i)}var O3={kernelName:ju,gradFunc:e=>({x:()=>kt(e)})};var Est=[a1,zM,BM,VM,WM,GM,UM,HM,qM,jM,KM,XM,QM,JM,tz,ez,rz,nz,oz,sz,iz,az,uz,lz,pz,fz,mz,dz,hz,gz,n3,xz,yz,bz,vz,wz,Sz,Cz,kz,Iz,Ez,_z,Az,Dz,Rz,$z,Oz,Fz,Pz,Mz,v_,v_,zz,Vz,Gz,Uz,Hz,qz,jz,Kz,Xz,Yz,Qz,Zz,Jz,w_,w_,t3,e3,r3,o3,s3,i3,a3,l3,u3,c3,p3,f3,m3,d3,h3,g3,x3,y3,b3,v3,w3,C_,C_,S_,S_,C3,k3,S3,T3,N3,I3,E3,_3,A3,D3,R3,$3,O3];for(let e of Est)cP(e);O().prototype.abs=function(){return this.throwIfDisposed(),ir(this)};O().prototype.acos=function(){return this.throwIfDisposed(),SE(this)};O().prototype.acosh=function(){return this.throwIfDisposed(),kE(this)};O().prototype.add=function(e){return this.throwIfDisposed(),tt(this,e)};O().prototype.all=function(e,t){return this.throwIfDisposed(),fx(this,e,t)};O().prototype.any=function(e,t){return this.throwIfDisposed(),fd(this,e,t)};O().prototype.argMax=function(e){return this.throwIfDisposed(),ol(this,e)};O().prototype.argMin=function(e){return this.throwIfDisposed(),IL(this,e)};O().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),L(this,[])};O().prototype.asType=function(e){return this.throwIfDisposed(),et(this,e)};O().prototype.as1D=function(){return this.throwIfDisposed(),L(this,[this.size])};O().prototype.as2D=function(e,t){return this.throwIfDisposed(),L(this,[e,t])};O().prototype.as3D=function(e,t,r){return this.throwIfDisposed(),L(this,[e,t,r])};O().prototype.as4D=function(e,t,r,n){return this.throwIfDisposed(),L(this,[e,t,r,n])};O().prototype.as5D=function(e,t,r,n,o){return this.throwIfDisposed(),L(this,[e,t,r,n,o])};O().prototype.asin=function(){return this.throwIfDisposed(),TE(this)};O().prototype.asinh=function(){return this.throwIfDisposed(),NE(this)};O().prototype.atan=function(){return this.throwIfDisposed(),IE(this)};O().prototype.atan2=function(e){return this.throwIfDisposed(),EL(this,e)};O().prototype.atanh=function(){return this.throwIfDisposed(),EE(this)};O().prototype.avgPool=function(e,t,r,n){return this.throwIfDisposed(),kp(this,e,t,r,n)};O().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),hd(this,e,t)};O().prototype.batchNorm=function(e,t,r,n,o){return this.throwIfDisposed(),Zu(this,e,t,r,n,o)};O().prototype.broadcastTo=function(e){return this.throwIfDisposed(),sl(this,e)};O().prototype.cast=function(e){return this.throwIfDisposed(),et(this,e)};O().prototype.ceil=function(){return this.throwIfDisposed(),PE(this)};O().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),zr(this,e,t)};O().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof qt&&(e=[e]),Ce([this,...e],t)};O().prototype.conv1d=function(e,t,r,n,o,s){return this.throwIfDisposed(),mx(this,e,t,r,n,o,s)};O().prototype.conv2dTranspose=function(e,t,r,n,o){return this.throwIfDisposed(),dx(this,e,t,r,n,o)};O().prototype.conv2d=function(e,t,r,n,o,s){return this.throwIfDisposed(),co(this,e,t,r,n,o,s)};O().prototype.cos=function(){return this.throwIfDisposed(),Tp(this)};O().prototype.cosh=function(){return this.throwIfDisposed(),hx(this)};O().prototype.cumprod=function(e,t,r){return this.throwIfDisposed(),gx(this,e,t,r)};O().prototype.cumsum=function(e,t,r){return this.throwIfDisposed(),Gw(this,e,t,r)};O().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),$L(this,e,t)};O().prototype.depthwiseConv2d=function(e,t,r,n,o,s){return this.throwIfDisposed(),al(this,e,t,r,n,o,s)};O().prototype.dilation2d=function(e,t,r,n,o){return this.throwIfDisposed(),OL(this,e,t,r,n,o)};O().prototype.divNoNan=function(e){return this.throwIfDisposed(),FL(this,e)};O().prototype.div=function(e){return this.throwIfDisposed(),mt(this,e)};O().prototype.dot=function(e){return this.throwIfDisposed(),PL(this,e)};O().prototype.elu=function(){return this.throwIfDisposed(),ll(this)};O().prototype.equal=function(e){return this.throwIfDisposed(),kn(this,e)};O().prototype.erf=function(){return this.throwIfDisposed(),GE(this)};O().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),zL(this,e,t)};O().prototype.exp=function(){return this.throwIfDisposed(),Qr(this)};O().prototype.expandDims=function(e){return this.throwIfDisposed(),hr(this,e)};O().prototype.expm1=function(){return this.throwIfDisposed(),KE(this)};O().prototype.fft=function(){return this.throwIfDisposed(),Ax(this)};O().prototype.flatten=function(){return this.throwIfDisposed(),L(this,[this.size])};O().prototype.floor=function(){return this.throwIfDisposed(),ul(this)};O().prototype.floorDiv=function(e){return this.throwIfDisposed(),Bw(this,e)};O().prototype.gather=function(e,t){return this.throwIfDisposed(),Np(this,e,t)};O().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Wn(this,e)};O().prototype.greater=function(e){return this.throwIfDisposed(),We(this,e)};O().prototype.ifft=function(){return this.throwIfDisposed(),Sd(this)};O().prototype.irfft=function(){return this.throwIfDisposed(),c_(this)};O().prototype.isFinite=function(){return this.throwIfDisposed(),XE(this)};O().prototype.isInf=function(){return this.throwIfDisposed(),YE(this)};O().prototype.isNaN=function(){return this.throwIfDisposed(),QE(this)};O().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Ip(this,e)};O().prototype.lessEqual=function(e){return this.throwIfDisposed(),ns(this,e)};O().prototype.less=function(e){return this.throwIfDisposed(),Hw(this,e)};O().prototype.localResponseNormalization=function(e,t,r,n){return this.throwIfDisposed(),BL(this,e,t,r,n)};O().prototype.logSigmoid=function(){return this.throwIfDisposed(),JE(this)};O().prototype.logSoftmax=function(e){return this.throwIfDisposed(),vx(this,e)};O().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),VL(this,e,t)};O().prototype.log=function(){return this.throwIfDisposed(),Tn(this)};O().prototype.log1p=function(){return this.throwIfDisposed(),bx(this)};O().prototype.logicalAnd=function(e){return this.throwIfDisposed(),cn(this,e)};O().prototype.logicalNot=function(){return this.throwIfDisposed(),yd(this)};O().prototype.logicalOr=function(e){return this.throwIfDisposed(),qw(this,e)};O().prototype.logicalXor=function(e){return this.throwIfDisposed(),WL(this,e)};O().prototype.matMul=function(e,t,r){return this.throwIfDisposed(),Qt(this,e,t,r)};O().prototype.maxPool=function(e,t,r,n){return this.throwIfDisposed(),Ep(this,e,t,r,n)};O().prototype.max=function(e,t){return this.throwIfDisposed(),Br(this,e,t)};O().prototype.maximum=function(e){return this.throwIfDisposed(),po(this,e)};O().prototype.mean=function(e,t){return this.throwIfDisposed(),Ee(this,e,t)};O().prototype.min=function(e,t){return this.throwIfDisposed(),Ju(this,e,t)};O().prototype.minimum=function(e){return this.throwIfDisposed(),_p(this,e)};O().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),GL(this,e,t)};O().prototype.mod=function(e){return this.throwIfDisposed(),UL(this,e)};O().prototype.mul=function(e){return this.throwIfDisposed(),F(this,e)};O().prototype.neg=function(){return this.throwIfDisposed(),Zt(this)};O().prototype.norm=function(e,t,r){return this.throwIfDisposed(),tc(this,e,t,r)};O().prototype.notEqual=function(e){return this.throwIfDisposed(),ec(this,e)};O().prototype.oneHot=function(e,t=1,r=0){return this.throwIfDisposed(),cd(this,e,t,r)};O().prototype.onesLike=function(){return this.throwIfDisposed(),_r(this)};O().prototype.pad=function(e,t){return this.throwIfDisposed(),Ap(this,e,t)};O().prototype.pool=function(e,t,r,n,o,s){return this.throwIfDisposed(),HL(this,e,t,r,n,o,s)};O().prototype.pow=function(e){return this.throwIfDisposed(),rs(this,e)};O().prototype.prelu=function(e){return this.throwIfDisposed(),Dp(this,e)};O().prototype.prod=function(e,t){return this.throwIfDisposed(),qL(this,e,t)};O().prototype.reciprocal=function(){return this.throwIfDisposed(),l_(this)};O().prototype.relu=function(){return this.throwIfDisposed(),mo(this)};O().prototype.relu6=function(){return this.throwIfDisposed(),Yw(this)};O().prototype.reshapeAs=function(e){return this.throwIfDisposed(),L(this,e.shape)};O().prototype.reshape=function(e){return this.throwIfDisposed(),L(this,e)};O().prototype.resizeBilinear=function(e,t,r){return this.throwIfDisposed(),o1(this,e,t,r)};O().prototype.resizeNearestNeighbor=function(e,t,r){return this.throwIfDisposed(),s1(this,e,t,r)};O().prototype.reverse=function(e){return this.throwIfDisposed(),Ro(this,e)};O().prototype.rfft=function(){return this.throwIfDisposed(),p_(this)};O().prototype.round=function(){return this.throwIfDisposed(),Cx(this)};O().prototype.rsqrt=function(){return this.throwIfDisposed(),Sx(this)};O().prototype.selu=function(){return this.throwIfDisposed(),kx(this)};O().prototype.separableConv2d=function(e,t,r,n,o,s){return this.throwIfDisposed(),Tx(this,e,t,r,n,o,s)};O().prototype.sigmoid=function(){return this.throwIfDisposed(),es(this)};O().prototype.sign=function(){return this.throwIfDisposed(),u_(this)};O().prototype.sin=function(){return this.throwIfDisposed(),Nx(this)};O().prototype.sinh=function(){return this.throwIfDisposed(),Ix(this)};O().prototype.slice=function(e,t){return this.throwIfDisposed(),Kt(this,e,t)};O().prototype.softmax=function(e){return this.throwIfDisposed(),$p(this,e)};O().prototype.softplus=function(){return this.throwIfDisposed(),Ei(this)};O().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),vd(this,e,t)};O().prototype.split=function(e,t){return this.throwIfDisposed(),wr(this,e,t)};O().prototype.sqrt=function(){return this.throwIfDisposed(),Se(this)};O().prototype.square=function(){return this.throwIfDisposed(),Vt(this)};O().prototype.squaredDifference=function(e){return this.throwIfDisposed(),uM(this,e)};O().prototype.squeeze=function(e){return this.throwIfDisposed(),Ms(this,e)};O().prototype.stack=function(e,t){this.throwIfDisposed();let r=e instanceof qt?[this,e]:[this,...e];return Cr(r,t)};O().prototype.step=function(e){return this.throwIfDisposed(),zs(this,e)};O().prototype.stridedSlice=function(e,t,r,n,o,s,i,a){return this.throwIfDisposed(),f_(this,e,t,r,n,o,s,i,a)};O().prototype.sub=function(e){return this.throwIfDisposed(),yt(this,e)};O().prototype.sum=function(e,t){return this.throwIfDisposed(),ht(this,e,t)};O().prototype.tan=function(){return this.throwIfDisposed(),m_(this)};O().prototype.tanh=function(){return this.throwIfDisposed(),dd(this)};O().prototype.tile=function(e){return this.throwIfDisposed(),Zr(this,e)};O().prototype.toBool=function(){return this.throwIfDisposed(),et(this,"bool")};O().prototype.toFloat=function(){return this.throwIfDisposed(),et(this,"float32")};O().prototype.toInt=function(){return this.throwIfDisposed(),et(this,"int32")};O().prototype.topk=function(e,t){return this.throwIfDisposed(),cM(this,e,t)};O().prototype.transpose=function(e){return this.throwIfDisposed(),Lt(this,e)};O().prototype.unique=function(e){return this.throwIfDisposed(),pM(this,e)};O().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Zw(this,e,t)};O().prototype.unstack=function(e){return this.throwIfDisposed(),pn(this,e)};O().prototype.where=function(e,t){return this.throwIfDisposed(),Ie(e,this,t)};O().prototype.zerosLike=function(){return this.throwIfDisposed(),kt(this)};var Gn=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Gn.prototype)}},en=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,en.prototype)}},z=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}},It=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,It.prototype)}},Dd=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Dd.prototype)}};var Ox=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let r;return this.cache.has(t)&&(r=this.cache.get(t),this.cache.delete(t),this.cache.set(t,r)),r}put(t,r){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,r)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let r=0;r<this.maxEntries-t;r++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function is(e,t){if(Array.isArray(e)){let r=[];for(let n=0;n<t;n++)r=r.concat(e);return r}else{let r=new Array(t);return r.fill(e),r}}function $o(e,t){if(!e)throw new Dd(t)}function T_(e,t){let r=0;for(let n of e)n===t&&r++;return r}function Ar(e){return e.length===1?e[0]:e}function fe(e){return Array.isArray(e)?e:[e]}function as(e){let r=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return r[0]!=="_"?r:"private"+r}function fl(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,r)=>r.toUpperCase())}var ss={};function Rd(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function k_(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>k_(t));else{let t=Object.keys(e);for(let r of t){let n=e[r];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?e[r]=n.value:k_(n))}}}function Di(e,t={},r={},n="object",o=!1){if(typeof e=="string"){let s=e,i;if(s in r)i=r[s];else if(s in ss)i=ss[s];else if(i=t[s],i==null)throw new z(`Unknown ${n}: ${e}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,l;if(i in r?[a,l]=r[i]:i in ss?[a,l]=ss.className:i in t&&([a,l]=t[i]),a==null)throw new z(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let m of Object.keys(ss))u[m]=ss[m];for(let m of Object.keys(r))u[m]=r[m];let c=s.config;c.customObjects=u;let p=Object.assign({},ss);for(let m of Object.keys(r))ss[m]=r[m];k_(s.config);let f=l(a,s.config,r,o);return ss=Object.assign({},p),f}else{let u=Object.assign({},ss);for(let p of Object.keys(r))ss[p]=r[p];let c=new a(s.config);return ss=Object.assign({},u),c}}}function _st(e,t){return e<t?-1:e>t?1:0}function Fx(e,t){return-1*_st(e,t)}function ls(e){if(e==null)return e;let t=[];for(let r of e)t.indexOf(r)===-1&&t.push(r);return t}function F3(e){if(e==null)throw new z(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ri(e,t,r){if(r!=null&&e.indexOf(r)<0)throw new z(`${r} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function u1(e,t,r=0,n=1/0){return $o(r>=0),$o(n>=r),Array.isArray(e)&&e.length>=r&&e.length<=n&&e.every(o=>typeof o===t)}function je(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((r,n)=>je(r,`element ${n+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${P3(e)}.`)}function P3(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>P3(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function L3(e,t,r){let n=r!=null?r():w.now(),o;return(...i)=>{let a=r!=null?r():w.now();return a-n<t||(n=a,o=e(...i)),o}}function c1(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Ast=0;function f1(){return Ast++}var p1={};function nc(e=""){return e in p1||(p1[e]=0),p1[e]+=1,e+p1[e].toString()}var M3=["channelsFirst","channelsLast"],z3=["nearest","bilinear"],B3=["valid","same","causal"],V3=["max","avg"],W3=["sum","mul","concat","ave"];var $d=new Map;function _e(e){Ri(M3,"DataFormat",e)}function U3(e){Ri(z3,"InterpolationFormat",e)}function Nn(e){Ri(B3,"PaddingMode",e)}function N_(e){Ri(V3,"PoolMode",e)}var Px=[],G3="/";function Ws(e,t){Px.push(e);try{let r=t();return Px.pop(),r}catch(r){throw Px.pop(),r}}function Dst(){return Px.length===0?"":Px.join(G3)+G3}function m1(e){if(!H3(e))throw new Error("Not a valid tensor name: '"+e+"'");return Dst()+e}function d1(e){if(!H3(e))throw new Error("Not a valid tensor name: '"+e+"'");$d.has(e)||$d.set(e,0);let t=$d.get(e);if($d.set(e,$d.get(e)+1),t>0){let r=`${e}_${t}`;return $d.set(r,1),r}else return e}var Rst=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function H3(e){return!!e.match(Rst)}function q3(e){return e===parseInt(e.toString(),10)}function us(e,t,r){t==null&&(t=0),r==null&&(r=e.length);let n=1;for(let o=t;o<r;++o)n*=e[o];return n}function Bp(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let r=0;r<e.length;r++){let n=e[r];n<t&&(t=n)}return t}function Gs(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let r=0;r<e.length;r++){let n=e[r];n>t&&(t=n)}return t}function In(e,t){if(t<e)throw new z(`end (${t}) < begin (${e}) is forbidden.`);let r=[];for(let n=e;n<t;++n)r.push(n);return r}var I_;function ar(){return I_==null&&(I_=mL().epsilon()),I_}function En(){return"channelsLast"}function fn(e,t){return et(e,t)}function dl(e,t=-1){let r=e.shape.slice();return t<0&&(t=r.length+t+1),r.splice(t,0,1),L(e,r)}function j3(e,t){return V(()=>{if(e.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let r=dl(e,1);return g1(r,[1,t,1])})}function K3(e){let t=[us(e.shape)];return L(e,t)}function X3(e){if(e.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],us(e.shape,1)];return L(e,t)}function ml(e,t,r){return V(()=>{switch(e.rank){case 1:return Ex(e,t,r);case 2:return Qw(e,[t,0],[r,e.shape[1]]);case 3:return _x(e,[t,0,0],[r,e.shape[1],e.shape[2]]);case 4:return Cd(e,[t,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Kt(e,[t,0,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Kt(e,[t,0,0,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function E_(e,t,r){return V(()=>{switch(e.rank){case 1:return Ex(e,t,r);case 2:return Qw(e,[0,t],[e.shape[0],r]);case 3:return _x(e,[0,0,t],[e.shape[0],e.shape[1],r]);case 4:return Cd(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],r]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Lx(e,t,r,n){return V(()=>{switch(e.rank){case 1:return Ex(e,t,r);case 2:switch(n){case 1:return ml(e,t,r);case 2:return E_(e,t,r);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return ml(e,t,r);case 2:return _x(e,[0,t,0],[e.shape[0],r,e.shape[2]]);case 3:return E_(e,t,r);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return ml(e,t,r);case 2:return Cd(e,[0,t,0,0],[e.shape[0],r,e.shape[2],e.shape[3]]);case 3:return Cd(e,[0,0,t,0],[e.shape[0],e.shape[1],r,e.shape[3]]);case 4:return E_(e,t,r);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Od(e,t=-1){let r;return t<0&&(r=e[0].rank,r!==0?t=r:t=0),t===e[0].rank&&(t=-1),Ce(e,t)}function A_(e,t){switch(e.rank){case 1:return LE([e,t]);case 2:return ME([e,t],0);case 3:return zE([e,t],0);case 4:return BE([e,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function g1(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Zr(e,t)}function Fd(e,t=0,r=1,n,o){return Xw(e,t,r,n,o)}function cs(e,t,r,n){if(e.rank<2||t.rank<2)throw new It(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new It(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Mp.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:n?__(e.rank,n,En()):null,activation:r});{let o=e.shape.slice(),s=o.pop();e=L(e,[-1,s]);let i=t.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:t.rank},(d,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=L(Lt(t,c),[l,-1]);let p=[...o,...u],f=!1,m=!1;return L(Mp.matMul({a:e,b:t,transposeA:f,transposeB:m,bias:n?__(e.rank,n,En()):null,activation:r}),p)}}function x1(e,t,r){return V(()=>(Array.isArray(t)?t=gr(t,"int32"):t=et(t,"int32"),Np(e,t,r)))}function Vp(e){return F(e,e)}function __(e,t,r){let n=t.shape;if(t.rank!==1&&t.rank!==e)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(r==="channelsFirst")return n.length===1?L(t,[1,n[0],1,1,1]):L(t,[1,n[3],n[0],n[1],n[2]]);if(r==="channelsLast")return n.length===1?L(t,[1,1,1,1,n[0]]):L(t,[1].concat(n))}else if(e===4){if(r==="channelsFirst")return n.length===1?L(t,[1,n[0],1,1]):L(t,[1,n[2],n[0],n[1]]);if(r==="channelsLast")return n.length===1?L(t,[1,1,1,n[0]]):L(t,[1].concat(n))}else if(e===3){if(r==="channelsFirst")return n.length===1?L(t,[1,n[0],1]):L(t,[1,n[1],n[0]]);if(r==="channelsLast")return n.length===1?L(t,[1,1,n[0]]):L(t,[1].concat(n))}else if(e<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function _n(e,t,r){return V(()=>(r==null&&(r=En()),_e(r),tt(e,__(e.rank,t,r))))}function Y3(e,t=1){if(t!==1)throw new It(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return ll(e)}function Q3(e){return V(()=>mt(e,tt(ir(e),1)))}function y1(e,t,r,n){return V(()=>dM(e,t,r,n))}function Z3(e){return V(()=>{let t=tt(.5,F(.2,e));return zr(t,0,1)})}function oc(e,t,r=!1){return r?e():t()}var J3=["fanIn","fanOut","fanAvg"],tB=["normal","uniform","truncatedNormal"];function $st(e){Ri(J3,"FanMode",e)}function Ost(e){Ri(tB,"Distribution",e)}var An=class extends Z.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Mx=class extends An{apply(t,r){return ke(t,r)}};Mx.className="Zeros";Z.registerClass(Mx);var Wp=class extends An{apply(t,r){return fo(t,r)}};Wp.className="Ones";Z.registerClass(Wp);var zx=class extends An{constructor(t){if(super(),typeof t!="object")throw new z(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new z(`config must have value set but got ${t}`);this.value=t.value}apply(t,r){return V(()=>F(At(this.value),fo(t,r)))}getConfig(){return{value:this.value}}};zx.className="Constant";Z.registerClass(zx);var Bx=class extends An{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,r){return cl(t,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Bx.className="RandomUniform";Z.registerClass(Bx);var Vx=class extends An{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new It(`randomNormal does not support dType ${r}.`);return Fd(t,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Vx.className="RandomNormal";Z.registerClass(Vx);var Wx=class extends An{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new It(`truncatedNormal does not support dType ${r}.`);return Rx(t,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Wx.className="TruncatedNormal";Z.registerClass(Wx);var Gx=class extends An{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,r){return V(()=>{if(t.length!==2||t[0]!==t[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return F(this.gain,xd(t[0]))})}getConfig(){return{gain:this.gain}}};Gx.className="Identity";Z.registerClass(Gx);function Fst(e,t="channelsLast"){let r,n;if(_e(t),e.length===2)r=e[0],n=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let o=us(e,2);r=e[1]*o,n=e[0]*o}else if(t==="channelsLast"){let o=us(e,0,e.length-2);r=e[e.length-2]*o,n=e[e.length-1]*o}}else{let o=us(e);r=Math.sqrt(o),n=Math.sqrt(o)}return[r,n]}var mn=class extends An{constructor(t){if(super(),t.scale<0)throw new z(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,$st(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Ost(this.distribution),this.seed=t.seed}apply(t,r){let n=Fst(t),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(r=r||"float32",r!=="float32"&&r!=="int32")throw new It(`${this.getClassName()} does not support dType ${r}.`);return Rx(t,0,a,r,this.seed)}else{let a=Math.sqrt(3*i);return cl(t,-a,a,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};mn.className="VarianceScaling";Z.registerClass(mn);var Pd=class extends mn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return mn.className}};Pd.className="GlorotUniform";Z.registerClass(Pd);var Ld=class extends mn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return mn.className}};Ld.className="GlorotNormal";Z.registerClass(Ld);var Md=class extends mn{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return mn.className}};Md.className="HeNormal";Z.registerClass(Md);var zd=class extends mn{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return mn.className}};zd.className="HeUniform";Z.registerClass(zd);var Bd=class extends mn{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return mn.className}};Bd.className="LeCunNormal";Z.registerClass(Bd);var Vd=class extends mn{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return mn.className}};Vd.className="LeCunNormal";Z.registerClass(Vd);var Ux=class extends An{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new It("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,r){return V(()=>{if(t.length<2)throw new It("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,o=Fd(n,0,1,"float32"),s=PM.gramSchmidt(o);return t[0]>t[1]&&(s=Lt(s)),F(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Ux.className="Orthogonal";Z.registerClass(Ux);var eB={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function rB(e,t={}){return Di(e,Z.SerializationMap.getMap().classNameMap,t,"initializer")}function be(e){return Rd(e)}function le(e){if(typeof e=="string"){let t=e in eB?eB[e]:e;if(t==="GlorotNormal")return new Ld;if(t==="GlorotUniform")return new Pd;if(t==="HeNormal")return new Md;if(t==="HeUniform")return new zd;if(t==="LeCunNormal")return new Bd;if(t==="LeCunUniform")return new Vd;{let r={};return r.className=t,r.config={},rB(r)}}else return e instanceof An?e:rB(e)}function b1(e){return Array.isArray(e)&&Array.isArray(e[0])}function Wd(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Et(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new z(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Mt(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new z(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Gd(e){let t=0;for(let r of e)r.shape.length===0?t+=1:t+=r.shape.reduce((n,o)=>n*o);return t}var oB="Variable",Hx=class{constructor(t,r="float32",n=oB,o=!0,s=null){this.dtype=r==null?"float32":r,this.shape=t.shape,this.id=f1(),n=n==null?oB:n,this.originalName=m1(n),this.name=d1(this.originalName),this.trainable_=o,this.constraint=s,this.val=d_(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Lst(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function Lst(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function qx(e){return e.map(t=>t.read())}function Ud(e){e.forEach(t=>{t[0].write(t[1])})}var me=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},dn=class{constructor(t,r,n,o,s,i,a){this.dtype=t,this.shape=r,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=f1(),i!=null&&(this.originalName=m1(i),this.name=d1(this.originalName)),this.rank=r.length}},Mst=0,hl=class{constructor(t,r){this.callArgs=r,this.id=Mst++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let r of this.inboundLayers)r!=null?t.push(r.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},zst=0,Ot=class extends Z.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=zst++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let r=t.name;if(!r){let n=this.getClassName();r=as(n)+"_"+nc(n)}if(this.name=r,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,r){return t.name+"_ib-"+r.toString()}getNodeAtIndex(t,r){if(this.inboundNodes.length===0)throw new en(`The layer has never been called and thus has no defined ${r}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${r} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Ar(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ar(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Gn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Gn(`Layer ${this.name} is not connected, no input to return.`);return Ar(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Gn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Gn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ar(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(r=>r.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=fe(t),this.inputSpec==null||this.inputSpec.length===0)return;let r=fe(this.inputSpec);if(t.length!==r.length)throw new z(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let o=t[n],s=r[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let l in s.axes){let u=Number(l),c=s.axes[l],p=u>=0?a[u]:a[a.length+u];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let l=s.shape[a],u=o.shape[a];if(l!=null&&u!=null&&l!==u)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(t,r){return t}invokeCallHook(t,r){this._callHook!=null&&this._callHook(t,r)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,r){r=r||{},this.assertNotDisposed();let n=fe(t),o=!0;for(let i of n)if(!(i instanceof dn)){o=!1;break}let s=!0;for(let i of n)if(i instanceof dn){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ws(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of fe(t))i.push(a.shape);this.build(Ar(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,r),a=fe(i),l=[];for(let u of a)n.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=Ar(l),this.activityRegularizer!=null)throw new It("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=Bst(t),a=this.computeOutputShape(i),l,u=Vst(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,p)=>new dn(u,c,this,fe(t),r,this.name,p)):l=new dn(u,a,this,fe(t),r,this.name),this.addInboundNode(t,l,null,null,i,a,r),this._refCount++,this.activityRegularizer!=null)throw new It("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let r=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(r=!0)}),r&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Gn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let r of this.inboundNodes){let n=JSON.stringify(r.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let r=this.inboundNodes[0].outputShapes;return Array.isArray(r)&&Array.isArray(r[0])&&r.length===1?r[0]:r}else throw new Gn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new en(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Gd(this.weights)}build(t){this.built=!0}getWeights(t=!1){return qx(t?this.trainableWeights:this.weights)}setWeights(t){V(()=>{let r=this.weights;if(r.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${r.length} weights. Provided weights: ${t}...`);if(r.length===0)return;let n=[],o=qx(r);for(let s=0;s<o.length;++s){let i=o[s],a=r[s],l=t[s];if(!w.arraysEqual(i.shape,l.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);n.push([a,l])}Ud(n)})}addWeight(t,r,n,o,s,i,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=l!=null?l():le("zeros"));let u=o.apply(r,n),c=new Hx(u,n,t,i,a);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=fe(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,r){if(!this.supportsMasking){if(r!=null)if(Array.isArray(r))r.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return r}addInboundNode(t,r,n,o,s,i,a=null){let l=fe(t);r=fe(r),n=fe(n),o=fe(o),s=Wd(s),i=Wd(i);let u=[],c=[],p=[];for(let f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),p.push(f.tensorIndex);new hl({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:r,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let f=0;f<r.length;f++)r[f].sourceLayer=this,r[f].nodeIndex=this.inboundNodes.length-1,r[f].tensorIndex=f}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function Bst(e){e=fe(e);let t=[];for(let r of e)t.push(r.shape);return Ar(t)}function Vst(e){return"float32"}function D_(e,t,r){if((t==null||r!=null&&r>0)&&(t=e.sourceLayer,r=e.nodeIndex),t.inboundNodes.length===0)return[e];{let n=t.inboundNodes[r];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],l=n.nodeIndices[s],u=D_(i,a,l);for(let c of u)o.indexOf(c)===-1&&o.push(c)}return o}}}var $i=class extends Ot{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:nc("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=t.batchInputShape;if(r==null){if(t.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=r,this.dtype=n,this.inputSpec=[{shape:r}];let o=new dn(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new hl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(t,r){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};$i.className="InputLayer";Z.registerClass($i);function R_(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let r=e.dtype;return r==null&&(r="float32"),new $i({batchInputShape:t,name:e.name,dtype:r,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function Wst(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return et(t,e.dtype)}catch(r){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var ps=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof ps)for(let r in t.id2Value)this.id2Value[r]=t.id2Value[r],r in t.id2Mask&&(this.id2Mask[r]=t.id2Mask[r]);else{if(t==null)return;for(let r of t)this.add(r.key,r.value)}}add(t,r,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Wst(t,r),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof dn){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let r=this.name2Id[t];if(r==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[r]}}getMask(t){if(t instanceof dn){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let r=this.name2Id[t];if(r==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[r]}}disposeMasks(){this.id2Mask!=null&&$t(this.id2Mask)}},v1=new Ox,w1=new Ox;function iB(e){v1!=null&&v1.setMaxEntries(e),w1!=null&&w1.setMaxEntries(e)}function Gp(e,t,r,n){let o=r==null?!1:r.training,s=Array.isArray(e),i=s?e:[e],a=i.map(d=>d.name),l=[],u=t.names();for(let d of a)u.indexOf(d)!==-1?l.push(t.getValue(d)):l.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=v1.get(c),f;if(p==null){let d=Gst(i,t);p=d.sorted,f=d.recipientCounts,v1.put(c,p),w1.put(c,f)}f={},o||Object.assign(f,w1.get(c));let m=new ps(t);for(let d=0;d<p.length;++d){if(n!=null){let D=ux().numTensors;D>n.maxNumTensors&&(n.maxNumTensors=D),D<n.minNumTensors&&(n.minNumTensors=D)}let h=p[d],x=h.sourceLayer;if(x instanceof $i)continue;let g=[],y=[],b=[],v=!1;for(let D of h.inputs){let R=m.getValue(D),M=m.getMask(D);g.push(R),y.push(M),M!=null&&(v=!0),o||(f[D.name]--,f[D.name]===0&&!t.hasKey(D)&&a.indexOf(D.name)===-1&&!R.isDisposed&&D.sourceLayer.stateful!==!0&&b.push(R))}v&&(r=r||{},r.mask=y[0]);let C=fe(x.apply(g,r)),S=null;x.supportsMasking&&(S=x.computeMask(g,y));let k=Hst(h),I=Array.isArray(k)?k:[k];for(let D=0;D<I.length;++D){m.hasKey(I[D])||m.add(I[D],C[D],Array.isArray(S)?S[0]:S);let R=a.indexOf(I[D].name);R!==-1&&(l[R]=C[D])}o||$t(b)}return m.disposeMasks(),s?l:l[0]}function Gst(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let r=[],n={};if(e.length===1){let o=sB(e[0],t);r=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of e){let{sorted:i,recipientMap:a}=sB(s,t);for(let l of i)o.has(l.name)||(r.push(l),o.add(l.name));for(let l in a)n[l]==null&&(n[l]=new Set),a[l].forEach(u=>n[l].add(u))}}return{sorted:r,recipientCounts:Ust(n)}}function Ust(e){let t={};for(let r in e)t[r]=e[r].size;return t}function sB(e,t){let r=new Set,n=[],o={};for(let a of t.names())r.add(a);let s=[],i=[];for(s.push(e);s.length>0;){let a=s[s.length-1];if(r.has(a.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),n.push(a),r.add(a.name),l&&i.pop();else{i.push(s.length-1);for(let u of a.inputs)o[u.name]==null&&(o[u.name]=new Set),o[u.name].add(a.name),!r.has(u.name)&&s.push(u)}}return{sorted:n,recipientMap:o}}function Hst(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let r=null;for(let n=0;n<e.sourceLayer.inboundNodes.length;++n)for(let o of e.sourceLayer.inboundNodes[n].outputTensors)if(o.id===e.id){r=n;break}t=e.sourceLayer.getOutputAt(r)}return t}var qst=B();qst.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,iB);function $_(e,t){return V(()=>Se(ht(F(e,e),t,!0)))}var Up=class extends Z.Serializable{getConfig(){return{}}},jx=class extends Up{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return V(()=>{let r=$_(t,this.axis),n=zr(r,0,this.maxValue);return F(t,mt(n,tt(ar(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};jx.className="MaxNorm";Z.registerClass(jx);var Kx=class extends Up{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return V(()=>mt(t,tt(ar(),$_(t,this.axis))))}getConfig(){return{axis:this.axis}}};Kx.className="UnitNorm";Z.registerClass(Kx);var Xx=class extends Up{apply(t){return mo(t)}};Xx.className="NonNeg";Z.registerClass(Xx);var Yx=class extends Up{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return V(()=>{let r=$_(t,this.axis),n=tt(F(this.rate,zr(r,this.minValue,this.maxValue)),F(1-this.rate,r));return F(t,mt(n,tt(ar(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Yx.className="MinMaxNorm";Z.registerClass(Yx);var aB={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Oe(e){return Rd(e)}function lB(e,t={}){return Di(e,Z.SerializationMap.getMap().classNameMap,t,"constraint")}function Fe(e){if(e==null)return null;if(typeof e=="string"){let r={className:e in aB?aB[e]:e,config:{}};return lB(r)}else return e instanceof Up?e:lB(e)}function gl(e){return H(this,null,function*(){if(e==null)return;let t=[],r=[],n=[];for(let o in e){let s=e[o];if(typeof s!="number"){let i=s;t.push(i.data()),r.push(o),n.push(i)}}if(t.length>0){let o=yield Promise.all(t);for(let s=0;s<o.length;++s)e[r[s]]=o[s][0];$t(n)}})}function C1(e){if(e!=null)for(let t in e){let r=e[t];typeof r!="number"&&r.dispose()}}var uB;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(uB||(uB={}));var Xst=125,sc=class{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,r){return H(this,null,function*(){})}onEpochEnd(t,r){return H(this,null,function*(){})}onBatchBegin(t,r){return H(this,null,function*(){})}onBatchEnd(t,r){return H(this,null,function*(){})}onTrainBegin(t){return H(this,null,function*(){})}onTrainEnd(t){return H(this,null,function*(){})}setModel(t){}},S1=class{constructor(t,r=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=r}append(t){this.callbacks.push(t)}setParams(t){for(let r of this.callbacks)r.setParams(t)}setModel(t){for(let r of this.callbacks)r.setModel(t)}onEpochBegin(t,r){return H(this,null,function*(){r==null&&(r={});for(let n of this.callbacks)yield n.onEpochBegin(t,r)})}onEpochEnd(t,r){return H(this,null,function*(){r==null&&(r={});for(let n of this.callbacks)yield n.onEpochEnd(t,r)})}onBatchBegin(t,r){return H(this,null,function*(){r==null&&(r={});for(let n of this.callbacks)yield n.onBatchBegin(t,r)})}onBatchEnd(t,r){return H(this,null,function*(){r==null&&(r={});for(let n of this.callbacks)yield n.onBatchEnd(t,r)})}onTrainBegin(t){return H(this,null,function*(){t==null&&(t={});for(let r of this.callbacks)yield r.onTrainBegin(t)})}onTrainEnd(t){return H(this,null,function*(){t==null&&(t={});for(let r of this.callbacks)yield r.onTrainEnd(t)})}},O_=class extends sc{constructor(){super()}onEpochBegin(t){return H(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(t,r){return H(this,null,function*(){r==null&&(r={});let n=r.size==null?0:r.size;this.seen+=n;for(let o in r){let s=r[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=V(()=>tt(this.totals[o],F(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}})}onEpochEnd(t,r){return H(this,null,function*(){if(r!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?r[n]=this.totals[n]/this.seen:V(()=>{let o=F(mt(1,this.seen),this.totals[n]);r[n]=o,this.totals[n].dispose(),Ir(r[n])}))})}},k1=class extends sc{onTrainBegin(t){return H(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(t,r){return H(this,null,function*(){r==null&&(r={}),this.epoch.push(t);for(let n in r)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(r[n])})}syncData(){return H(this,null,function*(){let t=[],r=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let l=i[a];t.push(l.data()),r.push(s),n.push(a)}}let o=yield Promise.all(t);for(let s=0;s<o.length;++s)this.history[r[s]][n[s]].dispose(),this.history[r[s]][n[s]]=o[s][0]})}},T1=class extends sc{constructor(t,r){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||$x,this.yieldEvery=r||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Xst),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=L3(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,r,n){return H(this,null,function*(){let o=[];this.yield!=null&&(yield gl(n),o.push(this.yield(t,r,n))),o.push(this.nextFrameFunc()),yield Promise.all(o)})}onEpochBegin(t,r){return H(this,null,function*(){this.currentEpoch=t,this.epochBegin!=null&&(yield gl(r),yield this.epochBegin(t,r))})}onEpochEnd(t,r){return H(this,null,function*(){let n=[];this.epochEnd!=null&&(yield gl(r),n.push(this.epochEnd(t,r))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),yield Promise.all(n)})}onBatchBegin(t,r){return H(this,null,function*(){this.batchBegin!=null&&(yield gl(r),yield this.batchBegin(t,r))})}onBatchEnd(t,r){return H(this,null,function*(){let n=[];this.batchEnd!=null&&(yield gl(r),n.push(this.batchEnd(t,r))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,r)),yield Promise.all(n)})}onTrainBegin(t){return H(this,null,function*(){this.trainBegin!=null&&(yield gl(t),yield this.trainBegin(t))})}onTrainEnd(t){return H(this,null,function*(){this.trainEnd!=null&&(yield gl(t),yield this.trainEnd(t))})}};function N1(e,t){return e==null&&(e={}),e instanceof sc?[e]:Array.isArray(e)&&e[0]instanceof sc?e:fe(e).map(n=>new T1(n,t))}var Un=class{constructor(){}static registerCallbackConstructor(t,r){w.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Un.checkForDuplicate(r),Un.constructors[t]==null&&(Un.constructors[t]=[]),Un.constructors[t].push(r)}static checkForDuplicate(t){for(let r in Un.constructors)Un.constructors[+r].forEach(o=>{if(o===t)throw new z("Duplicate callback constructor.")})}static clear(){Un.constructors={}}static createCallbacks(t){let r=[];for(let n in Un.constructors){let o=+n;t>=o&&r.push(...Un.constructors[o])}return r.map(n=>new n)}};Un.constructors={};function I1(e,t,r,n,o,s,i,a,l){let u=new k1,c=[new O_,...Un.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let p=new S1(c);return p.setParams({epochs:r,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:l}),{callbackList:p,history:u}}function ho(e,t={},r=!1){return Di(e,Z.SerializationMap.getMap().classNameMap,t,"layer",r)}function Qx(e,t){return V(()=>{e.dtype!=="float32"&&(e=et(e,"float32"));let r=ht(Vp(e),t,!0),n=il(r.shape,ar()),o=Se(po(r,n));return mt(e,o)})}function Hp(e,t){return V(()=>Ee(Vp(yt(t,e)),-1))}function Jx(e,t){return V(()=>Ee(ir(yt(t,e)),-1))}function ty(e,t){return V(()=>{let r=yt(e,t),n=zr(ir(e),ar(),Number.MAX_VALUE),o=ir(mt(r,n));return F(100,Ee(o,-1))})}function Yst(e,t){return V(()=>{let r=zr(t,ar(),Number.MAX_VALUE),n=Tn(tt(1,r)),o=zr(e,ar(),Number.MAX_VALUE),s=Tn(tt(1,o));return Ee(Vp(yt(n,s)),-1)})}function Qst(e,t){return V(()=>{let r=po(0,yt(1,F(e,t)));return Ee(Vp(r),-1)})}function Zst(e,t){return V(()=>{let r=po(0,yt(1,F(e,t)));return Ee(r,-1)})}function Jst(e,t){return V(()=>{let r=ht(F(e,t),-1),n=Br(F(yt(1,e),t),-1);return po(0,tt(1,yt(n,r)))})}function tit(e,t){return V(()=>{let r=Math.log(2),n=yt(t,e),o=yt(tt(n,Ei(F(-2,n))),r);return Ee(o,-1)})}function qp(e,t,r=!1){return V(()=>{if(r)t=$p(t);else{let n=ht(t,t.shape.length-1,!0);t=mt(t,n)}return t=zr(t,ar(),1-ar()),Zt(ht(F(et(e,"float32"),Tn(t)),t.shape.length-1))})}function Hd(e,t,r=!1){return V(()=>{let n=et(ul(K3(e)),"int32");t=zr(t,ar(),1-ar());let o=t.shape,s=L(cd(n,o[o.length-1]),o);return qp(s,t,r)})}function eit(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return V(()=>{let r=mo(t),n=Zt(ir(t));return tt(yt(r,F(t,e)),bx(Qr(n)))})}function qd(e,t){return V(()=>{let r;return r=zr(t,ar(),1-ar()),r=Tn(mt(r,yt(1,r))),Ee(eit(e,r),-1)})}function rit(e,t){return V(()=>{let r=zr(e,ar(),1),n=zr(t,ar(),1);return ht(F(e,Tn(mt(r,n))),-1)})}function nit(e,t){return V(()=>{let r=Tn(tt(ar(),t));return Ee(yt(t,F(e,r)),-1)})}function E1(e,t){return V(()=>{let r=Qx(e,-1),n=Qx(t,-1),o=F(r,n);return Zt(ht(o,-1))})}var Zx={meanSquaredError:Hp,meanAbsoluteError:Jx,meanAbsolutePercentageError:ty,meanSquaredLogarithmicError:Yst,squaredHinge:Qst,hinge:Zst,categoricalHinge:Jst,logcosh:tit,categoricalCrossentropy:qp,sparseCategoricalCrossentropy:Hd,binaryCrossentropy:qd,kullbackLeiblerDivergence:rit,poisson:nit,cosineProximity:E1};function _1(e){if(typeof e=="string"){if(e in Zx)return Zx[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}else return e}function D1(e,t){return V(()=>{let r=F(.5,_r(t)),n=fn(We(t,r),e.dtype);return Ee(kn(e,n),-1)})}function R1(e,t){return V(()=>fn(kn(ol(e,-1),ol(t,-1)),"float32"))}function oit(e,t){return V(()=>et(ht(cn(kn(e,1),kn(t,1))),"float32"))}function sit(e,t){return V(()=>et(ht(cn(kn(e,0),kn(t,1))),"float32"))}function pB(e,t){return V(()=>{let r=oit(e,t),n=sit(e,t),o=tt(r,n);return et(Ie(We(o,0),mt(r,o),0),"float32")})}function F_(e,t){return qd(e,t)}function P_(e,t){return e.rank===t.rank&&(e=Ms(e,[e.rank-1])),t=ol(t,-1),t.dtype!==e.dtype&&(t=et(t,e.dtype)),et(kn(e,t),"float32")}var iit=Hp,ait=Hp,lit=Jx,uit=Jx,cit=ty,pit=ty,$1=qp,fit=E1,L_=Hd,A1={binaryAccuracy:D1,categoricalAccuracy:R1,precision:pB,categoricalCrossentropy:$1,sparseCategoricalCrossentropy:L_,mse:iit,MSE:ait,mae:lit,MAE:uit,mape:cit,MAPE:pit,cosine:fit};function fB(e){if(typeof e=="string"&&e in A1)return A1[e];if(typeof e!="string"&&e!=null)return e;throw new z(`Unknown metric ${e}`)}function ey(e){if($o(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let r of Object.keys(Zx))if(Zx[r]===e){t=r;break}if(t!==void 0)return t;for(let r of Object.keys(A1))if(A1[r]===e){t=r;break}return t!==void 0?t:e.name}}function dB(e){let t={Adagrad:()=>zp.adagrad(.01),Adadelta:()=>zp.adadelta(1,.95,ar()),Adam:()=>zp.adam(.001,.9,.999,ar()),Adamax:()=>zp.adamax(.002,.9,.999,ar(),0),RMSProp:()=>zp.rmsprop(.001,.9,0,ar()),SGD:()=>zp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new z(`Unknown Optimizer ${e}`)}function z_(e,t,r=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!M_(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(r){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function M_(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let r of t)if(typeof r!="string"||!M_(e[r]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!M_(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function hB(e,t,r,n=console.log){let o=hit(e),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,r=r||[.32,.61,.89,1]):(t=t||115,r=r||[.24,.48,.7,.8,1]),r[r.length-1]<=1&&(r=r.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}n("_".repeat(t)),O1(s,r,n),n("=".repeat(t));let a=e.layers;for(let c=0;c<a.length;++c)o?git(a[c],r,n):xit(a[c],r,i,n),n((c===a.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=dit(e),u=Gd(e.nonTrainableWeights);n(`Total params: ${l+u}`),n(`Trainable params: ${l}`),n(`Non-trainable params: ${u}`),n("_".repeat(t))}function dit(e){let t;return e.collectedTrainableWeights!=null?t=Gd(e.collectedTrainableWeights):t=Gd(e.trainableWeights),t}function hit(e){let t=!0,r=[],n=[];for(let o in e.nodesByDepth)r.push(e.nodesByDepth[o]);for(let o of r){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of e.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function O1(e,t,r=console.log){let n="";for(let o=0;o<e.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=e[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);r(n)}function git(e,t,r){let n,o;try{o=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){o="multiple"}try{n=JSON.stringify(e.outputShape)}catch(l){n="multiple"}let s=e.name,i=e.getClassName(),a=[`${s} (${i})`,o,n,e.countParams().toString()];O1(a,t,r)}function xit(e,t,r,n){let o,s;try{s=e.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(e.outputShape)}catch(p){o="multiple"}let i=[];for(let p of e.inboundNodes)if(!(r!=null&&r.length>0&&r.indexOf(p)===-1))for(let f=0;f<p.inboundLayers.length;++f){let m=p.inboundLayers[f].name,d=p.nodeIndices[f],h=p.tensorIndices[f];i.push(`${m}[${d}][${h}]`)}let a=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,s,o,e.countParams().toString(),u];O1(c,t,n);for(let p=1;p<i.length;++p)O1(["","","","",i[p]],t,n)}function gB(e,t,r){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof r=="string"}function ry(e,t){if(e===null)return null;if(typeof e=="string")return fl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let r=[],n=e.length;for(let o=0;o<n;++o){let s=e[o];gB(t,o,s)?r.push(s):r.push(ry(s,t))}return r}else{let r={};for(let n of Object.keys(e)){let o=e[n];if(n==="name"&&typeof o=="string")r[n]=o;else{let s=fl(n);r[s]=ry(o,s)}}return r}}function F1(e,t){if(e==null)return null;if(typeof e=="string")return as(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let r=[],n=e.length;for(let o=0;o<n;++o){let s=e[o];gB(t,o,s)?r.push(s):r.push(F1(s,t))}return r}else{let r={};for(let n of Object.keys(e)){let o=e[n],s=as(n);(n==="name"||n==="className")&&typeof o=="string"?r[s]=o:r[s]=F1(o,n)}return r}}var jd="4.1.0";var go=class extends Ot{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=nc(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ls(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);ls(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let b=y.sourceLayer,v=y.nodeIndex,C=y.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(C)}for(let y of this.inputs){let b=y.sourceLayer,v=y.nodeIndex,C=y.tensorIndex;$o(v===0,"input layer has >1 nodes"),$o(C===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let b=this.inputLayers[y];if(!(b instanceof $i))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let r={},n={},o={},s={},i={},a=[],l=(y,b,v,C,S,k)=>{(C==null||S==null||k==null)&&(C=y.sourceLayer,S=y.nodeIndex,k=y.tensorIndex);let I=C.inboundNodes[S];if(v.indexOf(I)!==-1)throw new en(`The tensor ${y.name} at layer "${C.name}" is part of a cycle.`);if(b.indexOf(I)!==-1)return;this.containerNodes.add(go.nodeKey(C,S)),C.id in i||(i[C.id]=Object.keys(i).length),v.indexOf(I)===-1&&v.push(I);let D=I.inboundLayers.length;for(let R=0;R<D;R++){let M=I.inputTensors[R],U=I.inboundLayers[R],j=I.nodeIndices[R],K=I.tensorIndices[R];l(M,b,v,U,j,K)}for(b.push(I);v.indexOf(I)>=0;)v.splice(v.indexOf(I),1);a.push(I)},u=[],c=[];for(let y of this.outputs)l(y,u,c);let p=a.slice().reverse();for(let y of p){n[y.id]=y,y.id in r||(r[y.id]=0);let b=r[y.id],v=o[y.outboundLayer.id]==null?0:o[y.outboundLayer.id];b=Math.max(b,v),o[y.outboundLayer.id]=b,s[y.outboundLayer.id]=y.outboundLayer,r[y.id]=b;for(let C=0;C<y.inboundLayers.length;C++){let S=y.inboundLayers[C],k=y.nodeIndices[C],I=S.inboundNodes[k],D=r[I.id]==null?0:r[I.id];r[I.id]=Math.max(b+1,D),n[I.id]=I}}let f={};for(let y in r){let b=r[y];b in f||(f[b]=[]),f[b].push(n[y])}let m={};for(let y in o){let b=o[y];b in m||(m[b]=[]),m[b].push(s[y])}let d=Object.keys(m).map(y=>parseInt(y,10)).sort(Fx);this.layers=[];for(let y of d){let b=m[y];b.sort((v,C)=>{let S=i[v.id],k=i[C.id];return S<k?-1:S>k?1:0});for(let v of b)v instanceof go&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=m,d=Object.keys(f).map(y=>parseInt(y,10)).sort(Fx);let h=this.inputs.slice(),x=[];for(let y of d)for(let b of f[y]){let v=b.outboundLayer;if(v!=null){for(let C of b.inputTensors)if(h.indexOf(C)===-1)throw new en(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${v.name}". The following previous layers were accessed without issue: ${x}`);for(let C of b.outputTensors)h.push(C);x.push(v.name)}}this.nodesByDepth=f;let g=this.layers.map(y=>y.name);for(let y of g){let b=g.filter(v=>v===y).length;if(b!==1)throw new en(`The name "${y}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new hl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let r of this.layers)t.numDisposedVariables+=r.dispose().numDisposedVariables;for(let r of this.internalContainerRefs)t.numDisposedVariables+=r.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(r=>{r._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let r of this.layers)t=t.concat(r.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let r of this.layers)t.push(...r.nonTrainableWeights);if(!this.trainable){let r=[];for(let n of this.layers)r.push(...n.trainableWeights);return r.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,r=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new z(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in t){let a=i;if(n[i]==null){let l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],t[i]]);else if(r)throw new z(`Provided weight data has no target variable: ${i}`);delete n[a]}if(r){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new z(`${i.length} of ${o} weights are not set: ${i}`)}Ud(s)}updatedConfig(){let t=this.getConfig(),r={};return r.className=this.getClassName(),r.config=t,r.kerasVersion=`tfjs-layers ${jd}`,r.backend="TensorFlow.js",r}toJSON(t,r=!0){let n=F1(this.updatedConfig());return r?JSON.stringify(n):n}call(t,r){return V(()=>{t=fe(t);let n=new ps;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return Gp(this.outputs,n,r)})}computeMask(t,r){return V(()=>{t=fe(t);let n;return r==null?n=is(null,t.length):n=fe(r),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let r=Wd(t);if(r.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<r.length;a++){let l=this.inputLayers[a],u=r[a],c=l.name+"_0_0";n[c]=u}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Fx);if(o.length>1)for(let a of o){let l=this.nodesByDepth[a];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<u.inboundLayers.length;h++){let x=u.inboundLayers[h],g=u.nodeIndices[h],y=u.tensorIndices[h],b=`${x.name}_${g}_${y}`,v=n[b];p.push(v)}let f=c.computeOutputShape(Ar(p)),m=Wd(f),d=c.inboundNodes.indexOf(u);for(let h=0;h<m.length;h++){let x=`${c.name}_${d}_${h}`;n[x]=m[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${l.name}_${u}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let l=i[a];$o(l in n),s.push(n[l])}return Ar(s)}runInternalGraph(t,r){r==null&&(r=is(null,t.length));let n={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],p=r[l];n[u.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Fx);for(let l of o){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,f=c.inputTensors,m=c.outputTensors,d=new Array;for(let h of f)h.id in n&&d.push(n[h.id]);if(d.length===f.length){let h={},x,g,y,b;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[v,C]=d[0];h.mask==null&&(h.mask=C),y=fe(p.call(v,h)),b=fe(p.computeMask(v,C)),x=[v],g=[C]}else x=d.map(v=>v[0]),g=d.map(v=>v[1]),h.mask==null&&(h.mask=g),y=fe(p.call(x,h)),b=fe(p.computeMask(x,g));if(p.activityRegularizer)throw new It("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<m.length;++v){let C=m[v],S=y[v],k=b[v];n[C.id]=[S,k]}}}}let s=[],i=[],a=[];for(let l of this.outputs){$o(l.id in n,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=n[l.id];a.push(u.shape),s.push(u),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let r={},n;for(let o of this.layers){n=o instanceof go?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=go.nodeKey(o,s);this.containerNodes.has(i)&&(r[i]=n,n+=1)}}return r}getLayer(t,r){if(r!=null){if(this.layers.length<=r)throw new z(`Was asked to retrieve layer at index ${r}, but model only has ${this.layers.length} layer(s).`);return this.layers[r]}else if(t==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new z(`No such layer: ${t}`)}calculateLosses(){return V(()=>{let t=[];for(let r of this.layers)for(let n=0;n<r.inboundNodes.length;++n){let o=go.nodeKey(r,n);this.containerNodes.has(o)&&t.push(...r.calculateLosses())}return t})}getConfig(){let t={name:this.name},r=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),l=i.getConfig(),u=[];for(let p=0;p<i.inboundNodes.length;p++){let f=i.inboundNodes[p],m=go.nodeKey(i,p),d={};if(this.containerNodes.has(m)){if(f.callArgs)try{JSON.stringify(f.callArgs),d=f.callArgs}catch(h){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(f.inboundLayers.length>0){let h=[];for(let x=0;x<f.inboundLayers.length;x++){let g=f.inboundLayers[x],y=f.nodeIndices[x],b=f.tensorIndices[x],v=go.nodeKey(g,y),C=r[v];C==null&&(C=0),h.push([g.name,C,b,d])}u.push(h)}}}let c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=go.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=r[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=go.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=r[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,r,n={},o=!1){let s={},i={};function a(x,g){x.name in i?i[x.name].push(g):i[x.name]=[g]}function l(x,g){let y=[],b;for(let v of g){let C=v[0],S=v[1],k=v[2];if(b=v[3]==null?{}:v[3],!(C in s)){a(x,g);return}let I=s[C];if(I.inboundNodes.length<=S){a(x,g);return}let D=I.inboundNodes[S];y.push(D.outputTensors[k])}y.length>0&&x.apply(Ar(y),b)}function u(x){let g=x.name,y=ho(x,r.customObjects!=null?r.customObjects:{});y.setFastWeightInitDuringBuild(o),s[g]=y,x.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${v}`);a(y,v)})}let c=r.name,p=r.layers;for(let x of p)u(x);for(;!F3(i);)for(let x of p){let g=s[x.name];if(g.name in i){let y=i[g.name];delete i[g.name];for(let b of y)l(g,b)}}let f=[],m=[],d=r.inputLayers;for(let x of d){let g=x[0],y=x[1],b=x[2];$o(g in s);let C=s[g].inboundNodes[y].outputTensors;f.push(C[b])}let h=r.outputLayers;for(let x of h){let g=x[0],y=x[1],b=x[2];$o(g in s);let C=s[g].inboundNodes[y].outputTensors;m.push(C[b])}return new t({inputs:f,outputs:m,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){V(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function yit(e,t,r){let n=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(o=>null);if(n===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==n)throw new Error(`Provided ${r} is an array of ${e.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let o=[];return t.forEach(s=>{s in e?o.push(e[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${r} must be either an array with ${n} elements or an object with ${t} keys. Provided ${r} not understood: ${JSON.stringify(e)}`)}function P1(e,t){return yit(e,t,"classWeight")}function L1(e,t,r,n){return H(this,null,function*(){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(r!=null){let o=V(()=>{if(e.shape.length===1)return lo(e);if(e.shape.length===2){if(e.shape[1]>1)return ol(e,1);if(e.shape[1]===1)return L(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield o.data());$t(o);let i=[];return s.forEach(a=>{if(r[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(r[a])}),gr(i,"float32")}else return null})}function xB(e,t){return F(e,t)}var bit=32;function vB(e,t){let r,n,o=t;r=o.xs,n=o.ys,w.assert(r!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=yB("input",e.inputNames,r),i=yB("output",e.outputNames,n),a=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===a,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function yB(e,t,r){if(r instanceof qt)return[r];if(Array.isArray(r))return w.assert(r.length===t.length,()=>`Received an array of ${r.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),r;{let n=[];for(let o of t){if(r[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${e} key '${o}'.`);n.push(r[o])}return n}}function vit(e){if(e.length===3)throw new It("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function wB(e,t,r){return H(this,null,function*(){let n=r.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(r!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(r.epochs!=null&&r.epochs>0&&Number.isInteger(r.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${r.epochs}`),w.assert(!n||r.batchesPerEpoch>0&&Number.isInteger(r.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${r.batchesPerEpoch}`),w.assert(r.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let o=r.validationData!=null,s,i;if(o)if(bB(r.validationData))w.assert(r.validationBatches==null||r.validationBatches>0&&Number.isInteger(r.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${r.validationBatches}`);else{let x=vit(r.validationData);s=x.xs,i=x.ys}let a=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;o?u=l.slice().concat(l.map(x=>"val_"+x)):u=l.slice();let c=N1(r.callbacks,r.yieldEvery),p=r.verbose==null?1:r.verbose,{callbackList:f,history:m}=I1(c,p,r.epochs,null,null,wit(t,r),null,o,u);f.setModel(e),e.history=m,yield f.onTrainBegin(),e.stopTraining_=!1;let d=r.initialEpoch==null?0:r.initialEpoch,h=yield t.iterator();for(;d<r.epochs;){let x={};yield f.onEpochBegin(d);let g=0,y=0;for(n||(h=yield t.iterator());!n||g<r.batchesPerEpoch;){let b=yield h.next();if(n&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${r.batchesPerEpoch}, but your dataset iterator ran out of data after ${g} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${r.batchesPerEpoch*r.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){let{xs:v,ys:C}=vB(e,b.value),S={};S.batch=y,S.size=v[0].shape[0],yield f.onBatchBegin(y,S);let k=[];if(r.classWeight!=null){let R=P1(r.classWeight,e.outputNames);for(let M=0;M<R.length;++M)k.push(yield L1(C[M],null,R[M]))}let I=v.concat(C).concat(k),D=a(I);$t(I);for(let R=0;R<l.length;++R){let M=l[R],U=D[R];S[M]=U,Ir(U)}yield f.onBatchEnd(y,S),C1(S),y++,g++}if(n?g>=r.batchesPerEpoch:b.done){if(o){let v;bB(r.validationData)?v=fe(yield e.evaluateDataset(r.validationData,{batches:r.validationBatches})):v=fe(e.evaluate(s,i,{batchSize:r.validationBatchSize==null?bit:r.validationBatchSize,verbose:0}));for(let C=0;C<e.metricsNames.length;++C)x[`val_${e.metricsNames[C]}`]=v[C]}break}if(e.stopTraining_)break}if(yield f.onEpochEnd(d,x),d++,e.stopTraining_)break}return yield f.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})}function wit(e,t){let r=null;return t.batchesPerEpoch!=null?r=t.batchesPerEpoch:Number.isFinite(e.size)&&(r=e.size),r}function bB(e){return typeof e.iterator=="function"}function Cit(e){return typeof e.next=="function"}function CB(e,t,r){return H(this,null,function*(){r=r||{};let n=r.batches!=null,o=e.testFunction,s=[];if(r.verbose>0)throw new It("Verbose mode is not implemented yet.");w.assert(!n||r.batches>0&&Number.isInteger(r.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(r.batches)}`);let i=Cit(t)?t:yield t.iterator(),a=0,l=0;for(;!n||l<r.batches;){let u=yield i.next();if(s=V(()=>{if(u.value){let{xs:c,ys:p}=vB(e,u.value),f=c.concat(p),m=V(()=>o(f));if($t(f),l===0)for(let h=0;h<m.length;++h)s.push(At(0));let d=f[0].shape[0];for(let h=0;h<m.length;++h){let x=m[h],g=s[h];s[h]=V(()=>tt(s[h],F(d,x))),l>0&&$t(g)}$t(m),a+=d,++l}return s}),u.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${r.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=mt(s[u],a),$t(c)}return Ar(s)})}function M1(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Kd(e,t,r){return e==null?[null]:Array.isArray(e)?e.map(n=>ml(n,t,r-t)):ml(e,t,r-t)}function z1(e,t){return V(()=>e==null?null:Array.isArray(e)?e.map(r=>z1(r,t)):x1(e,t.dtype==="int32"?t:et(t,"int32")))}function B1(e,t){let r=[],n=0,o=null;for(;n<e;)o=n+t,o>=e&&(o=e),r.push([n,o]),n=o;return r}function B_(e){let t=[];e instanceof qt&&(e=[e]);for(let r=0;r<e.length;++r){let n=e[r];if(n.rank===1)t.push(dl(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function fs(e,t){if(e==null)return;let r=[];if(t instanceof qt)r.push(t.id);else if(Array.isArray(t))t.forEach(o=>r.push(o.id));else if(t!=null)for(let o in t){let s=t[o];r.push(s.id)}let n=[];if(e instanceof qt)r.indexOf(e.id)===-1&&n.push(e);else if(Array.isArray(e))e.forEach(o=>{r.indexOf(o.id)===-1&&n.push(o)});else if(e!=null)for(let o in e){let s=e[o];r.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function Sit(e){return e instanceof qt}function V_(e){return Array.isArray(e)}function SB(e){return!Sit(e)&&!V_(e)}function kB(e,t,r,n=!0,o=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(V_(e)&&e.length>0)i=!0;else if(SB(e)){for(let a in e)if(e.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${o} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(SB(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(V_(e)){if(e=e,e.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new z(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=B_(s),r!=null)for(let i=0;i<t.length;++i){if(r[i]==null)continue;let a=s[i];if(a.shape.length!==r[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${r[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<r[i].length;++l){if(l===0&&!n)continue;let u=a.shape[l],c=r[i][l];if(c!=null&&c>=0&&u!==c)throw new z(`${o} expected a batch of elements where each example has shape [${r[i].slice(1,r[i].length)}] (i.e.,tensor shape [*,${r[i].slice(1,r[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function kit(e,t,r){let n=ls(e.map(s=>s.shape[0]));n.sort();let o=ls(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!w.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function Tit(e,t,r){let n=[Hp,qd,qp];for(let o=0;o<e.length;++o){let s=e[o],i=t[o],a=r[o];if(i!=null){if(i===qp&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let l=s.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){let p=l[c],f=u[c];if(f!=null&&p!==f)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function TB(e,t,r,n=!0,o=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new z(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(r!=null)for(let i=0;i<t.length;++i){if(r[i]==null)continue;let a=s[i];if(a.shape.length!==r[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${r[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<r[i].length;++l){if(l===0&&!n)continue;let u=a.shape[l],c=r[i][l];if(c!=null&&c!==u)throw new z(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(r[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Nit(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(n=>[]);let r;if(typeof e=="string"||typeof e=="function")r=[e];else if(Array.isArray(e)||typeof e=="object")r=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(r))return t.map(n=>r);{let n=[];for(let o of t){let s=r.hasOwnProperty(o)?r[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var Iit="layers-model",ms=class extends go{constructor(t){super(t),this.isTraining=!1}summary(t,r,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");hB(this,t,r,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=dB(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Jr))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let r=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),r.push(_1(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);r=t.loss.map(a=>_1(a))}else{let i=_1(t.loss);this.outputs.forEach(a=>{r.push(i)})}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ws("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=Nit(t.metrics,this.outputNames),s=(i,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,i])};Ws("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(u=>{let c="",p,f,m;for(let d of u){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let x=this.internalOutputShapes[i];x[x.length-1]===1||this.lossFunctions[i]===qd?["accuracy","acc"].indexOf(d)!==-1?f=D1:["crossentropy","ce"].indexOf(d)!==-1&&(f=F_):this.lossFunctions[i]===Hd?["accuracy","acc"].indexOf(d)!==-1?f=P_:["crossentropy","ce"].indexOf(d)!==-1&&(f=L_):["accuracy","acc"].indexOf(d)!==-1?f=R1:["crossentropy","ce"].indexOf(d)!==-1&&(f=$1);let g;["accuracy","acc"].indexOf(d)!==-1?g="acc":["crossentropy","ce"].indexOf(d)!==-1&&(g="ce"),m=f,p=c+g}else m=fB(d),p=c+ey(d);let h;Ws(p,()=>{h=m}),s(i,p,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,r,n={}){let o=n.batchSize==null?32:n.batchSize;M1(o);let s=!0,i=this.standardizeUserDataXY(t,r,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let l=this.testFunction,u=this.testLoop(l,a,o,n.verbose,n.steps);return Ar(u)}finally{fs(i[0],t),fs(i[1],r)}}evaluateDataset(t,r){return H(this,null,function*(){return this.makeTestFunction(),CB(this,t,r)})}checkNumSamples(t,r,n,o="steps"){let s;if(n!=null){if(s=null,r!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(t,r){if(Array.isArray(r)&&r.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(r),o=n?r:[r],s=this.retrieveSymbolicTensors(o),i=new ps;if(t instanceof qt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new z(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(let l of this.inputs){let u=t[l.name];if(u==null)throw new z(`No value is provided for the model's input ${l.name}`);i.add(l,u)}let a=Gp(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){let r=is(null,t.length),n=t.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let l=i.indexOf(t[a]);if(l!==-1&&(r[a]=s[l],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw r.forEach((s,i)=>{s==null&&o.push(t[i])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(t,r=32,n=!1){return V(()=>{let o=this.checkNumSamples(t);if(n)throw new It("Verbose predictLoop() is not implemented yet.");let s=B1(o,r),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)V(()=>{let u=s[a][0],c=s[a][1],p=Kd(t,u,c),f=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)f.push({key:this.inputs[d],value:p[d]});else f.push({key:this.inputs[0],value:p});let m=new ps(f);return Gp(this.outputs,m)}).forEach((u,c)=>i[c].push(u));return Ar(i.map(a=>Ce(a,0)))})}predict(t,r={}){let n=B_(t);TB(n,this.inputNames,this.feedInputShapes,!1);try{let o=r.batchSize==null?32:r.batchSize;return M1(o),this.predictLoop(n,o)}finally{fs(n,t)}}predictOnBatch(t){TB(t,this.inputNames,this.feedInputShapes,!0);let r=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,r)}standardizeUserDataXY(t,r,n=!0,o){if(this.optimizer_==null)throw new en("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===Hd?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=kB(t,this.feedInputNames,this.feedInputShapes,!1,"input"),r=kB(r,this.feedOutputNames,s,!1,"target"),kit(t,r,null),Tit(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,r]}standardizeUserData(t,r,n,o,s=!0,i){return H(this,null,function*(){let[a,l]=this.standardizeUserDataXY(t,r,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(o!=null){let c=P1(o,this.outputNames);u=[];for(let p=0;p<c.length;++p)u.push(yield L1(l[p],null,c[p]))}return[a,l,u]})}testLoop(t,r,n,o=0,s){return V(()=>{let i=this.checkNumSamples(r,n,s,"steps"),a=[];if(o>0)throw new It("Verbose mode is not implemented yet.");if(s!=null)throw new It("steps mode in testLoop() is not implemented yet");{let l=B1(i,n),u=gr(In(0,i));for(let c=0;c<l.length;++c){let p=l[c][0],f=l[c][1],m=ml(u,p,f-p),d=z1(r,m),h=t(d);if(c===0)for(let x=0;x<h.length;++x)a.push(At(0));for(let x=0;x<h.length;++x){let g=h[x];a[x]=tt(a[x],F(f-p,g))}}for(let c=0;c<a.length;++c)a[c]=mt(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,r=[];for(let n=0;n<t.length;++n){let o=t[n],s=o;if(T_(t,o)>1){let i=T_(t.slice(0,n),o);s+=`_${i}`}r.push(s)}return r}makeTrainFunction(){return t=>{let r=[],n=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let f=new ps(p),m=Gp(this.outputs,f,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let x=this.lossFunctions[h],g=x(o[h],m[h]);s[h]!=null&&(g=xB(g,s[h]));let y=Ee(g);r.push(y),h===0?d=g:d=tt(d,g)}for(let h=0;h<this.metricsTensors.length;++h){let x;if(this.outputs.length>1&&h<this.outputs.length)x=r[h];else{let g=this.metricsTensors[h][0],y=this.metricsTensors[h][1];x=Ee(g(o[y],m[y]))}Ir(x),i.push(x)}return d=Ee(d),this.calculateLosses().forEach(h=>{d=tt(d,h)}),d},l=this.collectedTrainableWeights.map(p=>p.read()),u=!0;return[this.optimizer_.minimize(a,u,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>V(()=>{let r=[],n,o=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:o[u]});let a=new ps(i),l=Gp(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],p=Ee(c(s[u],l[u]));u===0?n=p:n=tt(n,p),r.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],p=this.metricsTensors[u][1],f=Ee(c(s[p],l[p]));r.push(f)}return r})}fit(o,s){return H(this,arguments,function*(t,r,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,a,l,u,c,p,f,m,d;try{let h=n.batchSize==null?32:n.batchSize;M1(h);let x=!1,g=yield this.standardizeUserData(t,r,n.sampleWeight,n.classWeight,x,h);i=g[0],a=g[1],d=g[2];let y=!1,b;if(n.validationData!=null&&n.validationData.length>0){if(y=!0,n.validationData.length===2)c=n.validationData[0],p=n.validationData[1];else throw n.validationData.length===3?new It("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let M=!0,U=yield this.standardizeUserData(c,p,null,null,M,h);f=U[0],m=U[1],b=f.concat(m)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){y=!0;let M=Math.floor(i[0].shape[0]*(1-n.validationSplit)),U=i[0].shape[0];f=Kd(i,M,U),l=i,i=Kd(i,0,M),m=Kd(a,M,U),u=a,a=Kd(a,0,M),b=f.concat(m)}else n.validationSteps!=null&&(y=!0);let v=i.concat(a).concat(d);this.checkTrainableWeightsConsistency();let C=this.makeTrainFunction(),S=this.getDedupedMetricsNames(),k,I;y?(this.makeTestFunction(),k=this.testFunction,I=S.slice().concat(S.map(M=>"val_"+M))):(k=null,b=[],I=S.slice());let D=N1(n.callbacks,n.yieldEvery);return yield this.fitLoop(C,v,S,h,n.epochs,n.verbose,D,k,b,n.shuffle,I,n.initialEpoch,null,null)}finally{this.isTraining=!1,fs(i,t),fs(a,r),fs(l,t),fs(u,r),fs(f,c),fs(m,p),d!=null&&$t(d)}})}fitLoop(t,r,n,o,s,i,a,l,u,c,p,f,m,d){return H(this,null,function*(){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),f==null&&(f=0);let h=!1;if(l!=null&&u!=null&&(h=!0),d!=null&&(h=!0,m==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let x=this.checkNumSamples(r,o,m,"steps_per_epoch"),g;x!=null&&(g=In(0,x)),i==null&&(i=1);let{callbackList:y,history:b}=I1(a,i,s,f,x,m,o,h,p);y.setModel(this),this.history=b,yield y.onTrainBegin(),this.stopTraining_=!1;for(let v=f;v<s;++v){yield y.onEpochBegin(v);let C={};if(m!=null)throw new It("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new It("batch shuffling is not implemneted yet");c&&w.shuffle(g);let S=gr(g),k=B1(x,o);for(let I=0;I<k.length;++I){let D={};if(yield y.onBatchBegin(I,D),V(()=>{let R=k[I][0],M=k[I][1],U=ml(S,R,M-R);D.batch=I,D.size=M-R;let j=z1(r,U),K=t(j);for(let W=0;W<n.length;++W){let q=n[W],X=K[W];D[q]=X,Ir(X)}if(I===k.length-1&&h){let W=this.testLoop(l,u,o);for(let q=0;q<n.length;++q){let X=n[q],Q=W[q];Ir(Q),C["val_"+X]=Q}}}),yield y.onBatchEnd(I,D),C1(D),this.stopTraining_)break}S.dispose()}if(yield y.onEpochEnd(v,C),this.stopTraining_)break}return yield y.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(t,r){return H(this,null,function*(){return wB(this,t,r)})}trainOnBatch(t,r){return H(this,null,function*(){let n=yield this.standardizeUserData(t,r),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),l=[];for(let u of a){let c=yield u.data();l.push(c[0])}return $t(a),fs(n[0],t),fs(n[1],r),Ar(l)})}getNamedWeights(t){let r=[],n=t!=null&&t.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||r.push({name:o[i].originalName,tensor:s[i]});return r}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let r=ux().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=r-ux().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=as(this.loss);else if(Array.isArray(this.loss)){for(let r of this.loss)if(typeof r!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(r=>as(r))}else{let r=Object.keys(this.loss);t={};let n=this.loss;for(let o of r)if(typeof n[o]=="string")t[o]=as(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[as(ey(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>as(ey(t)));{let t={};for(let r in this.metrics)t[r]=as(ey(this.metrics[r]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let r=ry(t.optimizer_config),n=ho(r),o;if(typeof t.loss=="string")o=fl(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(i=>fl(i));else if(t.loss!=null){o={};for(let i in t.loss)o[i]=fl(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>fl(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=fl(t.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}save(t,r){return H(this,null,function*(){if(typeof t=="string"){let u=nl.getSaveHandlers(t);if(u.length===0)throw new z(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new z(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=yield nl.encodeWeights(this.getNamedWeights(r)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:Iit,generatedBy:`TensorFlow.js tfjs-layers v${jd}`,convertedBy:null};if((r==null?!1:r.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:c,specs:p}=yield nl.encodeWeights(yield this.optimizer.getWeights(),u);n.specs.push(...p),n.data=nl.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&(z_(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)})}setUserDefinedMetadata(t){z_(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};ms.className="Model";Z.registerClass(ms);var V1=class extends ms{};V1.className="Functional";Z.registerClass(V1);var xl=class extends ms{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:nc("sequential_"),t.layers!=null)for(let r of t.layers)this.add(r)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let r=t instanceof xl||t instanceof ms,n;if(r){if(n=t,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=R_({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=D_(this.outputs[0])}this.inboundNodes=[],new hl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:is(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,r){return this.model==null&&this.build(),this.model.call(t,r)}build(t){if(Mt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ms({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,r,n=console.log){this.built||this.build(),super.summary(t,r,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,r,n={}){if(!this.built)throw new en("The model needs to be compiled before being used.");return this.model.evaluate(t,r,n)}evaluateDataset(t,r){return H(this,null,function*(){if(!this.built)throw new en("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,r)})}predict(t,r={}){return this.model==null&&this.build(),this.model.predict(t,r)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}fit(o,s){return H(this,arguments,function*(t,r,n={}){if(!this.built)throw new en("The model needs to be compiled before being used.");return this.model.fit(t,r,n)})}fitDataset(t,r){return H(this,null,function*(){if(!this.built)throw new en("The model needs to be compiled before being used.");return this.model.fitDataset(t,r)})}trainOnBatch(t,r){return H(this,null,function*(){return this.model.trainOnBatch(t,r)})}static fromConfig(t,r,n={},o=!1){let s,i={};if(r instanceof Array){if(r[0].className==null||r[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=r}else w.assert(r.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=r.layers,delete r.layers,i=r;let a=new t(i);if(!(a instanceof xl))throw new It(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let l of s){let c=ho(l,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let r of this.layers){let n={};n.className=r.getClassName(),n.config=r.getConfig(),t.push(n)}return{name:this.name,layers:t}}};xl.className="Sequential";Z.registerClass(xl);var hn=class extends Z.Serializable{getConfig(){return{}}},W1=class extends hn{apply(t,r=1){return Y3(t,r)}};W1.className="elu";Z.registerClass(W1);var G1=class extends hn{apply(t){return kx(t)}};G1.className="selu";Z.registerClass(G1);var U1=class extends hn{apply(t){return mo(t)}};U1.className="relu";Z.registerClass(U1);var H1=class extends hn{apply(t){return V(()=>_p(6,mo(t)))}};H1.className="relu6";Z.registerClass(H1);var q1=class extends hn{apply(t){return t}};q1.className="linear";Z.registerClass(q1);var j1=class extends hn{apply(t){return es(t)}};j1.className="sigmoid";Z.registerClass(j1);var K1=class extends hn{apply(t){return Z3(t)}};K1.className="hardSigmoid";Z.registerClass(K1);var X1=class extends hn{apply(t){return Ei(t)}};X1.className="softplus";Z.registerClass(X1);var Y1=class extends hn{apply(t){return Q3(t)}};Y1.className="softsign";Z.registerClass(Y1);var Q1=class extends hn{apply(t){return dd(t)}};Q1.className="tanh";Z.registerClass(Q1);var Xd=class extends hn{apply(t,r=-1){return $p(t,r)}};Xd.className="softmax";Z.registerClass(Xd);var Z1=class extends hn{apply(t,r=-1){return vx(t,r)}};Z1.className="logSoftmax";Z.registerClass(Z1);var J1=class extends hn{apply(t,r=1){return V(()=>F(es(F(t,r)),t))}};J1.className="swish";Z.registerClass(J1);var tC=class extends hn{apply(t){return V(()=>F(t,dd(Ei(t))))}};tC.className="mish";Z.registerClass(tC);function Us(e){return e.getClassName()}function W_(e,t={}){return Di(e,Z.SerializationMap.getMap().classNameMap,t,"activation")}function Hs(e){if(e==null){let t={};return t.className="linear",t.config={},W_(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},W_(t)}else return e instanceof hn?e:W_(e)}function _it(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var eC=class extends Z.Serializable{},ny=class extends eC{constructor(t){super(),_it(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return V(()=>{let r=ke([1]);return this.hasL1&&(r=tt(r,ht(F(this.l1,ir(t))))),this.hasL2&&(r=tt(r,ht(F(this.l2,Vp(t))))),L(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,r){return new t({l1:r.l1,l2:r.l2})}};ny.className="L1L2";Z.registerClass(ny);var NB={l1l2:"L1L2"};function ie(e){return Rd(e)}function IB(e,t={}){return Di(e,Z.SerializationMap.getMap().classNameMap,t,"regularizer")}function de(e){if(e==null)return null;if(typeof e=="string"){let r={className:e in NB?NB[e]:e,config:{}};return IB(r)}else return e instanceof eC?e:IB(e)}var oy=class extends Ot{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,r){t=Et(t);let n=mo(t);return this.maxValue!=null&&(n=zr(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},r=super.getConfig();return Object.assign(t,r),t}};oy.className="ReLU";Z.registerClass(oy);var sy=class extends Ot{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,r){let n=Et(t);return Ip(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},r=super.getConfig();return Object.assign(t,r),t}};sy.className="LeakyReLU";Z.registerClass(sy);var iy=class extends Ot{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=le(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=de(t.alphaRegularizer),this.alphaConstraint=Fe(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Mt(t);let r=t.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)n[o]=t[o];this.inputSpec=[new me({ndim:t.length,axes:n})],this.built=!0}call(t,r){return t=Et(t),Dp(t,this.alpha.read())}getConfig(){let t={alphaInitializer:be(this.alphaInitializer),alphaRegularizer:ie(this.alphaRegularizer),alphaConstraint:Oe(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(t,r),t}};iy.className="PReLU";Z.registerClass(iy);var ay=class extends Ot{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new It(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,r){let n=Et(t);return ll(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},r=super.getConfig();return Object.assign(t,r),t}};ay.className="ELU";Z.registerClass(ay);var ly=class extends Ot{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,r){let n=Et(t);return F(n,et(We(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},r=super.getConfig();return Object.assign(t,r),t}};ly.className="ThresholdedReLU";Z.registerClass(ly);var uy=class extends Ot{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Xd().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,r){let n=Et(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},r=super.getConfig();return Object.assign(t,r),t}};uy.className="Softmax";Z.registerClass(uy);function ic(e,t,r){if(typeof e=="number")return is(e,t);if(e.length!==t)throw new z(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let n=0;n<t;++n){let o=e[n];if(!q3(o))throw new z(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${o}`)}return e}function Hn(e,t,r,n,o=1){if(e==null)return e;let s=t+(t-1)*(o-1),i;return r==="same"?i=e:i=e-s+1,Math.floor((i+n-1)/n)}function qs(e,t,r,n){if(e==null)return null;if(n==="valid")e=e*t+Gs([r-t,0]);else if(n==="same")e=e*t;else throw new z(`Unsupport padding mode: ${n}.`);return e}function hy(e,t){return V(()=>(_e(t),t==="channelsFirst"?Lt(e,[0,2,3,1]):e))}function G_(e,t){return V(()=>(_e(t),t==="channelsFirst"?Lt(e,[0,2,3,4,1]):e))}function Dit(e,t,r,n=1,o="valid",s,i=1){return V(()=>{if(s==null&&(s=En()),_e(s),e.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(r!=null&&r.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(e=Lt(e,[0,2,1])),o==="causal")throw new It("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=mx(e,t,n,o==="same"?"same":"valid","NWC",i);return r!=null&&(a=_n(a,r)),a})}function EB(e,t,r,n=[1,1],o="valid",s,i,a=null){return V(()=>{if(s==null&&(s=En()),_e(s),e.rank!==3&&e.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=hy(e,s);if(o==="causal")throw new It("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Mp.conv2d({x:l,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:r,activation:a}),s==="channelsFirst"&&(l=Lt(l,[0,3,1,2])),l})}function Rit(e,t,r,n=[1,1,1],o="valid",s,i){return V(()=>{if(s==null&&(s=En()),_e(s),e.rank!==4&&e.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let a=G_(e,s);if(o==="causal")throw new It("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=VE(a,t,n,o==="same"?"same":"valid","NDHWC",i),r!=null&&(a=_n(a,r)),s==="channelsFirst"&&(a=Lt(a,[0,4,1,2,3])),a})}var jp=class extends Ot{constructor(t,r){if(super(r),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",jp.verifyArgs(r),this.rank=t,je(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new It(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ic(r.kernelSize,t,"kernelSize"),this.strides=ic(r.strides==null?1:r.strides,t,"strides"),this.padding=r.padding==null?"valid":r.padding,Nn(this.padding),this.dataFormat=r.dataFormat==null?"channelsLast":r.dataFormat,_e(this.dataFormat),this.activation=Hs(r.activation),this.useBias=r.useBias==null?!0:r.useBias,this.biasInitializer=le(r.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Fe(r.biasConstraint),this.biasRegularizer=de(r.biasRegularizer),this.activityRegularizer=de(r.activityRegularizer),this.dilationRate=ic(r.dilationRate==null?1:r.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if($o("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!u1(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Us(this.activation),useBias:this.useBias,biasInitializer:be(this.biasInitializer),biasRegularizer:ie(this.biasRegularizer),activityRegularizer:ie(this.activityRegularizer),biasConstraint:Oe(this.biasConstraint)},r=super.getConfig();return Object.assign(t,r),t}},ac=class extends jp{constructor(t,r){super(t,r),this.kernel=null,ac.verifyArgs(r),this.filters=r.filters,je(this.filters,"filters"),this.kernelInitializer=le(r.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Fe(r.kernelConstraint),this.kernelRegularizer=de(r.kernelRegularizer)}build(t){t=Mt(t);let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[r]}`);let n=t[r],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[r]:n}}],this.built=!0}call(t,r){return V(()=>{t=Et(t);let n,o=this.bias==null?null:this.bias.read(),s=c1(this.activation.getClassName());if(s!=null&&this.rank===2)n=EB(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=Dit(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=EB(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=Rit(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new It("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Mt(t);let r=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=Hn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);r.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(r),o.push(this.filters)):(o.push(this.filters),o=o.concat(r)),o}getConfig(){let t={filters:this.filters,kernelInitializer:be(this.kernelInitializer),kernelRegularizer:ie(this.kernelRegularizer),kernelConstraint:Oe(this.kernelConstraint)},r=super.getConfig();return Object.assign(t,r),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},lc=class extends ac{constructor(t){super(2,t),lc.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!u1(t.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};lc.className="Conv2D";Z.registerClass(lc);var uc=class extends ac{constructor(t){super(3,t),uc.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};uc.className="Conv3D";Z.registerClass(uc);var cy=class extends lc{constructor(t){if(super(t),this.inputSpec=[new me({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Mt(t),t.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(t));let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[r],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new me({ndim:4,axes:{[r]:n}})],this.built=!0}call(t,r){return V(()=>{let n=Et(t);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let l=o[i],u=o[a],c=this.kernelSize[0],p=this.kernelSize[1],f=this.strides[0],m=this.strides[1],d=qs(l,f,c,this.padding),h=qs(u,m,p,this.padding),x=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Lt(n,[0,2,3,1]));let g=dx(n,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Lt(g,[0,3,1,2])),this.bias!=null&&(g=_n(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(t){t=Mt(t);let r=t.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return r[n]=this.filters,r[o]=qs(r[o],l,i,this.padding),r[s]=qs(r[s],u,a,this.padding),r}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};cy.className="Conv2DTranspose";Z.registerClass(cy);var py=class extends uc{constructor(t){if(super(t),this.inputSpec=[new me({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Mt(t),t.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(t));let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[r],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new me({ndim:5,axes:{[r]:n}})],this.built=!0}call(t,r){return V(()=>{let n=Et(t);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,l;this.dataFormat==="channelsFirst"?(l=2,i=3,a=4):(l=1,i=2,a=3);let u=o[l],c=o[i],p=o[a],f=this.kernelSize[0],m=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],x=this.strides[1],g=this.strides[2],y=qs(u,h,f,this.padding),b=qs(c,x,m,this.padding),v=qs(p,g,d,this.padding),C=[s,y,b,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Lt(n,[0,2,3,4,1]));let S=WE(n,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=Lt(S,[0,4,1,2,3])),this.bias!==null&&(S=_n(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=Mt(t);let r=t.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],p=this.strides[1],f=this.strides[2];return r[n]=this.filters,r[o]=qs(r[o],c,a,this.padding),r[s]=qs(r[s],p,l,this.padding),r[i]=qs(r[i],f,u,this.padding),r}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};py.className="Conv3DTranspose";Z.registerClass(py);var rC=class extends ac{constructor(t,r){if(super(t,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,r.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(r.kernelInitializer!=null||r.kernelRegularizer!=null||r.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(r.padding!=null&&r.padding!=="same"&&r.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier==null?1:r.depthMultiplier,this.depthwiseInitializer=le(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=de(r.depthwiseRegularizer),this.depthwiseConstraint=Fe(r.depthwiseConstraint),this.pointwiseInitializer=le(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=de(r.pointwiseRegularizer),this.pointwiseConstraint=Fe(r.pointwiseConstraint)}build(t){if(t=Mt(t),t.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null||t[r]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[r])}`);let n=t[r],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new me({ndim:this.rank+2,axes:{[r]:n}})],this.built=!0}call(t,r){return V(()=>{t=Et(t);let n;if(this.rank===1)throw new It("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Lt(t,[0,2,3,1])),n=Tx(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=_n(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Lt(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=be(this.depthwiseInitializer),t.pointwiseInitializer=be(this.pointwiseInitializer),t.depthwiseRegularizer=ie(this.depthwiseRegularizer),t.pointwiseRegularizer=ie(this.pointwiseRegularizer),t.depthwiseConstraint=Oe(this.depthwiseConstraint),t.pointwiseConstraint=Oe(this.pointwiseConstraint),t}};rC.className="SeparableConv";var fy=class extends rC{constructor(t){super(2,t)}};fy.className="SeparableConv2D";Z.registerClass(fy);var Kp=class extends ac{constructor(t){super(1,t),Kp.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!u1(t.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};Kp.className="Conv1D";Z.registerClass(Kp);var my=class extends Ot{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,r){return V(()=>{if(t=Et(t),this.dataFormat==="channelsLast"){let n=Lx(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Lx(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Lx(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Lx(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}};my.className="Cropping2D";Z.registerClass(my);var dy=class extends Ot{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,_e(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,U3(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let r=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],r,n]}else{let r=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],r,n,t[3]]}}call(t,r){return V(()=>{let n=Et(t),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Lt(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?Bs.resizeNearestNeighbor(n,[s,i]):Bs.resizeBilinear(n,[s,i]);return Lt(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?Bs.resizeNearestNeighbor(n,[s,i]):Bs.resizeBilinear(n,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(t,r),t}};dy.className="UpSampling2D";Z.registerClass(dy);function $it(e,t,r=[1,1],n="valid",o,s){return V(()=>{o==null&&(o=En()),_e(o);let i=hy(e,o);if(e.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=al(i,t,r,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Lt(i,[0,3,1,2])),i})}var gy=class extends jp{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=le(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Fe(t.depthwiseConstraint),this.depthwiseRegularizer=de(t.depthwiseRegularizer)}build(t){if(t=Mt(t),t.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let r=this.dataFormat==="channelsFirst"?1:3;if(t[r]==null||t[r]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[r]}).`);let n=t[r],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,r){return V(()=>{t=Et(t);let n=$it(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=_n(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=Mt(t);let r=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=Hn(r,this.kernelSize[0],this.padding,this.strides[0]),i=Hn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,s,i]:[t[0],s,i,o]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=be(this.depthwiseInitializer),t.depthwiseRegularizer=ie(this.depthwiseRegularizer),t.depthwiseConstraint=Oe(this.depthwiseRegularizer),t}};gy.className="DepthwiseConv2D";Z.registerClass(gy);function U_(e,t,r,n){if(Array.isArray(e)){if(t!=null||r!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(r=e.slice(e.length-n,e.length),e=e.slice(0,e.length-n)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),r=o(r),{inputs:e,initialState:t,constants:r}}function H_(e,t,r,n=!1,o,s,i=!1,a=!1){return V(()=>{let l=t.shape.length;if(l<3)throw new z(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(In(2,l));if(t=Lt(t,u),s!=null)throw new It("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=et(et(o,"bool"),"float32"),o.rank===l-1&&(o=hr(o,-1)),o=Lt(o,u)),n&&(t=Ro(t,0),o!=null&&(o=Ro(o,0)));let c=[],p,f=r,m=t.shape[0],d=pn(t),h;o!=null&&(h=pn(o));for(let g=0;g<m;++g){let y=d[g],b=V(()=>e(y,f));if(o==null)p=b[0],f=b[1];else{let v=V(()=>{let C=h[g],S=yt(_r(C),C),k=tt(F(b[0],C),F(f[0],S)),I=f.map((D,R)=>tt(F(b[1][R],C),F(D,S)));return{output:k,newStates:I}});p=v.output,f=v.newStates}a&&c.push(p)}let x;return a&&(x=Cr(c,1)),[p,x,f]})}var Oo=class extends Ot{constructor(t){super(t);let r;if(t.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?r=new Zd({cells:t.cell}):r=t.cell,r.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new me({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return In(0,t).map(r=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){b1(t)&&(t=t[0]),t=t;let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let n=r[0],o;if(this.returnSequences?o=[t[0],t[1],n]:o=[t[0],n],this.returnState){let s=[];for(let i of r)s.push([t[0],i]);return[o].concat(s)}else return o}computeMask(t,r){return V(()=>{Array.isArray(r)&&(r=r[0]);let n=this.returnSequences?r:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let n=0;n<t;++n)r.push(null);return r}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new It("Constants support is not implemented in RNN yet.");b1(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new me({shape:[n,null,...o]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new me({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,r=!1){V(()=>{if(!this.stateful)throw new Gn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ke([n,o])):this.states_=[ke([n,this.cell.stateSize])];else if(t==null)$t(this.states_),this.keptStates!=null&&($t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ke([n,o])):this.states_[0]=ke([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);r===!0?this.keptStates.push(this.states_.slice()):$t(this.states_);for(let o=0;o<this.states_.length;++o){let s=t[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!w.arraysEqual(s.shape,a))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Ir(o.clone()))})}apply(t,r){let n=r==null?null:r.initialState,o=r==null?null:r.constants;r==null&&(r={});let s=U_(t,n,o,this.numConstants);t=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){r.initialState=n,i=i.concat(n),this.stateSpec=[];for(let u of n)this.stateSpec.push(new me({shape:u.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(r.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof dn){let u=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let f=super.apply(u,r);return this.inputSpec=p,f}else return super.apply(t,r)}call(t,r){return V(()=>{let n=r==null?null:r.mask,o=r==null?null:r.training,s=r==null?null:r.initialState;t=Et(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new z(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},u=H_((d,h)=>{let x=this.cell.call([d].concat(h),a);return[x[0],x.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=u[0],p=u[1],f=u[2];this.stateful&&this.resetStates(f,o);let m=this.returnSequences?p:c;return this.returnState?[m].concat(f):m})}getInitialState(t){return V(()=>{let r=ke(t.shape);return r=ht(r,[1,2]),r=dl(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?g1(r,[1,n]):r):this.cell.stateSize>1?[g1(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(r.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Oo.className&&(r.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),r)}static fromConfig(t,r,n={}){let o=r.cell,s=ho(o,n);return new t(Object.assign(r,{cell:s}))}};Oo.className="RNN";Z.registerClass(Oo);var cc=class extends Ot{},Yd=class extends cc{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,je(this.units,"units"),this.activation=Hs(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=le(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=le(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=le(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=de(t.kernelRegularizer),this.recurrentRegularizer=de(t.recurrentRegularizer),this.biasRegularizer=de(t.biasRegularizer),this.kernelConstraint=Fe(t.kernelConstraint),this.recurrentConstraint=Fe(t.recurrentConstraint),this.biasConstraint=Fe(t.biasConstraint),this.dropout=Bp([1,Gs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Mt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,r){return V(()=>{if(t=t,t.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let o=r.training==null?!1:r.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>_r(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>_r(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=cs(F(t,i),this.kernel.read()):s=cs(t,this.kernel.read()),this.bias!=null&&(s=_n(s,this.bias.read())),a!=null&&(n=F(n,a));let l=tt(s,cs(n,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let t=super.getConfig(),r={units:this.units,activation:Us(this.activation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ie(this.kernelRegularizer),recurrentRegularizer:ie(this.recurrentRegularizer),biasRegularizer:ie(this.biasRegularizer),activityRegularizer:ie(this.activityRegularizer),kernelConstraint:Oe(this.kernelConstraint),recurrentConstraint:Oe(this.recurrentConstraint),biasConstraint:Oe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),r)}};Yd.className="SimpleRNNCell";Z.registerClass(Yd);var xy=class extends Oo{constructor(t){t.cell=new Yd(t),super(t)}call(t,r){return V(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=r==null?null:r.mask,o=r==null?null:r.training,s=r==null?null:r.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,r){return new t(r)}};xy.className="SimpleRNN";Z.registerClass(xy);var Qd=class extends cc{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=t.units,je(this.units,"units"),this.activation=Hs(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hs(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=le(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=le(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=le(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=de(t.kernelRegularizer),this.recurrentRegularizer=de(t.recurrentRegularizer),this.biasRegularizer=de(t.biasRegularizer),this.kernelConstraint=Fe(t.kernelConstraint),this.recurrentConstraint=Fe(t.recurrentConstraint),this.biasConstraint=Fe(t.biasConstraint),this.dropout=Bp([1,Gs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Mt(t);let r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,r){return V(()=>{if(t=t,t.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=r.training==null?!1:r.training,o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>_r(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>_r(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,l,u;0<this.dropout&&this.dropout<1&&(t=F(t,s[0]));let c=cs(t,this.kernel.read());this.useBias&&(c=_n(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=F(o,i[0]));let p=this.recurrentKernel.read(),[f,m]=wr(p,[2*this.units,this.units],p.rank-1),d=cs(o,f),[h,x,g]=wr(c,3,c.rank-1),[y,b]=wr(d,2,d.rank-1);a=this.recurrentActivation.apply(tt(h,y)),l=this.recurrentActivation.apply(tt(x,b));let v=cs(F(l,o),m);u=this.activation.apply(tt(g,v));let C=tt(F(a,o),F(tt(1,Zt(a)),u));return[C,C]})}getConfig(){let t=super.getConfig(),r={units:this.units,activation:Us(this.activation),recurrentActivation:Us(this.recurrentActivation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ie(this.kernelRegularizer),recurrentRegularizer:ie(this.recurrentRegularizer),biasRegularizer:ie(this.biasRegularizer),activityRegularizer:ie(this.activityRegularizer),kernelConstraint:Oe(this.kernelConstraint),recurrentConstraint:Oe(this.recurrentConstraint),biasConstraint:Oe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),r)}};Qd.className="GRUCell";Z.registerClass(Qd);var yy=class extends Oo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Qd(t),super(t)}call(t,r){return V(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=r==null?null:r.mask,o=r==null?null:r.training,s=r==null?null:r.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,r){return r.implmentation===0&&(r.implementation=1),new t(r)}};yy.className="GRU";Z.registerClass(yy);var pc=class extends cc{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,je(this.units,"units"),this.activation=Hs(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hs(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=le(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=le(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=le(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=de(t.kernelRegularizer),this.recurrentRegularizer=de(t.recurrentRegularizer),this.biasRegularizer=de(t.biasRegularizer),this.kernelConstraint=Fe(t.kernelConstraint),this.recurrentConstraint=Fe(t.recurrentConstraint),this.biasConstraint=Fe(t.biasConstraint),this.dropout=Bp([1,Gs([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gs([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var r;t=Mt(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;o=new(r=class extends An{apply(l,u){let c=s.apply([i]),p=new Wp().apply([i]),f=s.apply([i*2]);return A_(A_(c,p),f)}},r.className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,r){return V(()=>{let n=r.training==null?!1:r.training;if(t=t,t.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>_r(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>_r(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,l,u,c,p;0<this.dropout&&this.dropout<1&&(t=F(t,i[0]));let f=cs(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=F(o,a[0])),f=tt(f,cs(o,this.recurrentKernel.read())),this.useBias&&(f=_n(f,this.bias.read()));let[m,d,h,x]=wr(f,4,f.rank-1);l=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(d),c=tt(F(u,s),F(l,this.activation.apply(h))),p=this.recurrentActivation.apply(x);let g=F(p,this.activation.apply(c));return[g,g,c]})}getConfig(){let t=super.getConfig(),r={units:this.units,activation:Us(this.activation),recurrentActivation:Us(this.recurrentActivation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ie(this.kernelRegularizer),recurrentRegularizer:ie(this.recurrentRegularizer),biasRegularizer:ie(this.biasRegularizer),activityRegularizer:ie(this.activityRegularizer),kernelConstraint:Oe(this.kernelConstraint),recurrentConstraint:Oe(this.recurrentConstraint),biasConstraint:Oe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),r)}};pc.className="LSTMCell";Z.registerClass(pc);var by=class extends Oo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new pc(t),super(t)}call(t,r){return V(()=>{this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=r==null?null:r.mask,o=r==null?null:r.training,s=r==null?null:r.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,r){return r.implmentation===0&&(r.implementation=1),new t(r)}};by.className="LSTM";Z.registerClass(by);var Zd=class extends cc{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let r of this.cells.slice().reverse())Array.isArray(r.stateSize)?t.push(...r.stateSize):t.push(r.stateSize);return t}call(t,r){return V(()=>{t=t;let n=t.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let l=this.cells[a];n=o[a],a===0?i=[t[0]].concat(n):i=[i[0]].concat(n),i=l.call(i,r),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(t){b1(t)&&(t=t[0]),t=t;let r;this.cells.forEach((n,o)=>{Ws(`RNNCell_${o}`,()=>{n.build(t),Array.isArray(n.stateSize)?r=n.stateSize[0]:r=n.stateSize,t=[t[0],r]})}),this.built=!0}getConfig(){let t=super.getConfig(),r=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(r)};return Object.assign(Object.assign({},t),o)}static fromConfig(t,r,n={}){let o=[];for(let s of r.cells)o.push(ho(s,n));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let r of this.cells)t.push(...r.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let r of this.cells)t.push(...r.nonTrainableWeights);if(!this.trainable){let r=[];for(let n of this.cells)r.push(...n.trainableWeights);return r.concat(t)}return t}getWeights(){let t=[];for(let r of this.cells)t.push(...r.weights);return qx(t)}setWeights(t){let r=[];for(let n of this.cells){let o=n.weights.length,s=t.splice(o);for(let i=0;i<n.weights.length;++i)r.push([n.weights[i],s[i]])}Ud(r)}};Zd.className="StackedRNNCells";Z.registerClass(Zd);function yl(e){let{ones:t,rate:r,training:n=!1,count:o=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),r):y1(t(),r),a=()=>oc(i,t,n);return!o||o<=1?Ir(a().clone()):Array(o).fill(void 0).map(a).map(u=>Ir(u.clone()))}var Oit=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]]);return r};var nC=class extends Oo{constructor(t){if(t.unroll)throw new It("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new It("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new me({ndim:5})]}call(t,r){return V(()=>{if(this.cell.dropoutMask!=null&&($t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&($t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new z("ConvRNN2D cell does not support constants");let n=r==null?null:r.mask,o=r==null?null:r.training,s=r==null?null:r.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}computeOutputShape(t){let r=this.computeSingleOutputShape(t);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([t[0],...r.slice(-3)])]),r}getInitialState(t){return V(()=>{let{stateSize:r}=this.cell,n=t.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=ke(s);return Array.isArray(r)?Array(r.length).fill(i):[i]})}resetStates(t,r=!1){V(()=>{if(!this.stateful)throw new Gn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ke(s)):this.states_=[ke(s)];else if(t==null)$t(this.states_),this.keptStates!=null&&($t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ke(s)):this.states_[0]=ke(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);r?this.keptStates.push(this.states_.slice()):$t(this.states_);for(let a=0;a<this.states_.length;++a){let l=t[a],u=s;if(!w.arraysEqual(l.shape,u))throw new z(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Ir(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:r,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,l=r==="channelsFirst",u=t[l?3:2],c=t[l?4:3],p=Hn(u,o[0],s,i[0],a[0]),f=Hn(c,o[1],s,i[1],a[1]);return[...t.slice(0,2),...l?[n,p,f]:[p,f,n]]}};nC.className="ConvRNN2D";var Jd=class extends pc{constructor(t){let{filters:r,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:r})),this.filters=r,je(this.filters,"filters"),this.kernelSize=ic(n,2,"kernelSize"),this.kernelSize.forEach(l=>je(l,"kernelSize")),this.strides=ic(o||1,2,"strides"),this.strides.forEach(l=>je(l,"strides")),this.padding=s||"valid",Nn(this.padding),this.dataFormat=i||"channelsLast",_e(this.dataFormat),this.dilationRate=ic(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>je(l,"dilationRate"))}build(t){var r;t=Mt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[n]}`);let o=t[n],s=4,i=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;l=new(r=class extends An{apply(f,m){let d=u.apply([c]),h=fo([c]),x=u.apply([c*2]);return Od([d,h,x])}},r.className="CustomInit",r)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,r){return V(()=>{if(t.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=r.training||!1,o=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yl({ones:()=>_r(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let l=this.dropoutMask,u=(nt,rt,at)=>!rt||!rt[at]?nt:F(rt[at],nt),c=u(o,l,0),p=u(o,l,1),f=u(o,l,2),m=u(o,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yl({ones:()=>_r(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=u(s,d,0),x=u(s,d,1),g=u(s,d,2),y=u(s,d,3),b=3,[v,C,S,k]=wr(this.kernel.read(),a,b),[I,D,R,M]=this.useBias?wr(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,v,I,this.padding),p=this.inputConv(p,C,D,this.padding),f=this.inputConv(f,S,R,this.padding),m=this.inputConv(m,k,M,this.padding);let[U,j,K,W]=wr(this.recurrentKernel.read(),a,b);h=this.recurrentConv(h,U),x=this.recurrentConv(x,j),g=this.recurrentConv(g,K),y=this.recurrentConv(y,W);let q=this.recurrentActivation.apply(tt(c,h)),X=this.recurrentActivation.apply(tt(p,x)),Q=tt(F(X,i),F(q,this.activation.apply(tt(f,g)))),Y=F(this.recurrentActivation.apply(tt(m,y)),this.activation.apply(Q));return[Y,Y,Q]})}getConfig(){let t=super.getConfig(),{units:r}=t,n=Oit(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),o)}inputConv(t,r,n,o){let s=co(t,r,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?_n(s,n,this.dataFormat):s}recurrentConv(t,r){return co(t,r,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Jd.className="ConvLSTM2DCell";Z.registerClass(Jd);var vy=class extends nC{constructor(t){let r=new Jd(t);super(Object.assign(Object.assign({},t),{cell:r}))}static fromConfig(t,r){return new t(r)}};vy.className="ConvLSTM2D";Z.registerClass(vy);var th=class extends Ot{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let r=t.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?r[o]:this.noiseShape[o]);return n}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);if(0<this.rate&&this.rate<1){let o=r.training==null?!1:r.training,s=this.getNoiseShape(n);return oc(()=>y1(n,this.rate,s,this.seed),()=>n,o)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(t,r),t}dispose(){return super.dispose()}};th.className="Dropout";Z.registerClass(th);var wy=class extends th{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let r=t.shape;return[r[0],1,r[2]]}};wy.className="SpatialDropout1D";Z.registerClass(wy);var Cy=class extends Ot{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let r=null;t.batchSize!=null&&(r=t.batchSize),this.batchInputShape=[r,t.inputDim]}this.units=t.units,je(this.units,"units"),this.activation=Hs(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=le(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=le(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Fe(t.kernelConstraint),this.biasConstraint=Fe(t.biasConstraint),this.kernelRegularizer=de(t.kernelRegularizer),this.biasRegularizer=de(t.biasRegularizer),this.activityRegularizer=de(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Mt(t);let r=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(t){t=Mt(t);let r=t.slice();return r[r.length-1]=this.units,r}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t),o=c1(this.activation.getClassName()),s;return o!=null?s=cs(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=cs(n,this.kernel.read()),this.bias!=null&&(s=_n(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:Us(this.activation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ie(this.kernelRegularizer),biasRegularizer:ie(this.biasRegularizer),activityRegularizer:ie(this.activityRegularizer),kernelConstraint:Oe(this.kernelConstraint),biasConstraint:Oe(this.biasConstraint)},r=super.getConfig();return Object.assign(t,r),t}};Cy.className="Dense";Z.registerClass(Cy);var Sy=class extends Ot{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Mt(t);for(let r of t.slice(1))if(r==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],us(t,1)]}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Lt(n,o)}return X3(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let r=super.getConfig();return Object.assign(t,r),t}};Sy.className="Flatten";Z.registerClass(Sy);var ky=class extends Ot{constructor(t){super(t),this.supportsMasking=!0,this.activation=Hs(t.activation)}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);return this.activation.apply(n)})}getConfig(){let t={activation:Us(this.activation)},r=super.getConfig();return Object.assign(t,r),t}};ky.className="Activation";Z.registerClass(ky);var Ty=class extends Ot{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,r){return V(()=>(t=Et(t),j3(t,this.n)))}getConfig(){let t={n:this.n},r=super.getConfig();return Object.assign(t,r),t}};Ty.className="RepeatVector";Z.registerClass(Ty);var Ny=class extends Ot{constructor(t){super(t),this.targetShape=t.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,r){let n="Total size of new array must be unchanged.",o=r.slice(),s=1,i=null;for(let l=0;l<o.length;++l){let u=o[l];if(this.isUnknown(u))if(i===null)i=l;else throw new z("Can only specifiy one unknown dimension.");else s*=u}let a=us(t);if(i!==null){if(s===0||a%s!==0)throw new z(n);o[i]=a/s}else if(a!==s)throw new z(n);return o}computeOutputShape(t){let r=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){r=!0;break}return r?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return L(n,s)})}getConfig(){let t={targetShape:this.targetShape},r=super.getConfig();return Object.assign(t,r),t}};Ny.className="Reshape";Z.registerClass(Ny);var Iy=class extends Ot{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let r=In(1,t.dims.length+1);if(!w.arraysEqual(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new me({ndim:this.dims.length+1})]}computeOutputShape(t){t=Mt(t);let r=t.slice();return this.dims.forEach((n,o)=>{r[o+1]=t[n]}),r}call(t,r){return Lt(Et(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},r=super.getConfig();return Object.assign(t,r),t}};Iy.className="Permute";Z.registerClass(Iy);var Ey=class extends Ot{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,t),r}computeMask(t,r){let n=Et(t),o=-1;return fd(ec(n,this.maskValue),o)}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t),o=-1,s=!0,i=fd(ec(n,this.maskValue),o,s);return F(n,et(i,n.dtype))})}};Ey.className="Masking";Z.registerClass(Ey);var _y=class extends Ot{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let r=null;t.batchSize!=null&&(r=t.batchSize),t.inputLength==null?this.batchInputShape=[r,null]:this.batchInputShape=[r].concat(fe(t.inputLength))}this.inputDim=t.inputDim,je(this.inputDim,"inputDim"),this.outputDim=t.outputDim,je(this.outputDim,"outputDim"),this.embeddingsInitializer=le(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=de(t.embeddingsRegularizer),this.activityRegularizer=de(t.activityRegularizer),this.embeddingsConstraint=Fe(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,r){return V(()=>this.maskZero?(t=Et(t),ec(t,kt(t))):null)}computeOutputShape(t){if(t=Mt(t),this.inputLength==null)return[...t,this.outputDim];let r=fe(this.inputLength);if(r.length!==t.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let o=0;o<r.length;++o){let s=r[o],i=t[o+1];if(s!=null&&i!=null&&s!==i)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(r[n]=i),n++}}return[t[0],...r,this.outputDim]}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);n.dtype!=="int32"&&(n=fn(n,"int32"));let o=x1(this.embeddings.read(),L(n,[n.size]));return L(o,Mt(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:be(this.embeddingsInitializer),embeddingsRegularizer:ie(this.embeddingsRegularizer),activityRegularizer:ie(this.activityRegularizer),embeddingsConstraint:Oe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(t,r),t}};_y.className="Embedding";Z.registerClass(_y);var bl=class extends Ot{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new It}computeElementwiseOpOutputShape(t,r){if(t==null||r==null)return null;if(t.length<r.length)return this.computeElementwiseOpOutputShape(r,t);if(r.length===0)return t;let n=t.slice(0,t.length-r.length);for(let o=0;o<r.length;++o){let s=t[t.length-r.length+o],i=r[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(r));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Mt(t)]),t=t,t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let r=[];for(let s of t)s!=null&&s[0]!==null&&r.push(s[0]);if(r=ls(r),r.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&ls(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,r){return V(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=Gs(o);for(let i of t){let a=i.rank;for(let l=0;l<s-a;++l)i=dl(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let l of t){let u=l.rank;if(u==null){let c=l.shape,p=c[0],f=c.slice(1).concat([p]),m=L(l,[p].concat(us(c.slice(1))));m=Lt(m,[1,0]),m=L(m,f),n.push(m),s=!0}else if(u>1){let c=In(1,u).concat([0]);n.push(Lt(l,c)),s=!0}else n.push(l)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let l=i.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));i=L(Lt(L(i,[-1,c]),[1,0]),p)}else if(a>1){let l=[a-1].concat(In(0,a-1));i=Lt(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let r;t[0]==null?r=null:r=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);r=this.computeElementwiseOpOutputShape(r,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=ls(n),n.length===1?r=n.concat(r):r=[null].concat(r),r}computeMask(t,r){return V(()=>{if(r==null)return null;if(!Array.isArray(r))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(r.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${r.length})`);if(r.every(o=>o==null))return null;r=r.map(o=>o==null?o:hr(o,0));let n=r[0];for(let o=1;o<r.length-1;++o)n=cn(n,r[o]);return n})}},Dy=class extends bl{constructor(t){super(t)}mergeFunction(t){return V(()=>{let r=t[0].clone();for(let n=1;n<t.length;++n)r=tt(r,t[n]);return r})}};Dy.className="Add";Z.registerClass(Dy);var Ry=class extends bl{constructor(t){super(t)}mergeFunction(t){return V(()=>{let r=t[0].clone();for(let n=1;n<t.length;++n)r=F(r,t[n]);return r})}};Ry.className="Multiply";Z.registerClass(Ry);var $y=class extends bl{constructor(t){super(t)}mergeFunction(t){return V(()=>{let r=t[0].clone();for(let n=1;n<t.length;++n)r=tt(r,t[n]);return F(1/t.length,r)})}};$y.className="Average";Z.registerClass($y);var Oy=class extends bl{constructor(t){super(t)}mergeFunction(t){return V(()=>{let r=t[0];for(let n=1;n<t.length;++n)r=po(r,t[n]);return r})}};Oy.className="Maximum";Z.registerClass(Oy);var Fy=class extends bl{constructor(t){super(t)}mergeFunction(t){return V(()=>{let r=t[0];for(let n=1;n<t.length;++n)r=_p(r,t[n]);return r})}};Fy.className="Minimum";Z.registerClass(Fy);var Py=class extends bl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let r=!0;for(let o of t)if(o!=null){r=!1;break}if(r)return;let n=[];for(let o=0;o<t.length;++o){let s=t[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(w.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return V(()=>Od(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let r=t,n=r[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of r.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(t,r){if(r==null)return null;if(!Array.isArray(r))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new z("`inputs` should be an array for Concatenate");if(r.length!==t.length)throw new z(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${t.length})`);return V(()=>{let n=!0;if(r.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<t.length;++i)r[i]==null?o.push(et(_r(t[i]),"bool")):r[i].rank<t[i].rank?o.push(hr(r[i],-1)):o.push(r[i]);let s=Ce(o,this.axis);return fx(s,-1,!1)})}getConfig(){let t={axis:this.axis},r=super.getConfig();return Object.assign(t,r),t}};Py.className="Concatenate";Z.registerClass(Py);function Ay(e,t){for(;e<0;)e+=t;return e}function Fit(e,t,r){if(e.shape.length>3||t.shape.length>3)throw new It("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof r=="number"&&(r=[r,r]),e.dtype==="complex64"||t.dtype==="complex64")throw new It("batchDot is not implemented for complex64-type Tensors yet.");let n=e.shape.length,o=t.shape.length;r==null&&(r=[n-1,o-2]);let s=r;return V(()=>{let i;if(n>o){i=n-o;let l=[];for(let u=0;u<i;++u)l.push(1);t=L(t,t.shape.concat(l))}else if(o>n){i=o-n;let l=[];for(let u=0;u<i;++u)l.push(1);e=L(e,e.shape.concat(l))}else i=0;let a;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=ht(F(e,t),s[0]):a=ht(F(Lt(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;a=Qt(e,t,l,u)}if(i>0){let l;n>o?l=n+o-3:l=n-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);a=Ms(a,u)}return a.shape.length===1&&(a=hr(a,1)),a})}var Ly=class extends bl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){w.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=t[0],n=t[1];if(r.length>3||n.length>3)throw new It("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(r,n);if(r[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${r[o[0]]} !== ${n[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let r=t[0],n=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>Ay(s,t[i].shape.length)):o=[Ay(this.axes,r.shape.length),Ay(this.axes,n.shape.length)],this.normalize&&(r=Qx(r,o[0]),n=Qx(n,o[1])),Fit(r,n,o)}interpretAxes(t,r){let n;return Array.isArray(this.axes)?n=this.axes:n=[Ay(this.axes,t.length),Ay(this.axes,r.length)],n}computeOutputShape(t){w.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=t[0].slice(),n=t[1].slice();if(r.length>3||n.length>3)throw new It("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(r,n);r.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=r.concat(n);return s.length===1&&s.push(1),s}computeMask(t,r){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(t,r),t}};Ly.className="Dot";Z.registerClass(Ly);var My=class extends Ot{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,t),r}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);return oc(()=>tt(Fd(n.shape,0,this.stddev),n),()=>n,r.training||!1)})}};My.className="GaussianNoise";Z.registerClass(My);var zy=class extends Ot{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),r={rate:this.rate};return Object.assign(r,t),r}call(t,r){return V(()=>{this.invokeCallHook(t,r);let n=Et(t);return this.rate>0&&this.rate<1?oc(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return F(n,Fd(n.shape,1,s))},()=>n,r.training||!1):n})}};zy.className="GaussianDropout";Z.registerClass(zy);var By=class extends Ot{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Et(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),r={rate:this.rate};return Object.assign(r,t),r}call(t,r){return V(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return oc(()=>{let s=Et(t),i=1.6732632423543772,a=1.0507009873554805,l=-i*a,u=Wn(cl(n),this.rate);u=fn(u,"float32");let c=nN((1-this.rate)*(1+this.rate*nN(l,2)),-.5),p=-c*l*this.rate,f=tt(F(s,u),F(tt(u,-1),l));return tt(F(f,c),p)},()=>Et(t),r.training||!1)}return t})}};By.className="AlphaDropout";Z.registerClass(By);function Vy(e,t,r,n,o,s=.001){let i;if(e.rank===2)i=$E(e,t,r,n,o,s);else if(e.rank===3)i=OE(e,t,r,n,o,s);else if(e.rank===4)i=FE(e,t,r,n,o,s);else throw new It(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Pit(e,t,r,n,o=.001){return V(()=>{let s=bd(e,n),i=s.mean,a=s.variance;return[Vy(e,i,a,r,t,o),i,a]})}function Lit(e,t,r,n,o=.001){return V(()=>{let s=bd(e,n),i=s.mean,a=s.variance,l=[];for(let d of In(0,e.rank))n.indexOf(d)!==-1?l.push(1):l.push(e.shape[d]);let u=L(i,l),c=L(a,l),p=t==null?null:L(t,l),f=r==null?null:L(r,l);return[Vy(e,u,c,f,p,o),i,a]})}function Mit(e,t,r,n,o=.001){return w.arraysEqual(n.slice().sort(),In(0,e.rank-1))?Pit(e,t,r,n,o):Lit(e,t,r,n,o)}var Wy=class extends Ot{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=le(t.betaInitializer||"zeros"),this.gammaInitializer=le(t.gammaInitializer||"ones"),this.movingMeanInitializer=le(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=le(t.movingVarianceInitializer||"ones"),this.betaConstraint=Fe(t.betaConstraint),this.gammaConstraint=Fe(t.gammaConstraint),this.betaRegularizer=de(t.betaRegularizer),this.gammaRegularizer=de(t.gammaRegularizer)}build(t){t=Mt(t);let r=this.axis>=0?this.axis:this.axis+t.length,n=t[r];if(n==null)throw new z(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new me({ndim:t.length,axes:{[r]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,r){return V(()=>{let n=r.training==null?!1:r.training,o=Et(t),s=o.shape,i=s.length,a=In(0,i),l=this.axis>=0?this.axis:this.axis+i;a.splice(l,1);let u=is(1,i);u[l]=s[l];let c=a.slice();c.sort();let p=!w.arraysEqual(c,In(0,i).slice(0,i-1)),f=()=>{if(p){let y=L(this.movingMean.read(),u),b=L(this.movingVariance.read(),u),v=this.center?L(this.beta.read(),u):null,C=this.scale?L(this.gamma.read(),u):null;return Vy(o,y,b,v,C,this.epsilon)}else return Vy(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return f();let[m,d,h]=Mit(o,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(y,b,v)=>{V(()=>{let C=1-v,S=y.read(),k=F(yt(S,b),C);y.write(yt(S,k))})};return(()=>{x(this.movingMean,d,this.momentum),x(this.movingVariance,h,this.momentum)})(),m})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:be(this.betaInitializer),gammaInitializer:be(this.gammaInitializer),movingMeanInitializer:be(this.movingMeanInitializer),movingVarianceInitializer:be(this.movingVarianceInitializer),betaRegularizer:ie(this.betaRegularizer),gammaRegularizer:ie(this.gammaRegularizer),betaConstraint:Oe(this.betaConstraint),gammaConstraint:Oe(this.gammaConstraint)},r=super.getConfig();return Object.assign(t,r),t}};Wy.className="BatchNormalization";Z.registerClass(Wy);var Gy=class extends Ot{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=le(t.betaInitializer||"zeros"),this.gammaInitializer=le(t.gammaInitializer||"ones"),this.betaRegularizer=de(t.betaRegularizer),this.gammaRegularizer=de(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Mt(t);let r=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=r);for(let s of this.axis)if(s<0||s>=r)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==ls(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>t[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,r){let n=Et(t),o=n.shape,s=o.length;return V(()=>{let{mean:a,variance:l}=bd(n,this.axis,!0),u=is(1,s);for(let h of this.axis)u[h]=o[h];let c=h=>h!=null&&h.shape.length!==s?L(h,u):h,p=this.scale?c(this.gamma.read()):null,f=this.center?c(this.beta.read()):null,m=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(m.push(o[h]),d.push(1)):(m.push(1),d.push(o[h]));return a=Zr(a,m),l=Zr(l,m),p!=null&&(p=Zr(p,d)),f!=null&&(f=Zr(f,d)),Vy(n,a,l,f,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:be(this.betaInitializer),gammaInitializer:be(this.gammaInitializer),betaRegularizer:ie(this.betaRegularizer),gammaRegularizer:ie(this.gammaRegularizer)},r=super.getConfig();return Object.assign(t,r),t}};Gy.className="LayerNormalization";Z.registerClass(Gy);function zit(e,t,r){return V(()=>{if(e.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(r==null&&(r=En()),r!=="channelsLast"&&r!=="channelsFirst")throw new z(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return r==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Ap(e,n)})}var Uy=class extends Ot{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?En():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let r,n;if(typeof t.padding[0]=="number")r=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(r=t.padding[0],t.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[r,n]}this.inputSpec=[new me({ndim:4})]}computeOutputShape(t){t=Mt(t);let r,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?r=t[2]+this.padding[0][0]+this.padding[0][1]:r=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],r,n]):(t[1]!=null&&t[1]>=0?r=t[1]+this.padding[0][0]+this.padding[0][1]:r=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],r,n,t[3]])}call(t,r){return V(()=>zit(Et(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}};Uy.className="ZeroPadding2D";Z.registerClass(Uy);function uC(e,t,r,n,o,s){return V(()=>{_e(o),N_(s),Nn(n),r==null&&(r=[1,1]),n==null&&(n="valid"),o==null&&(o=En()),s==null&&(s="max"),e=hy(e,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Ep(e,t,r,a):i=kp(e,t,r,a),o==="channelsFirst"&&(i=Lt(i,[0,3,1,2])),i})}function _B(e,t,r,n,o,s){return V(()=>{_e(o),N_(s),Nn(n),r==null&&(r=[1,1,1]),n==null&&(n="valid"),o==null&&(o=En()),s==null&&(s="max"),e=G_(e,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=t_(e,t,r,a):i=RE(e,t,r,a),o==="channelsFirst"&&(i=Lt(i,[0,4,1,2,3])),i})}var oC=class extends Ot{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(je(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Nn(this.padding),this.inputSpec=[new me({ndim:3})]}computeOutputShape(t){t=Mt(t);let r=Hn(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],r,t[2]]}call(t,r){return V(()=>{this.invokeCallHook(t,r),t=dl(Et(t),2);let n=this.poolingFunction(Et(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ms(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},r=super.getConfig();return Object.assign(t,r),t}},Hy=class extends oC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),uC(t,r,n,o,s,"max")}};Hy.className="MaxPooling1D";Z.registerClass(Hy);var qy=class extends oC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),uC(t,r,n,o,s,"avg")}};qy.className="AveragePooling1D";Z.registerClass(qy);var sC=class extends Ot{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];je(this.poolSize,"poolSize"),je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,_e(this.dataFormat),Nn(this.padding),this.inputSpec=[new me({ndim:4})]}computeOutputShape(t){t=Mt(t);let r=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return r=Hn(r,this.poolSize[0],this.padding,this.strides[0]),n=Hn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],r,n]:[t[0],r,n,t[3]]}call(t,r){return V(()=>(this.invokeCallHook(t,r),this.poolingFunction(Et(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}},jy=class extends sC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),uC(t,r,n,o,s,"max")}};jy.className="MaxPooling2D";Z.registerClass(jy);var Ky=class extends sC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),uC(t,r,n,o,s,"avg")}};Ky.className="AveragePooling2D";Z.registerClass(Ky);var iC=class extends Ot{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];je(this.poolSize,"poolSize"),je(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,_e(this.dataFormat),Nn(this.padding),this.inputSpec=[new me({ndim:5})]}computeOutputShape(t){t=Mt(t);let r=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return r=Hn(r,this.poolSize[0],this.padding,this.strides[0]),n=Hn(n,this.poolSize[1],this.padding,this.strides[1]),o=Hn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],r,n,o]:[t[0],r,n,o,t[4]]}call(t,r){return V(()=>(this.invokeCallHook(t,r),this.poolingFunction(Et(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}},Xy=class extends iC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),_B(t,r,n,o,s,"max")}};Xy.className="MaxPooling3D";Z.registerClass(Xy);var Yy=class extends iC{constructor(t){super(t)}poolingFunction(t,r,n,o,s){return _e(s),Nn(o),_B(t,r,n,o,s,"avg")}};Yy.className="AveragePooling3D";Z.registerClass(Yy);var aC=class extends Ot{constructor(t){super(t),this.inputSpec=[new me({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,r){throw new It}},Qy=class extends aC{constructor(t){super(t||{})}call(t,r){return V(()=>{let n=Et(t);return Ee(n,1)})}};Qy.className="GlobalAveragePooling1D";Z.registerClass(Qy);var Zy=class extends aC{constructor(t){super(t||{})}call(t,r){return V(()=>{let n=Et(t);return Br(n,1)})}};Zy.className="GlobalMaxPooling1D";Z.registerClass(Zy);var lC=class extends Ot{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,_e(this.dataFormat),this.inputSpec=[new me({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,r){throw new It}getConfig(){let t={dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}},Jy=class extends lC{call(t,r){return V(()=>{let n=Et(t);return this.dataFormat==="channelsLast"?Ee(n,[1,2]):Ee(n,[2,3])})}};Jy.className="GlobalAveragePooling2D";Z.registerClass(Jy);var tb=class extends lC{call(t,r){return V(()=>{let n=Et(t);return this.dataFormat==="channelsLast"?Br(n,[1,2]):Br(n,[2,3])})}};tb.className="GlobalMaxPooling2D";Z.registerClass(tb);var cC=class extends Ot{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},r=super.getConfig();return Object.assign(t,r),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,r,n={}){let o=r.layer,s=ho(o,n);delete r.layer;let i={layer:s};return Object.assign(i,r),new t(i)}},eb=class extends cC{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Mt(t),t.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let r=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Mt(t);let r=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(r),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,r){return V(()=>(t=Et(t),H_((i,a)=>[Et(this.layer.call(i,r)),[]],t,[],!1,null,null,!1,!0)[1]))}};eb.className="TimeDistributed";Z.registerClass(eb);function Bit(e){Ri(W3,"BidirectionalMergeMode",e)}var Vit="concat",rb=class extends cC{constructor(t){super(t);let r=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=r,this.forwardLayer=ho(n),r.goBackwards=r.goBackwards!==!0;let o={};if(o.className=t.layer.getClassName(),o.config=r,this.backwardLayer=ho(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Vit:t.mergeMode,Bit(this.mergeMode),t.weights)throw new It("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let r=t.length,n=Math.floor(r/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let r=this.forwardLayer.computeOutputShape(t);Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r;let n,o,s;return this.returnState&&(s=r.slice(1)),n=r[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Ar(o)}apply(t,r){let n=r==null?null:r.initialState,o=r==null?null:r.constants;r==null&&(r={});let s=U_(t,n,o,this.numConstants);if(t=s.inputs,n=s.initialState,o=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&o==null)return super.apply(t,r);let i=[],a=[];if(n!=null){let u=n.length;if(u%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=n,i.push(...n);let c=n.map(p=>new me({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(o!=null)throw new It("Support for constants in Bidirectional layers is not implemented yet.");let l=i[0]instanceof dn;for(let u of i)if(u instanceof dn!==l)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let u=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let f=super.apply(u,r);return this.inputSpec=p,f}else return super.apply(t,r)}call(t,r){return V(()=>{let n=r.initialState,o,s;if(n==null)o=this.forwardLayer.call(t,r),s=this.backwardLayer.call(t,r);else{let l=n.slice(0,n.length/2),u=n.slice(n.length/2);o=this.forwardLayer.call(t,Object.assign(r,{initialState:l})),s=this.backwardLayer.call(t,Object.assign(r,{initialState:u}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=Ro(s,1));let a;return this.mergeMode==="concat"?a=Od([o,s]):this.mergeMode==="sum"?a=tt(o,s):this.mergeMode==="ave"?a=F(.5,tt(o,s)):this.mergeMode==="mul"?a=F(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ws(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ws(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,r){Array.isArray(r)&&(r=r[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[r,r]:n=r:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(t,r),t}static fromConfig(t,r){let n=ho(r.layer);if(delete r.layer,r.numConstants!=null)throw new It("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=r;return o.layer=n,new t(o)}};rb.className="Bidirectional";Z.registerClass(rb);var nb=class extends Ot{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){let t={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(t,r),t}call(t,r){return V(()=>(t=Et(t),t.dtype!=="float32"&&(t=fn(t,"float32")),tt(F(t,this.scale),this.offset)))}};nb.className="Rescaling";Z.registerClass(nb);var{resizeBilinear:Wit,cropAndResize:Git}=Bs,ob=class extends Ot{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,r,n,o,s,i,a,l){return V(()=>{let u,c=!1,p=r/i,f=n/a,m=(o+r)/i,d=(s+n)/a,h=[p,f,m,d],x=[];t.rank===3?(c=!0,u=Cr([t])):u=t;for(let C=0;C<u.shape[0];C++)x.push(h);let g=sr(x,[x.length,4]),y=pl(0,x.length,1,"int32"),v=Git(u,g,y,[o,s],"nearest");return c?fn(Et(pn(v)),l):fn(v,l)})}upsize(t,r,n,o){return V(()=>{let s=Wit(t,[r,n]);return fn(s,o)})}call(t,r){return V(()=>{let n=Et(t),o=n.dtype,s=n.shape,i=s[s.length-3],a=s[s.length-2],l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(n,l,u,this.height,this.width,i,a,o):this.upsize(t,this.height,this.width,o)})}getConfig(){let t={height:this.height,width:this.width},r=super.getConfig();return Object.assign(t,r),t}computeOutputShape(t){t=Mt(t);let r=t.length-3,n=t.length-2;return t[r]=this.height,t[n]=this.width,t}};ob.className="CenterCrop";Z.registerClass(ob);function AB(e,t,r,n){let o=Et(e);if(o.dtype!=="int32"&&(o=fn(o,"int32")),t==="int")return o;let s=o.shape;if(o.rank===0&&(o=hr(o,-1)),t==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=hr(o,-1)),o.rank>2)throw new z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${o.rank}.`);let i=["multiHot","oneHot"].includes(t),a=o,l;if(typeof n!="undefined"&&t==="count"?l=Uw(a,n,r,i):l=Uw(a,[],r,i),t!=="tfIdf")return l;if(n)return F(l,n);throw new z("When outputMode is 'tfIdf', weights must be provided.")}var sb=class extends Ot{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){let t={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(t,r),t}computeOutputShape(t){return t=Mt(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,r){return V(()=>{t=Et(t),t.dtype!=="int32"&&(t=fn(t,"int32"));let n;if(typeof r.countWeights!="undefined"){if(this.outputMode!=="count")throw new z(`countWeights is not used when outputMode !== count.
              Received countWeights=${r.countWeights}`);n=Et(r.countWeights)}let o=Br(t),s=Ju(t),i=We(this.numTokens,o).bufferSync().get(0),a=Wn(s,0).bufferSync().get(0);if(!(i&&a))throw new z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return AB(t,this.outputMode,this.numTokens,n)})}};sb.className="CategoryEncoding";Z.registerClass(sb);var Hit=["bilinear","nearest"],DB=new Set(Hit),ib=class extends Ot{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(DB.has(t.interpolation))this.interpolation=t.interpolation;else throw new z(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=Mt(t);let r=t[2];return[this.height,this.width,r]}getConfig(){let t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(t,r),t}call(t,r){return V(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Bs.resizeBilinear(t,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Bs.resizeNearestNeighbor(t,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...DB]} are supported`)})}};ib.className="Resizing";Z.registerClass(ib);var Qit=B();Qit.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var q_;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(q_||(q_={}));var RB;(function(e){let t;(function(r){r[r.LEGACY=0]="LEGACY",r[r.V1=1]="V1",r[r.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(RB||(RB={}));var GB=Yt(wx());var BB=Yt(wx());function OB(e,t){return FB(e,t)}function FB(e,t,r=new Map,n=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(n.has(e))throw new Error("Circular references are not supported.");if(r.has(e))return r.get(e);let o=t(e);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(eh(e)){let s=Array.isArray(e)?[]:{};n.add(e);for(let i in e){let a=e[i],l=FB(a,t,r,n);s[i]=l}return n.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return r.set(e,o.value),o.value}function PB(e,t=j_){return LB(e,t)}function LB(e,t,r=new Set){let n=e[0];if(r.has(n))throw new Error("Circular references are not supported.");let o=t(e);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(eh(n)){let s=Array.isArray(n)?[]:{};r.add(n);for(let i in n){let a=e.map(u=>u[i]),l=LB(a,t,r);s[i]=l}return r.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function j_(e){return e===null?null:eh(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function eh(e){let t=!1;if(B().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:r}=$B();t=e instanceof r}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof qt)&&!(e instanceof Promise)&&!t)}function MB(e){return e==null||Uat(e)||Array.isArray(e)||typeof e=="object"&&e instanceof qt||w.isTypedArray(e)}function Uat(e){return e===null||typeof e!="object"&&typeof e!="function"}function zB(e){return OB(e,Hat)}function Hat(e){return e instanceof qt?{value:e.clone(),recurse:!1}:eh(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var rh=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,r){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=r}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let r of t)this.push(r)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let r=this.wrap(this.begin+t),n=this.get(r);return this.set(r,this.pop()),n}};var Xp=class extends rh{constructor(){super(Xp.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,r=new Array(t),n=this.length();for(let o=0;o<n;o++)r[o]=this.get(this.wrap(this.begin+o));this.data=r,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Xp.INITIAL_CAPACITY=32;function VB(e){return new K_(e)}function i2(e){return new X_(e)}function WB(e,t){return new mC(e,t)}var Vr=class{toArray(){return H(this,null,function*(){let t=[],r=yield this.next();for(;!r.done;)t.push(r.value),r=yield this.next();return t})}toArrayForTest(){return H(this,null,function*(){let t=this.prefetch(100),r=[],n=yield t.next();for(;!n.done;)r.push(n.value),n=yield t.next();return r})}resolveFully(){return H(this,null,function*(){let t=yield this.next();for(;!t.done;)t=yield this.next()})}resolveWhile(t){return H(this,null,function*(){let r=yield this.next(),n=t(r.value);for(;!r.done&&n;)r=yield this.next(),n=t(r.value)})}handleErrors(t){return new r2(this,t)}filter(t){return new t2(this,t)}map(t){return new e2(this,t)}mapAsync(t){return new fC(this,t)}serialMapAsync(t){return new fC(this,t).serial()}flatmap(t){return new n2(this,t)}forEachAsync(t){return H(this,null,function*(){return this.map(t).resolveFully()})}serialForEach(t){return H(this,null,function*(){return this.serialMapAsync(t).resolveWhile(r=>r===!0)})}rowMajorBatch(t,r=!0){return new J_(this,t,r)}columnMajorBatch(t,r=!0,n=j_){return this.rowMajorBatch(t,r).map(s=>PB(s,n))}concatenate(t,r){return new mC(VB([this,t]),r)}take(t){return t<0||t==null?this:new Z_(this,t)}skip(t){return t<0||t==null?this:new Q_(this,t)}prefetch(t){return new dC(this,t)}shuffle(t,r){return new s2(this,t,r)}serial(){return new Y_(this)}},K_=class extends Vr{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){return H(this,null,function*(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:zB(t),done:!1}})}},X_=class extends Vr{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}next(){return H(this,null,function*(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})}},Y_=class extends Vr{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){return this.upstream.next()})}},Q_=class extends Vr{constructor(t,r){super(),this.upstream=t,this.maxCount=r,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){for(;this.count++<this.maxCount;){let t=yield this.upstream.next();if(t.done)return t;$t(t.value)}return this.upstream.next()})}},Z_=class extends Vr{constructor(t,r){super(),this.upstream=t,this.maxCount=r,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){return H(this,null,function*(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()})}},J_=class extends Vr{constructor(t,r,n=!0){super(),this.upstream=t,this.batchSize=r,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){let t=[];for(;t.length<this.batchSize;){let r=yield this.upstream.next();if(r.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(r.value)}return{value:t,done:!1}})}},t2=class extends Vr{constructor(t,r){super(),this.upstream=t,this.predicate=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){for(;;){let t=yield this.upstream.next();if(t.done||this.predicate(t.value))return t;$t(t.value)}})}},e2=class extends Vr{constructor(t,r){super(),this.upstream=t,this.transform=r}summary(){return`${this.upstream.summary()} -> Map`}next(){return H(this,null,function*(){let t=yield this.upstream.next();if(t.done)return{value:null,done:!0};let r=Jo.getTensorsInContainer(t.value),n=this.transform(t.value),o=Jo.getTensorsInContainer(n);for(let s of r)Jo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}})}},r2=class extends Vr{constructor(t,r){super(),this.upstream=t,this.handler=r,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){for(;;)try{return yield this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}})}},fC=class extends Vr{constructor(t,r){super(),this.upstream=t,this.transform=r}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){return H(this,null,function*(){let t=yield this.upstream.next();if(t.done)return{value:null,done:!0};let r=Jo.getTensorsInContainer(t.value),n=yield this.transform(t.value),o=Jo.getTensorsInContainer(n);for(let s of r)Jo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}})}},ab=class extends Vr{constructor(){super(),this.outputQueue=new Xp,this.lastRead=Promise.resolve({value:null,done:!1})}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return H(this,null,function*(){for(;this.outputQueue.length()===0;)if(!(yield this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}})}},n2=class extends ab{constructor(t,r){super(),this.upstream=t,this.transform=r}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){return H(this,null,function*(){let t=yield this.upstream.next();if(t.done)return!1;let r=Jo.getTensorsInContainer(t.value),n=this.transform(t.value),o=Jo.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of r)Jo.isTensorInList(s,o)||s.dispose();return!0})}},mC=class extends Vr{constructor(t,r){super(),this.baseErrorHandler=r,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){return H(this,null,function*(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead})}readFromChain(t){return H(this,null,function*(){if(yield t,this.iterator==null){let n=yield this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let r=yield this.iterator.next();return r.done?(this.iterator=null,this.readFromChain(t)):r})}},o2;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(o2||(o2={}));var dC=class extends Vr{constructor(t,r){super(),this.upstream=t,this.bufferSize=r,this.buffer=new rh(r)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},s2=class extends dC{constructor(t,r,n){super(t,r),this.upstream=t,this.windowSize=r,this.upstreamExhausted=!1,this.random=BB.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){return H(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){return H(this,null,function*(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),r=yield this.buffer.shuffleExcise(t);if(r.done)this.upstreamExhausted=!0;else return this.refill(),r}return{value:null,done:!0}})}};var Yp=class{constructor(){this.size=null}batch(t,r=!0){let n=this;w.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:r?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),js(()=>H(this,null,function*(){return(yield n.iterator()).columnMajorBatch(t,r,jat)}),o)}concatenate(t){let r=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,js(()=>H(this,null,function*(){return(yield r.iterator()).concatenate(yield t.iterator())}),n)}filter(t){let r=this,n;return this.size===1/0?n=1/0:n=null,js(()=>H(this,null,function*(){return(yield r.iterator()).filter(o=>V(()=>t(o)))}),n)}forEachAsync(t){return H(this,null,function*(){return(yield this.iterator()).forEachAsync(t)})}map(t){let r=this;return js(()=>H(this,null,function*(){return(yield r.iterator()).map(n=>V(()=>t(n)))}),this.size)}mapAsync(t){let r=this;return js(()=>H(this,null,function*(){return(yield r.iterator()).mapAsync(t)}),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let r=this;return js(()=>H(this,null,function*(){return(yield r.iterator()).prefetch(t)}),this.size)}repeat(t){let r=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,js(()=>H(this,null,function*(){let o=i2(()=>H(this,null,function*(){return{value:yield r.iterator(),done:!1}}));return WB(o.take(t))}),n)}skip(t){let r=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,js(()=>H(this,null,function*(){return(yield r.iterator()).skip(t)}),n)}shuffle(t,r,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=GB.alea(r||w.now().toString());return js(()=>H(this,null,function*(){let i=s.int32();return n&&(i+=s.int32()),(yield o.iterator()).shuffle(t,i.toString())}),this.size)}take(t){let r=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,js(()=>H(this,null,function*(){return(yield r.iterator()).take(t)}),n)}toArray(){return H(this,null,function*(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield this.iterator()).toArray()})}toArrayForTest(){return H(this,null,function*(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield this.iterator()).toArrayForTest()})}};Yp.MAX_BUFFER_SIZE=1e4;function js(e,t=null){return new class extends Yp{constructor(){super(...arguments),this.size=t}iterator(){return H(this,null,function*(){return e()})}}}function jat(e){if(e===null)return null;let t=e[0];return MB(t)?{value:Kat(e),recurse:!1}:{value:null,recurse:!0}}function Kat(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof qt?Cr(e):sr(e)}var She=Symbol("out"),khe=Symbol("field"),The=Symbol("quote"),Nhe=Symbol("quoteafterquote"),Ihe=Symbol("quoteinquote");function J(e,t){Array.isArray(e)||(e=[e]),e.forEach(r=>{r!=null&&w.assert(r.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var olt=tn.whereImpl,Qp=class extends sa{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Zc(this,ts())}nextDataId(){return Qp.nextDataId++}write(t,r,n){this.firstUse&&(this.firstUse=!1,B().get("IS_NODE")&&T.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:n,refCount:1}),o}makeTensorInfo(t,r,n){let o;if(r==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(i=>w.encodeString(i));o=this.write(s,t,r)}else o=this.write(n,t,r);return{dataId:o,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let r=this.data.get(t);r.refCount++}decRef(t){if(this.data.has(t)){let r=this.data.get(t);r.refCount--}}move(t,r,n,o,s){this.data.set(t,{values:r,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}read(t){return H(this,null,function*(){return this.readSync(t)})}readSync(t){let{dtype:r,complexTensorInfos:n}=this.data.get(t);if(r==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return T.mergeRealAndImagArrays(o,s)}return this.data.get(t).values}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let n=r.map(o=>w.decodeString(o));return Ct(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(t.shape,t.dtype,r)}makeOutput(t,r,n){return ts().makeTensorFromTensorInfo(this.makeTensorInfo(r,n,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return H(this,null,function*(){let r=w.now();return t(),{kernelMs:w.now()-r}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){J([t],"where");let r=this.readSync(t.dataId);return olt(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Qp.nextDataId=0;var $2={};Zn($2,{addImpl:()=>u2,bincountImpl:()=>sh,bincountReduceImpl:()=>hC,castImpl:()=>l2,ceilImpl:()=>c2,concatImpl:()=>gC,equalImpl:()=>p2,expImpl:()=>m2,expm1Impl:()=>h2,floorImpl:()=>g2,gatherNdImpl:()=>xC,gatherV2Impl:()=>yC,greaterEqualImpl:()=>y2,greaterImpl:()=>x2,lessEqualImpl:()=>v2,lessImpl:()=>b2,linSpaceImpl:()=>bC,logImpl:()=>w2,maxImpl:()=>vC,maximumImpl:()=>C2,minimumImpl:()=>S2,multiplyImpl:()=>lb,negImpl:()=>k2,notEqualImpl:()=>T2,prodImpl:()=>N2,raggedGatherImpl:()=>wC,raggedRangeImpl:()=>CC,raggedTensorToTensorImpl:()=>SC,rangeImpl:()=>kC,rsqrtImpl:()=>I2,scatterImpl:()=>vl,sigmoidImpl:()=>yV,simpleAbsImpl:()=>a2,sliceImpl:()=>_2,sparseFillEmptyRowsImpl:()=>TC,sparseReshapeImpl:()=>NC,sparseSegmentReductionImpl:()=>lh,sqrtImpl:()=>wV,squaredDifferenceImpl:()=>A2,stridedSliceImpl:()=>IC,stringNGramsImpl:()=>EC,stringSplitImpl:()=>_C,stringToHashBucketFastImpl:()=>AC,subImpl:()=>R2,tileImpl:()=>DC,topKImpl:()=>RC,transposeImpl:()=>ih,uniqueImpl:()=>$C});function a2(e){let t=new Float32Array(e.length);for(let r=0;r<e.length;++r)t[r]=Math.abs(e[r]);return t}var slt=e=>{let{x:t}=e.inputs,r=e.backend;J(t,"abs");let n=new Float32Array(w.sizeFromShape(t.shape)),o=r.data.get(t.dataId).values;return n=a2(o),r.makeOutput(n,t.shape,t.dtype)},UB={kernelName:ru,backendName:"cpu",kernelFunc:slt};function Xt(e){return(t,r,n,o,s)=>{let i=T.assertAndGetBroadcastShape(t,r),a=i.length,l=w.computeStrides(i),u=w.sizeFromShape(i),c=w.getTypedArrayFromDType(s,u),p=t.length,f=r.length,m=w.computeStrides(t),d=w.computeStrides(r),h=T.getBroadcastDims(t,i),x=T.getBroadcastDims(r,i);if(h.length+x.length===0)for(let g=0;g<c.length;++g)c[g]=e(n[g%n.length],o[g%o.length]);else for(let g=0;g<c.length;++g){let y=w.indexToLoc(g,a,l),b=y.slice(-p);h.forEach(k=>b[k]=0);let v=w.locToIndex(b,p,m),C=y.slice(-f);x.forEach(k=>C[k]=0);let S=w.locToIndex(C,f,d);c[g]=e(n[v],o[S])}return[c,i]}}function Sr(e){let{inputs:t,backend:r}=e,{real:n,imag:o}=t,s=r.data.get(n.dataId).values,i=r.data.get(o.dataId).values,a=r.makeTensorInfo(n.shape,"complex64"),l=r.data.get(a.dataId);return l.complexTensorInfos={real:r.makeTensorInfo(n.shape,"float32",s),imag:r.makeTensorInfo(o.shape,"float32",i)},a}var HB={kernelName:wm,backendName:"cpu",kernelFunc:Sr};function nh(e,t,r="float32"){if(r==="complex64"){let o=nh(e,t,"float32"),s=nh(e,t,"float32");return Sr({inputs:{real:o,imag:s},backend:e})}let n=w.makeZerosTypedArray(w.sizeFromShape(t),r);return e.makeTensorInfo(t,r,n)}function rn(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var qB={kernelName:yi,backendName:"cpu",kernelFunc:rn};function ds(e){let{inputs:t,backend:r}=e,{input:n}=t,o=r.data.get(n.dataId).complexTensorInfos.real,s=r.data.get(o.dataId).values;return r.makeTensorInfo(o.shape,o.dtype,s)}var jB={kernelName:Hm,backendName:"cpu",kernelFunc:ds};function l2(e,t,r,n){if(n==="int32"){let o=Int32Array.from(e);return[t,"int32",o]}if(n==="bool"){let o=w.toTypedArray([0],r),[s,i]=Xt((a,l)=>a!==l?1:0)(t,[],e,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${r} to ${n}`)}function hs(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return rn({inputs:{x:o},backend:r});let c=nh(r,o.shape,o.dtype),p=hs({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),f=Sr({inputs:{real:p,imag:c},backend:r});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(p),f}if(o.dtype==="complex64"){let c=ds({inputs:{input:o},backend:r}),p=hs({inputs:{x:c},backend:r,attrs:{dtype:s}});return r.disposeIntermediateTensorInfo(c),p}if(!w.hasEncodingLoss(o.dtype,s)){let c=rn({inputs:{x:o},backend:r});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=r.data.get(o.dataId).values,[a,l,u]=l2(i,o.shape,o.dtype,s);return r.makeTensorInfo(a,l,u)}var KB={kernelName:xi,backendName:"cpu",kernelFunc:hs};function Jt(e,t,r,n){return r==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;J([i,a],e);let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=i.dtype==="string"?T.fromUint8ToStringArray(u):u,f=i.dtype==="string"?T.fromUint8ToStringArray(c):c,m=n||i.dtype,[d,h]=t(i.shape,a.shape,p,f,m);return l.makeTensorInfo(h,m,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let u=hs({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,m=l.data.get(p.dataId).values,d=l.data.get(f.dataId).values,h=hs({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),x=l.data.get(h.dataId),g=x.complexTensorInfos.real,y=x.complexTensorInfos.imag,b=l.data.get(g.dataId).values,v=l.data.get(y.dataId).values,[C,S,k]=r(i.shape,a.shape,m,d,b,v),I=l.makeTensorInfo(k,"float32",C),D=l.makeTensorInfo(k,"float32",S),R=Sr({inputs:{real:I,imag:D},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(h),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(D),R}else{let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=n||i.dtype,[f,m]=t(i.shape,a.shape,u,c,p);return l.makeTensorInfo(m,p,f)}}}function oh(e){return(t,r,n,o,s,i)=>{let a=T.assertAndGetBroadcastShape(t,r),l=w.sizeFromShape(a),u=a.length,c=w.computeStrides(a),p=w.getTypedArrayFromDType("float32",l),f=w.getTypedArrayFromDType("float32",l),m=T.getBroadcastDims(t,a),d=T.getBroadcastDims(r,a),h=T.mergeRealAndImagArrays(n,o),x=T.mergeRealAndImagArrays(s,i),g=t.length,y=w.computeStrides(t),b=r.length,v=w.computeStrides(r);if(m.length+d.length===0)for(let C=0;C<p.length;C++){let S=C%h.length,k=C%x.length,I=e(h[S*2],h[S*2+1],x[k*2],x[k*2+1]);p[C]=I.real,f[C]=I.imag}else for(let C=0;C<p.length;C++){let S=w.indexToLoc(C,u,c),k=S.slice(-g);m.forEach(U=>k[U]=0);let I=w.locToIndex(k,g,y),D=S.slice(-b);d.forEach(U=>D[U]=0);let R=w.locToIndex(D,b,v),M=e(h[I*2],h[I*2+1],x[R*2],x[R*2+1]);p[C]=M.real,f[C]=M.imag}return[p,f,a]}}var u2=Xt((e,t)=>e+t),ilt=oh((e,t,r,n)=>({real:e+r,imag:t+n})),Oi=Jt(Fs,u2,ilt),XB={kernelName:Fs,backendName:"cpu",kernelFunc:Oi};function sh(e,t,r,n,o){let s=w.sizeFromShape(n),i=w.makeZerosTypedArray(o,r);for(let a=0;a<e.length;a++){let l=e[a];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(s>0?i[l]+=t[a]:i[l]+=1)}return i}function hC(e,t,r,n=!1){let o=e.shape[0],s=e.shape[1],i=Ct([o,r],t.dtype);for(let a=0;a<o;a++)for(let l=0;l<s;l++){let u=e.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=r||(n?i.set(1,a,u):t.size>0?i.set(i.get(a,u)+t.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}function Dn(e){return(t,r,n)=>{let o=w.getTypedArrayFromDType(r,t.length);for(let s=0;s<t.length;++s)o[s]=e(t[s],n);return o}}function Rt(e,t,r){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(J(i,e),i.dtype==="string"||r==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,l=a.data.get(i.dataId).values,u=w.sizeFromShape(i.shape),c=r||i.dtype,p=w.getArrayFromDType(c,u);for(let f=0;f<u;++f)p[f]=t(l[f],o);return a.makeTensorInfo(i.shape,c,p)}}function gs(e,t,r){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(J(i,e),i.dtype==="string"||r==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,l=a.data.get(i.dataId).values,u=r||i.dtype,c=t(l,u,o);return a.makeTensorInfo(i.shape,u,c)}}var c2=Dn(e=>Math.ceil(e)),alt=gs(da,c2),YB={kernelName:da,backendName:"cpu",kernelFunc:alt};function gC(e,t,r,n){let o=w.getArrayFromDType(r,w.sizeFromShape(t));if(n&&r!=="string"){let s=0;e.forEach(i=>{let a=w.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;e.forEach(i=>{let a=r==="string"?T.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[l++]}s+=i.shape[1]})}return o}var p2=Xt((e,t)=>e===t?1:0),f2=Jt(rp,p2,null,"bool"),QB={kernelName:rp,backendName:"cpu",kernelFunc:f2};var m2=Dn(e=>Math.exp(e)),d2=gs(wa,m2,"float32"),ZB={kernelName:wa,backendName:"cpu",kernelFunc:d2};var h2=Dn(e=>Math.expm1(e)),llt=gs(Ca,h2),JB={kernelName:Ca,backendName:"cpu",kernelFunc:llt};var g2=Dn(e=>Math.floor(e)),ult=gs(Sa,g2),tV={kernelName:Sa,backendName:"cpu",kernelFunc:ult};function xC(e,t,r,n,o,s,i,a,l){let u=Ct([n,s],r);for(let c=0;c<n;c++){let p=[],f=0;for(let m=0;m<o;m++){let d=e[c*o+m];f+=d*i[m],p.push(d)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let m=0;m<s;m++)u.values[c*s+m]=t.get(...t.indexToLoc(f*s+m))}return u}function yC(e,t,r){let n=Ct(r,e.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],l=i[2],u=t.locToIndex([a,l]);i[2]=t.values[u];let c=e.locToIndex(i);0<=c&&c<e.values.length&&(n.values[o]=e.values[c])}return n}var x2=Xt((e,t)=>e>t?1:0),clt=Jt(np,x2,null,"bool"),eV={kernelName:np,backendName:"cpu",kernelFunc:clt};var y2=Xt((e,t)=>e>=t?1:0),plt=Jt(Ta,y2,null,"bool"),rV={kernelName:Ta,backendName:"cpu",kernelFunc:plt};var b2=Xt((e,t)=>e<t?1:0),flt=Jt(op,b2,null,"bool"),nV={kernelName:op,backendName:"cpu",kernelFunc:flt};var v2=Xt((e,t)=>e<=t?1:0),mlt=Jt(sp,v2,null,"bool"),oV={kernelName:sp,backendName:"cpu",kernelFunc:mlt};function bC(e,t,r){let n=(t-e)/(r-1),o=w.makeZerosTypedArray(r,"float32");o[0]=e;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var w2=Dn(e=>Math.log(e)),dlt=gs(_a,w2),sV={kernelName:_a,backendName:"cpu",kernelFunc:dlt};function vC(e,t,r,n){let o=w.getTypedArrayFromDType(n,w.sizeFromShape(r));for(let s=0;s<o.length;++s){let i=s*t,a=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>a)&&(a=u)}o[s]=a}return o}var C2=Xt((e,t)=>Math.max(e,t)),hlt=Jt(Da,C2),iV={kernelName:Da,backendName:"cpu",kernelFunc:hlt};var S2=Xt((e,t)=>Math.min(e,t)),glt=Jt(Ra,S2),aV={kernelName:Ra,backendName:"cpu",kernelFunc:glt};var lb=Xt((e,t)=>e*t),xlt=oh((e,t,r,n)=>({real:e*r-t*n,imag:e*n+t*r})),Zp=Jt(Oa,lb,xlt),lV={kernelName:Oa,backendName:"cpu",kernelFunc:Zp};function k2(e,t,r){let n=w.createScalarValue(-1,r);return lb([],t,n,e,r)}function ylt(e){let{inputs:t,backend:r}=e,{x:n}=t;J(n,"neg");let o=r.data.get(n.dataId).values,[s,i]=k2(o,n.shape,n.dtype);return r.makeTensorInfo(i,n.dtype,s)}var uV={kernelName:Eu,backendName:"cpu",kernelFunc:ylt};var T2=Xt((e,t)=>e!==t?1:0),blt=Jt(up,T2,null,"bool"),cV={kernelName:up,backendName:"cpu",kernelFunc:blt};function ih(e,t,r,n,o){let s=t.length,i=w.sizeFromShape(t),a=w.computeStrides(t),l=w.computeStrides(o),u=w.getTypedArrayFromDType(r,w.sizeFromShape(o));for(let c=0;c<i;++c){let p=w.indexToLoc(c,s,a),f=new Array(p.length);for(let d=0;d<f.length;d++)f[d]=p[n[d]];let m=w.locToIndex(f,s,l);u[m]=e[c]}return u}function Pe(e){let{inputs:t,attrs:r,backend:n}=e,{x:o}=t,{perm:s}=r;J(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let l=n.data.get(o.dataId).values,u=ih(l,o.shape,o.dtype,s,a);return{dataId:n.write(u,a,o.dtype),shape:a,dtype:o.dtype}}var pV={kernelName:vi,backendName:"cpu",kernelFunc:Pe};function N2(e,t,r,n){let[o,s]=T.computeOutAndReduceShapes(e,n),i=or(t,"int32"),a=w.makeZerosTypedArray(w.sizeFromShape(o),i),l=w.sizeFromShape(s);for(let u=0;u<a.length;++u){let c=u*l,p=1;for(let f=0;f<l;++f)p*=r[c+f];a[u]=p}return{outVals:a,outShape:o,outDtype:i}}function vlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;J(o,"prod");let a=o.shape.length,l=w.parseAxisParam(s,o.shape),u=T.getAxesPermutation(l,a),c=l,p=o,f=[];u!=null&&(p=Pe({inputs:{x:o},backend:r,attrs:{perm:u}}),f.push(p),c=T.getInnerMostAxes(c.length,a));let m=r.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:x}=N2(p.shape,p.dtype,m,c),g=h;return i&&(g=T.expandShapeToKeepDim(h,l)),f.forEach(y=>r.disposeIntermediateTensorInfo(y)),r.makeTensorInfo(g,x,d)}var fV={kernelName:Ou,backendName:"cpu",kernelFunc:vlt};function wlt(e,t,r){e.forEach((n,o)=>{if(n<0||n>=r){let s=w.indexToLoc(o,t.length,w.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${n} is not in [0, ${r})`)}})}function Clt(e,t){for(let r=0;r<e.length;++r){let n=e[r],o=r===e.length-1?t:e[r+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<n.length;++s)if(n[s-1]>n[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Slt(e,t,r,n){let o=[],s=0,i=t.length-1+r.length,a=new Array(i).fill(null).map(()=>[0]);Clt(r,n);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let p=1;p<l+1;++p)a[u].push(p*c)}for(let u=0;u<e.length;++u){let c=e[u],p=e[u]+1;for(let f=0;f<r.length;++f){let m=r[f],d=f+t.length-1;if(d>=0){let h=a[d],x=h[h.length-1]-m[c];for(let g=c;g<p;++g)a[d].push(m[g+1]+x)}c=m[c],p=m[p]}p!==c&&(o.push([c,p]),s+=p-c)}return{outSplits:a,valueSlices:o,numValues:s}}function klt(e){let t=[];for(let r=0;r<e.length;++r){let n=e[r].length,o=w.getArrayFromDType("int32",n);t.push(o),e[r].forEach((s,i)=>o[i]=s)}return t}function mV(e,t){let r=e.slice(0,t);for(;r.length<t;)r.push(1);for(let n=t;n<e.length;n++)r[t-1]*=e[n];return r}function Tlt(e,t,r,n,o,s){let i=mV(t,2)[1],a=mV(s,2)[1],l=0;for(let u of r)for(let c=u[0];c<u[1];++c){for(let p=0;p<n;++p)o[l*a+p]=e[c*i+p];++l}}function Nlt(e,t,r,n,o){let s=t.slice();s[0]=o;let i=w.getArrayFromDType(r,w.sizeFromShape(s)),a=e.length,l=a===0?0:a/t[0];return Tlt(e,t,n,l,i,s),[i,s]}function wC(e,t,r,n,o,s,i,a){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(wlt(s,i,l),n.length===0)throw new Error("params.rank must be nonzero");let u=n[0],{outSplits:c,valueSlices:p,numValues:f}=Slt(s,i,e,u),m=klt(c),d=Nlt(r,n,o,p,f);return[m,d[0],d[1]]}var dV=2147483647;function CC(e,t,r,n,o,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=t.length===0,l=o.length===0,u=i.length===0,c=[];a||c.push(t[0]),l||c.push(o[0]),u||c.push(i[0]);for(let x=1;x<c.length;++x)if(c[x]!==c[x-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],f=w.getArrayFromDType("int32",p+1);f[0]=0;for(let x=0;x<p;++x){let g=a?e[0]:e[x],y=l?n[0]:n[x],b=u?s[0]:s[x];if(b===0)throw new Error("Requires delta != 0");let v;if(b>0&&y<g||b<0&&y>g)v=0;else if(v=Math.ceil(Math.abs((y-g)/b)),v>dV)throw new Error(`Requires ((limit - start) / delta) <= ${dV}`);f[x+1]=f[x]+v}let m=f[p],d=w.getArrayFromDType(r,m),h=0;for(let x=0;x<p;++x){let g=f[x+1]-f[x],y=a?e[0]:e[x],b=u?s[0]:s[x];for(let v=0;v<g;++v)d[h++]=y,y+=b}return[f,d]}var xs=T.RowPartitionType,ah=class{constructor(t,r,n,o,s,i,a,l,u,c){this.shape=t,this.shapeShape=r,this.values=n,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=T.getRowPartitionTypesHelper(c),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===xs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===xs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let r=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case xs.VALUE_ROWIDS:return ah.getMaxWidthValueRowID(r);case xs.ROW_SPLITS:return ah.getMaxWidthRowSplit(r);default:throw new Error(`Cannot handle partition type ${xs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let r=t.length;if(r===0||r===1)return 0;let n=0;for(let o=0;o<r-1;++o){let s=t[o+1]-t[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(t){let r=t.length;if(r===0)return 0;let n=0,o=t[0],s=0;for(let i=1;i<r;++i){let a=t[i];a!==o&&(o=a,s=Math.max(i-n,s),n=i)}return Math.max(r-n,s)}tensorShapeFromTensor(t,r,n=!0){if(r.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return gV(t,n)}calculateOutputSize(t){let r=this.valuesShape,n=this.defaultValueShape;T.validateDefaultValueShape(n,r);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=T.combineRaggedTensorToTensorShapes(this.raggedRank,o,r);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,r,n){let o=Math.min(t,n),s=[],i=0;for(let a=0;a<o;++a,i+=r)s.push(i);for(let a=o;a<t;++a)s.push(-1);return w.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,r,n,o){let s=t.length,i=[];for(let a=0;a<s-1;++a){let l=t[a+1]-t[a],u=Math.min(o,l),c=r[a];c===-1&&(u=0);for(let p=0;p<u;++p)i.push(c),c+=n;for(let p=0;p<l-u;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,r,n,o){let s=t.length,i=[];if(s===0)return[];let a=0,l=t[0];if(l>=r.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${r.length}`);let u=r[l];i.push(u);for(let c=1;c<s;++c){let p=t[c];if(p===l)u>=0&&(++a,a<o?u+=n:u=-1);else{if(a=0,l=p,p>=r.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${r.length}`);u=r[p]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,r,n,o){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case xs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,r,n,o);case xs.ROW_SPLITS:if(s.length-1>r.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${r.length}`);return this.calculateOutputIndexRowSplit(s,r,n,o);default:throw new Error(`Unsupported partition type: ${xs[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let r=this.rowPartitionTypes[0];switch(r){case xs.FIRST_DIM_SIZE:return t[0];case xs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case xs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${xs[r]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let r=this.getFirstDimensionSize(),n=this.calculateOutputSize(r),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let l=o.length-2;l>=0;--l)o[l]=o[l+1]*n[l+1];let s=gV(n,!1),i=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(s));if(o[0]*n[0]>0){let l=this.calculateFirstParentOutputIndex(r,o[0],n[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,o[u],n[u]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(t,r,n,o){if(n.length===0)return;let s=this.values,i=n,a=o.slice();a=a.slice(t+1);let l=w.sizeFromShape(a),u=r.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let d=this.defaultValueShape;V(()=>{let h=L(c,d);c=sl(h,a).dataSync()})}let p=0,f=0,m=0;for(let d=0;d<=u;++d){let h=d<u?r[d]:-1;if(h===m){++m;continue}if(f<m){let x=s.subarray(p*l),g=i.subarray(f*l),y=(m-f)*l;hV(g,x,y)}if(d>=u){let x=n.length;h=Math.floor(x/l)}if(h>m)if(this.defaultValue.length===1)i.subarray(m*l,h*l).fill(this.defaultValue[0]),m=h;else for(;h>m;){let x=i.slice(m*l);hV(x,c,l),++m}h<0?(p=d+1,f=m):(p=d,f=m,m=f+1)}}};function hV(e,t,r){for(let n=0;n<r;n++)e[n]=t[n]}function gV(e,t){let r=[];for(let n of e){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}r.push(n)}return r}function SC(e,t,r,n,o,s,i,a,l,u){return new ah(e,t,r,n,o,s,i,a,l,u).compute()}function kC(e,t,r,n){let o=e===t,s=e<t&&r<0,i=t<e&&r>1;if(o||s||i)return w.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-e)/r)),l=w.makeZerosTypedArray(a,n);t<e&&r===1&&(r=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+r;return l}var I2=Dn(e=>1/Math.sqrt(e)),Ilt=gs(Ba,I2),xV={kernelName:Ba,backendName:"cpu",kernelFunc:Ilt};function vl(e,t,r,n,o,s,i,a,l,u){let c=[n/o,o],p=e.values,f=t.values;if(n===0)return Ct(r,t.dtype);let m=Ct(c,t.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let d=0;d<s;d++){let h=[],x=0;for(let g=0;g<i;g++){let y=p[d*i+g];h.push(y),x+=y*a[g]}if(x<0||x>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${r}`);for(let g=0;g<o;g++)u?m.values[x*o+g]+=f[d*o+g]:m.values[x*o+g]=t.rank===0?f[0]:f[d*o+g]}return m}var yV=Dn(e=>1/(1+Math.exp(-e))),E2=Rt(Ha,e=>1/(1+Math.exp(-e))),bV={kernelName:Ha,backendName:"cpu",kernelFunc:E2};function _2(e,t,r,n,o){let s=Er.isSliceContinous(n,t,r),i=w.sizeFromShape(r),a=w.computeStrides(n);if(s){let p=Er.computeFlatOffset(t,a);return o==="string"?e.slice(p,p+i):e.subarray(p,p+i)}let l=o==="string"?T.fromUint8ToStringArray(e):e,u=Ct(n,o,l),c=Ct(r,o);for(let p=0;p<c.size;++p){let f=c.indexToLoc(p),m=f.map((d,h)=>d+t[h]);c.set(u.get(...m),...f)}return o==="string"?T.fromStringArrayToUint8(c.values):c.values}function ys(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{begin:s,size:i}=n;J(o,"slice");let[a,l]=Er.parseSliceParams(o,s,i);Er.assertParamsValid(o,a,l);let u=r.data.get(o.dataId).values,c=_2(u,a,l,o.shape,o.dtype);return r.makeTensorInfo(l,o.dtype,c)}var vV={kernelName:Bu,backendName:"cpu",kernelFunc:ys};function TC(e,t,r,n,o,s,i){let a=t[0],l=s[0],u=new Array(l),c=new Array(a),p=t[1];if(l===0){if(a!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let x=w.getArrayFromDType(r,0),g=w.getArrayFromDType(o,0);return[x,[0,p],g,u,c]}let f=!0,m=0,d=new Array(l).fill(0);for(let x=0;x<a;++x){let g=e[x*p];if(g<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(x,g));if(g>=l)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(x,g,l));++d[g],f=f&&g>=m,m=g}let h=!0;for(let x=0;x<l;++x){let g=d[x]===0;u[x]=g,h=h&&!g,d[x]=Math.max(d[x],1),x>0&&(d[x]+=d[x-1])}if(h&&f){let x=e,g=n;for(let y=0;y<a;++y)c[y]=y;return[x,[a,p],g,u,c]}else{let x=d[l-1],g=w.getArrayFromDType(r,x*p),y=w.getArrayFromDType(o,x),b=new Array(l).fill(0);for(let v=0;v<a;++v){let C=e[v*p],S=b[C],k=(C===0?0:d[C-1])+S;b[C]++;for(let I=0;I<p;++I)g[k*p+I]=e[v*p+I];y[k]=n[v],c[v]=k}for(let v=0;v<l;++v)if(b[v]===0){let S=v===0?0:d[v-1];g[S*p+0]=v;for(let k=1;k<p;++k)g[S*p+k]=0;y[S]=i}return[g,[x,p],y,u,c]}}function NC(e,t,r,n,o){let s=w.sizeFromShape(n),i=t[0],a=o.length,l=[],u=1,c=-1;for(let x=0;x<a;++x){let g=o[x];if(g===-1){if(c!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,x));c=x,l.push(1)}else{if(g<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(x,g));u*=g,l.push(g)}}if(c!==-1){if(u<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let x=Math.trunc(s/u);if(u*x!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(n,l));l[c]=x}if(w.sizeFromShape(l)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(n,l));let f=n.length,m=[];if(f>0){m[f-1]=1;for(let x=f-2;x>=0;--x)m[x]=m[x+1]*n[x+1]}let d=[];if(a>0){d[a-1]=1;for(let x=a-2;x>=0;--x)d[x]=d[x+1]*l[x+1]}let h=w.getArrayFromDType(r,i*a);for(let x=0;x<i;++x){let g=0;for(let y=0;y<f;++y)g+=e[x*f+y]*m[y];for(let y=0;y<a;++y)h[x*a+y]=Math.trunc(g/d[y]),g%=d[y]}return[h,[i,a],l]}function lh(e,t,r,n,o,s=!1,i=0){let a=n.length,l=[t[0],e.length/t[0]],u=l[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=t.slice();f[0]=p;let m=f.reduce((b,v)=>b*v,1),d=w.getArrayFromDType(r,m);if(a===0)return p>0&&d.fill(i),[d,f];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,x=1,g=0,y=o[h];for(;;){let b=0;if(x<a){if(b=o[x],y===b){++x;continue}if(y>=b)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,p));y>g&&d.fill(i,g*u,y*u);for(let v=h;v<x;++v){let C=n[v];if(C<0||C>=l[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,n[v],l[0]));for(let S=0;S<u;S++)d[y*u+S]+=e[C*u+S]}if(s)for(let v=0;v<u;v++)d[y*u+v]/=x-h;if(h=x,++x,g=y+1,y=b,x>a)break}return g<p&&d.fill(i,g*u,p*u),[d,f]}var wV=Dn(e=>Math.sqrt(e)),Elt=Rt(ja,e=>Math.sqrt(e)),CV={kernelName:ja,backendName:"cpu",kernelFunc:Elt};var A2=Xt((e,t)=>{let r=e-t;return r*r}),_lt=Jt(Ka,A2),SV={kernelName:Ka,backendName:"cpu",kernelFunc:_lt};function IC(e,t,r,n){let o=Ct(e,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*r[l]+n[l];o.set(t.get(...a),...i)}return o}var D2=class{constructor(t,r,n,o,s,i){this.separator=w.encodeString(t),this.nGramWidths=r,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,r){let n=this.getPadWidth(r);return Math.max(0,t+2*n-r+1)}createNGrams(t,r,n,o,s,i){for(let a=0;a<s;++a){let l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),p=i-(u+c),f=r+(u>0?0:a-l),m=0;m+=u*this.leftPad.length;for(let y=0;y<p;++y)m+=t[f+y].length;m+=c*this.rightPad.length;let d=u+c+p-1;m+=d*this.separator.length,n[o+a]=new Uint8Array(m);let h=n[o+a],x=0,g=y=>y.forEach(b=>h[x++]=b);for(let y=0;y<u;++y)g(this.leftPad),g(this.separator);for(let y=0;y<p-1;++y)g(t[f+y]),g(this.separator);if(p>0){g(t[f+p-1]);for(let y=0;y<c;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<c-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(t,r){let n=t.length,o=r.length;if(o>0){let l=r[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<o;++u){let c=r[u]>=l;if(c=c&&r[u]<=n,!c)throw new Error(`Invalid split value ${r[u]}, must be in [${l}, ${n}]`);l=r[u]}if(l!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${l}`)}let s=o-1,i=w.getArrayFromDType("int32",o);if(n===0||o===0){let l=new Array(n);for(let u=0;u<=s;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){let u=r[l]-r[l-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}let a=new Array(i[s]);for(let l=0;l<s;++l){let u=r[l],c=i[l];if(this.nGramWidths.forEach(p=>{let f=r[l+1]-r[l],m=this.getNumNGrams(f,p);this.createNGrams(t,u,a,c,m,p),c+=m}),this.preserveShort&&c===i[l]){let p=r[l+1]-r[l];if(p===0)continue;let f=p+2*this.padWidth,m=1;this.createNGrams(t,u,a,c,m,f)}}return[a,i]}};function EC(e,t,r,n,o,s,i,a){return new D2(r,n,o,s,i,a).compute(e,t)}function Alt(e,t,r,n){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)n.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let a=e.subarray(0,i);(!r||a.length!==0)&&n.push(a),e=e.subarray(i+1),i=e.indexOf(s)}(!r||e.length!==0)&&n.push(e);return}let o=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(o,s);(!r||i.length!==0)&&n.push(i),o=s+1}}function _C(e,t,r){let n=e.length,o=[],s=0,i=0,a=new Array(n);for(let f=0;f<n;++f){let m=o.length;Alt(e[f],t,r,o);let d=o.length-m;a[f]=d,s+=d,i=Math.max(i,d)}let l=w.getArrayFromDType("int32",s*2),u=new Array(s),c=[n,i],p=0;for(let f=0;f<n;++f)for(let m=0;m<a[f];++m)l[p*2]=f,l[p*2+1]=m,u[p]=o[p],++p;return[l,u,c]}function AC(e,t){let r=w.getArrayFromDType("int32",e.length);for(let n=0;n<e.length;++n)r[n]=w.fingerPrint64(e[n]).modulo(t).getLowBitsUnsigned();return r}var R2=Xt((e,t)=>e-t),Dlt=oh((e,t,r,n)=>({real:e-r,imag:t-n})),ub=Jt(Xa,R2,Dlt),kV={kernelName:Xa,backendName:"cpu",kernelFunc:ub};function DC(e,t){let r=new Array(e.rank);for(let o=0;o<r.length;o++)r[o]=e.shape[o]*t[o];let n=Ct(r,e.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let a=e.locToIndex(i);n.values[o]=e.values[a]}return n}var cb=(e,t)=>{let r=t.value-e.value;return r===0?e.index-t.index:r};function TV(e,t,r=0,n=e.length-1){for(;n>r;){if(n-r>600){let a=n-r+1,l=t-r+1,u=Math.log(a),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),f=Math.max(r,Math.floor(t-l*c/a+p)),m=Math.min(n,Math.floor(t+(a-l)*c/a+p));TV(e,t,f,m)}let o=e[t],s=r,i=n;for(w.swap(e,r,t),cb(e[n],o)>0&&w.swap(e,r,n);s<i;){for(w.swap(e,s,i),s++,i--;cb(e[s],o)<0;)s=s+1;for(;cb(e[i],o)>0;)i=i-1}cb(e[r],o)===0?w.swap(e,r,i):(i=i+1,w.swap(e,i,n)),i<=t&&(r=i+1),t<=i&&(n=i-1)}}function RC(e,t,r,n,o){let s=t[t.length-1],[i,a]=[e.length/s,s],l=w.getTypedArrayFromDType(r,i*n),u=w.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let f=p*a,m=e.subarray(f,f+a),d=new Array(m.length);m.forEach((y,b)=>d[b]={value:y,index:b}),n<d.length&&(TV(d,n),d=d.slice(0,n)),o&&d.sort(cb);let h=p*n,x=l.subarray(h,h+n),g=u.subarray(h,h+n);for(let y=0;y<n;y++)x[y]=d[y].value,g[y]=d[y].index}let c=t.slice();return c[c.length-1]=n,[Ct(c,r,l),Ct(c,"int32",u)]}function $C(e,t,r,n){let o=w.parseAxisParam(t,r)[0],s=[1,r[0],1];for(let d=0;d<o;d++)s[0]*=r[d];s[1]=r[o];for(let d=o+1;d<r.length;d++)s[2]*=r[d];let i={},a=new Int32Array(r[o]),l=new ce(s,n,e),u=[],c=s[0]===1&&s[2]===1;for(let d=0;d<r[o];d++){let h;if(c)h=e[d].toString();else{let x=[];for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)x.push(l.get(g,d,y));h=x.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let x=Object.keys(i).length;i[h]=x,a[d]=x,u.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let f=new ce(p,n);u.forEach((d,h)=>{for(let x=0;x<s[0];x++)for(let g=0;g<s[2];g++)f.set(l.get(x,d,g),x,h,g)});let m=r.slice();return m[o]=p[1],{outputValues:f.values,outputShape:m,indices:a}}zw("cpu",()=>new Qp,1);var O2=Rt(ba,e=>e>=0?e:Math.exp(e)-1),NV={kernelName:ba,backendName:"cpu",kernelFunc:O2};function F2(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{alpha:s}=n;J([o],"leakyRelu");let i=w.sizeFromShape(o.shape),a=r.data.get(o.dataId).values,l=w.getTypedArrayFromDType("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?s*a[u]:a[u];return r.makeTensorInfo(o.shape,"float32",l)}var IV={kernelName:vu,backendName:"cpu",kernelFunc:F2};var Rlt=Xt((e,t)=>e<0?t*e:e);function P2(e){let{inputs:t,backend:r}=e,{x:n,alpha:o}=t;J([n,o],"prelu");let s=r.data.get(n.dataId).values,i=r.data.get(o.dataId).values,[a,l]=Rlt(n.shape,o.shape,s,i,"float32");return r.makeTensorInfo(l,"float32",a)}var EV={kernelName:$u,backendName:"cpu",kernelFunc:P2};var L2=Rt(La,e=>Math.max(0,e)),_V={kernelName:La,backendName:"cpu",kernelFunc:L2};var M2=Rt(Ma,e=>Math.min(Math.max(0,e),6)),AV={kernelName:Ma,backendName:"cpu",kernelFunc:M2};function Jp(e,t,r,n,o){if(r==="linear")return rn({inputs:{x:t},backend:e});if(r==="relu")return L2({inputs:{x:t},backend:e});if(r==="elu")return O2({inputs:{x:t},backend:e});if(r==="relu6")return M2({inputs:{x:t},backend:e});if(r==="prelu")return P2({inputs:{x:t,alpha:n},backend:e});if(r==="leakyrelu")return F2({inputs:{x:t},backend:e,attrs:{alpha:o}});if(r==="sigmoid")return E2({inputs:{x:t},backend:e});throw new Error(`Activation ${r} has not been implemented for the CPU backend.`)}function jt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{shape:s}=n,i=w.sizeFromShape(o.shape),a=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(a);w.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),r.incRef(o.dataId);let u=r.data.get(o.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var DV={kernelName:Fu,backendName:"cpu",kernelFunc:jt};function z2(e){let{inputs:t,backend:r,attrs:n}=e,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;J([o,s],"matMul");let l=o.shape.length,u=s.shape.length,c=i?o.shape[l-2]:o.shape[l-1],p=a?s.shape[u-1]:s.shape[u-2],f=i?o.shape[l-1]:o.shape[l-2],m=a?s.shape[u-2]:s.shape[u-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),x=w.sizeFromShape(d),g=w.sizeFromShape(h),b=uo.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,m]);w.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[x,c,f]:[x,f,c],C=a?[g,m,p]:[g,p,m],S=jt({inputs:{x:o},backend:r,attrs:{shape:v}}),k=jt({inputs:{x:s},backend:r,attrs:{shape:C}}),I=i?S.shape[1]:S.shape[2],D=i?S.shape[2]:S.shape[1],R=a?k.shape[1]:k.shape[2],M=Math.max(x,g),U=r.data.get(S.dataId).values,j=r.data.get(k.dataId).values,K=w.computeStrides(S.shape),W=w.computeStrides(k.shape),[q,X,Q]=i?[K[0],1,K[1]]:[K[0],K[1],1],[Y,nt,rt]=a?[1,W[1],W[0]]:[W[1],1,W[0]],at=D*R,lt=Ct([M,D,R],S.dtype),ut=lt.values,it=r.blockSize;for(let dt=0;dt<M;dt++)for(let wt=0;wt<D;wt+=it)for(let bt=0;bt<R;bt+=it)for(let St=0;St<I;St+=it){let Wt=Math.min(wt+it,D),Ht=Math.min(bt+it,R),$=Math.min(St+it,I);for(let G=wt;G<Wt;G++)for(let P=bt;P<Ht;P++){let ot=0;for(let ct=St;ct<$;ct++){let pt=Math.min(dt,x-1)*q,Ft=Math.min(dt,g-1)*rt,ne=U[pt+G*X+ct*Q],Bt=j[ct*Y+P*nt+Ft];ot+=ne*Bt}ut[dt*at+(G*R+P)]+=ot}}return r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(k),r.makeTensorInfo(b,lt.dtype,lt.values)}var RV={kernelName:au,backendName:"cpu",kernelFunc:z2};function $lt(e){let{inputs:t,backend:r,attrs:n}=e,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=n,f,m,d,h=[];f=z2({inputs:{a:o,b:s},attrs:{transposeA:l,transposeB:u},backend:r}),i&&(m=Oi({inputs:{a:f,b:i},backend:r}),h.push(f),f=m),c&&(d=Jp(r,f,c,a,p),h.push(f),f=d);for(let g of h)r.disposeIntermediateTensorInfo(g);return f}var $V={kernelName:cp,backendName:"cpu",kernelFunc:$lt};var Olt=Rt(aa,e=>Math.acos(e)),OV={kernelName:aa,backendName:"cpu",kernelFunc:Olt};var Flt=Rt(la,e=>Math.acosh(e)),FV={kernelName:la,backendName:"cpu",kernelFunc:Flt};function Plt(e){let{inputs:t,backend:r}=e,n=t;J(t,"addN");let o=n.map(a=>r.data.get(a.dataId).values),s=Ct(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let l=o[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return r.makeTensorInfo(s.shape,s.dtype,s.values)}var PV={kernelName:hm,backendName:"cpu",kernelFunc:Plt};function Llt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;J(o,"all");let a=w.parseAxisParam(s,o.shape),l=a,u=T.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Pe({inputs:{x:o},backend:r,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,o.shape.length)),T.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,f]=T.computeOutAndReduceShapes(c.shape,l),m=w.sizeFromShape(f),d=w.makeZerosTypedArray(w.sizeFromShape(p),c.dtype),h=r.data.get(c.dataId).values;for(let g=0;g<d.length;++g){let y=g*m,b=h[y];for(let v=0;v<m;++v){let C=h[y+v];b=b&&C}d[g]=b}u!=null&&r.disposeIntermediateTensorInfo(c);let x=r.makeTensorInfo(p,c.dtype,d);if(i){let g=T.expandShapeToKeepDim(p,a),y=jt({inputs:{x},backend:r,attrs:{shape:g}});return r.disposeIntermediateTensorInfo(x),y}return x}var LV={kernelName:gm,backendName:"cpu",kernelFunc:Llt};function Mlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;J(o,"any");let a=w.parseAxisParam(s,o.shape),l=a,u=T.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Pe({inputs:{x:o},backend:r,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,o.shape.length)),T.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,f]=T.computeOutAndReduceShapes(c.shape,l),m=w.sizeFromShape(f),d=w.makeZerosTypedArray(w.sizeFromShape(p),c.dtype),h=r.data.get(c.dataId).values;for(let g=0;g<d.length;++g){let y=g*m,b=h[y];for(let v=0;v<m;++v){let C=h[y+v];b=b||C}d[g]=b}u!=null&&r.disposeIntermediateTensorInfo(c);let x=r.makeTensorInfo(p,c.dtype,d);if(i){let g=T.expandShapeToKeepDim(p,a),y=jt({inputs:{x},backend:r,attrs:{shape:g}});return r.disposeIntermediateTensorInfo(x),y}return x}var MV={kernelName:xm,backendName:"cpu",kernelFunc:Mlt};function zlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s}=n;J(o,"argMax");let i=w.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Pe({inputs:{x:o},backend:r,attrs:{perm:a}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,p]=T.computeOutAndReduceShapes(l.shape,i),f=w.sizeFromShape(c),m=w.makeZerosTypedArray(f,"int32"),d=w.sizeFromShape(p),h=r.data.get(l.dataId).values;for(let x=0;x<m.length;++x){let g=x*d,y=h[g],b=0;for(let v=0;v<d;++v){let C=h[g+v];C>y&&(y=C,b=v)}m[x]=b}return u.forEach(x=>r.disposeIntermediateTensorInfo(x)),r.makeTensorInfo(c,"int32",m)}var zV={kernelName:nu,backendName:"cpu",kernelFunc:zlt};function Blt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s}=n;J(o,"argMin");let i=w.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Pe({inputs:{x:o},backend:r,attrs:{perm:a}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,p]=T.computeOutAndReduceShapes(l.shape,i),f=w.sizeFromShape(c),m=w.makeZerosTypedArray(f,"int32"),d=w.sizeFromShape(p),h=r.data.get(l.dataId).values;for(let x=0;x<m.length;++x){let g=x*d,y=h[g],b=0;for(let v=0;v<d;++v){let C=h[g+v];C<y&&(y=C,b=v)}m[x]=b}return u.forEach(x=>r.disposeIntermediateTensorInfo(x)),r.makeTensorInfo(c,"int32",m)}var BV={kernelName:ou,backendName:"cpu",kernelFunc:Blt};var Vlt=Rt(ua,e=>Math.asin(e)),VV={kernelName:ua,backendName:"cpu",kernelFunc:Vlt};var Wlt=Rt(ca,e=>Math.asinh(e)),WV={kernelName:ca,backendName:"cpu",kernelFunc:Wlt};var Glt=Rt(pa,e=>Math.atan(e)),GV={kernelName:pa,backendName:"cpu",kernelFunc:Glt};var Ult=Xt((e,t)=>Math.atan2(e,t)),Hlt=Jt(ma,Ult),UV={kernelName:ma,backendName:"cpu",kernelFunc:Hlt};var qlt=Rt(fa,e=>Math.atanh(e)),HV={kernelName:fa,backendName:"cpu",kernelFunc:qlt};function uh(e,t,r,n,o,s){let i=o.strideHeight,a=o.strideWidth,l=o.dilationHeight,u=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,f=o.padInfo.top,m=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ct(o.outShape,r),x=h.values,g=o.outShape[1]*o.outShape[2]*o.outShape[3],y=o.outShape[2]*o.outShape[3],b=o.outShape[3];for(let v=0;v<o.batchSize;++v){let C=v*g,S=v*n[0];for(let k=0;k<o.inChannels;++k)for(let I=0;I<o.outHeight;++I){let D=I*i-f,R=Math.max(0,D),M=Math.min(o.inHeight,c+D),U=C+I*y;for(let j=0;j<o.outWidth;++j){let K=j*a-m,W=Math.max(0,K),q=Math.min(o.inWidth,p+K),X=d,Q=0,Y=0;for(let rt=R;rt<M;rt+=l){let at=S+rt*n[1];for(let lt=W;lt<q;lt+=u){let ut=at+lt*n[2],it=e[ut+k];s==="max"&&it>X?X=it:s==="avg"&&(Q+=it,Y++)}if(isNaN(X))break}let nt=U+j*b+k;x[nt]=s==="avg"?Q/Y:X}}}return h}function OC(e,t,r,n,o=!1,s=!1){let i=Ct(n.outShape,"int32"),a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=n.padInfo.top,d=n.padInfo.left,h=Ct(t,r,e);for(let x=0;x<n.batchSize;++x)for(let g=0;g<n.inChannels;++g)for(let y=0;y<n.outHeight;++y){let b=y*a-m,v=b;for(;v<0;)v+=u;let C=Math.min(n.inHeight,p+b);for(let S=0;S<n.outWidth;++S){let k=S*l-d,I=k;for(;I<0;)I+=c;let D=Math.min(n.inWidth,f+k),R=Number.NEGATIVE_INFINITY,M=-1;for(let U=v;U<C;U+=u){let j=U-b;for(let K=I;K<D;K+=c){let W=K-k,q=h.get(x,U,K,g);q>R&&(R=q,o?M=s?((x*n.inHeight+U)*n.inWidth+K)*n.inChannels+g:(U*n.inWidth+K)*n.inChannels+g:M=j*f+W)}}i.set(M,x,y,S,g)}}return i}function FC(e,t,r,n,o,s){let i=o.strideDepth,a=o.strideHeight,l=o.strideWidth,u=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,f=o.effectiveFilterDepth,m=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,x=o.padInfo.top,g=o.padInfo.left,y=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Ct(o.outShape,r),v=b.values,C=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],S=o.outShape[2]*o.outShape[3]*o.outShape[4],k=o.outShape[3]*o.outShape[4],I=o.outShape[4];for(let D=0;D<o.batchSize;++D){let R=D*C,M=D*n[0];for(let U=0;U<o.inChannels;++U)for(let j=0;j<o.outDepth;++j){let K=j*i-h,W=K;for(;W<0;)W+=u;let q=Math.min(o.inDepth,f+K),X=R+j*S;for(let Q=0;Q<o.outHeight;++Q){let Y=Q*a-x,nt=Y;for(;nt<0;)nt+=c;let rt=Math.min(o.inHeight,m+Y),at=X+Q*k;for(let lt=0;lt<o.outWidth;++lt){let ut=lt*l-g,it=ut;for(;it<0;)it+=p;let dt=Math.min(o.inWidth,d+ut),wt=at+lt*I,bt=y,St=0,Wt=0;for(let $=W;$<q;$+=u){let G=M+$*n[1];for(let P=nt;P<rt;P+=c){let ot=G+P*n[2];for(let ct=it;ct<dt;ct+=p){let pt=ot+ct*n[3],Ft=e[pt+U];if(s==="max"&&Ft>bt?bt=Ft:s==="avg"&&(St+=Ft,Wt++),isNaN(bt))break}if(isNaN(bt))break}if(isNaN(bt))break}let Ht=wt+U;v[Ht]=s==="avg"?St/Wt:bt}}}}return b}function qV(e,t){let r=Ct(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=t.padInfo.front,m=t.padInfo.top,d=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let x=0;x<t.inChannels;++x)for(let g=0;g<t.outDepth;++g){let y=g*n-f,b=y;for(;b<0;)b+=i;let v=Math.min(t.inDepth,u+y);for(let C=0;C<t.outHeight;++C){let S=C*o-m,k=S;for(;k<0;)k+=a;let I=Math.min(t.inHeight,c+S);for(let D=0;D<t.outWidth;++D){let R=D*s-d,M=R;for(;M<0;)M+=l;let U=Math.min(t.inWidth,p+R),j=Number.NEGATIVE_INFINITY,K=-1;for(let W=b;W<v;W+=i){let q=W-y;for(let X=k;X<I;X+=a){let Q=X-S;for(let Y=M;Y<U;Y+=l){let nt=Y-R,rt=e.get(h,W,X,Y,x);rt>=j&&(j=rt,K=q*c*p+Q*c+nt)}}}r.set(K,h,g,C,D,x)}}}return r}function jlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t;J(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=n,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=T.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))p=rn({inputs:{x:o},backend:r});else{let f=r.data.get(o.dataId).values,m=w.computeStrides(o.shape),d=uh(f,o.shape,o.dtype,m,c,"avg");p=r.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var jV={kernelName:su,backendName:"cpu",kernelFunc:jlt};function Klt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=n;J(o,"avgPool3d");let c=T.computePool3DInfo(o.shape,s,i,1,a,l,u),p=r.data.get(o.dataId).values,f=FC(p,o.shape,o.dtype,w.computeStrides(o.shape),c,"avg");return r.makeTensorInfo(f.shape,"float32",f.values)}var KV={kernelName:iu,backendName:"cpu",kernelFunc:Klt};function Xlt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=n;J([o,s],"avgPool3DGrad");let c=T.computePool3DInfo(s.shape,i,a,1,l,u),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,d=c.filterDepth,h=c.filterHeight,x=c.filterWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,C=c.effectiveFilterHeight,S=c.effectiveFilterWidth,k=v-1-c.padInfo.front,I=S-1-c.padInfo.left,D=C-1-c.padInfo.top,R=Ct(s.shape,"float32"),M=1/(d*h*x),U=r.bufferSync(o);for(let j=0;j<c.batchSize;++j)for(let K=0;K<c.inChannels;++K)for(let W=0;W<c.inDepth;++W)for(let q=0;q<c.inHeight;++q)for(let X=0;X<c.inWidth;++X){let Q=W-k,Y=q-D,nt=X-I,rt=0;for(let at=0;at<v;at+=g){let lt=(Q+at)/p;if(!(lt<0||lt>=c.outDepth||Math.floor(lt)!==lt))for(let ut=0;ut<C;ut+=y){let it=(Y+ut)/f;if(!(it<0||it>=c.outHeight||Math.floor(it)!==it))for(let dt=0;dt<S;dt+=b){let wt=(nt+dt)/m;if(wt<0||wt>=c.outWidth||Math.floor(wt)!==wt)continue;let bt=U.get(j,lt,it,wt,K);rt+=bt}}}R.set(rt*M,j,W,q,X,K)}return r.makeTensorInfo(R.shape,R.dtype,R.values)}var XV={kernelName:bm,backendName:"cpu",kernelFunc:Xlt};function Ylt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,i=s;J([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=n,c=T.computePool2DInfo(i.shape,a,l,1,u),p=c.strideHeight,f=c.strideWidth,m=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,x=c.dilationWidth,g=c.effectiveFilterHeight,y=c.effectiveFilterWidth,b=y-1-c.padInfo.left,v=g-1-c.padInfo.top,C=Ct(i.shape,"float32"),S=1/(m*d),k=r.data.get(o.dataId).values,I=Ct(o.shape,"float32",k);for(let D=0;D<c.batchSize;++D)for(let R=0;R<c.inChannels;++R)for(let M=0;M<c.inHeight;++M)for(let U=0;U<c.inWidth;++U){let j=M-v,K=U-b,W=0;for(let q=0;q<g;q+=h){let X=(j+q)/p;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let Q=0;Q<y;Q+=x){let Y=(K+Q)/f;if(Y<0||Y>=c.outWidth||Math.floor(Y)!==Y)continue;let nt=I.get(D,X,Y,R);W+=nt}}C.set(W*S,D,M,U,R)}return r.makeTensorInfo(C.shape,C.dtype,C.values)}var YV={kernelName:ym,backendName:"cpu",kernelFunc:Ylt};function Qlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,scale:s,offset:i,mean:a,variance:l}=t;w.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),J([o,a,l,s,i],"batchNorm");let{varianceEpsilon:u}=n;u==null&&(u=.001);let c=r.data.get(o.dataId).values,p=r.data.get(a.dataId).values,f=r.data.get(l.dataId).values,m=s?r.data.get(s.dataId).values:new Float32Array([1]),d=i?r.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),x=d.length,g=m.length,y=f.length,b=p.length,v=0,C=0,S=0,k=0;for(let I=0;I<c.length;++I)h[I]=d[v++]+(c[I]-p[C++])*m[S++]/Math.sqrt(f[k++]+u),v>=x&&(v=0),C>=b&&(C=0),S>=g&&(S=0),k>=y&&(k=0);return r.makeTensorInfo(o.shape,o.dtype,h)}var QV={kernelName:yu,backendName:"cpu",kernelFunc:Qlt};function Zlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockShape:s,crops:i}=n;J([o],"batchToSpaceND");let a=s.reduce((g,y)=>g*y),l=T.getReshaped(o.shape,s,a),u=T.getPermuted(l.length,s.length),c=T.getReshapedPermuted(o.shape,s,a),p=T.getSliceBeginCoords(i,s.length),f=T.getSliceSize(c,i,s.length),m=jt({inputs:{x:o},backend:r,attrs:{shape:l}}),d=Pe({inputs:{x:m},backend:r,attrs:{perm:u}}),h=jt({inputs:{x:d},backend:r,attrs:{shape:c}}),x=ys({inputs:{x:h},backend:r,attrs:{begin:p,size:f}});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),x}var ZV={kernelName:lu,backendName:"cpu",kernelFunc:Zlt};function Jlt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,weights:s}=t,{size:i}=n,a=r.data.get(o.dataId).values,l=r.data.get(s.dataId).values,u=sh(a,l,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,u)}var JV={kernelName:vm,backendName:"cpu",kernelFunc:Jlt};function tut(e){let{inputs:t,backend:r}=e,{s0:n,s1:o}=t,s=r.data.get(n.dataId).values,i=r.data.get(o.dataId).values,a=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return r.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var tW={kernelName:rw,backendName:"cpu",kernelFunc:tut};var eut=Rt(ha,(e,t)=>{let r=t;return e>r.clipValueMax?r.clipValueMax:e<r.clipValueMin?r.clipValueMin:e}),eW={kernelName:ha,backendName:"cpu",kernelFunc:eut};var rut=e=>{let{x:t}=e.inputs,r=e.backend,n=new Float32Array(w.sizeFromShape(t.shape)),o=r.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=r.data.get(s.dataId).values,l=r.data.get(i.dataId).values;for(let u=0;u<a.length;u++){let c=a[u],p=l[u];n[u]=Math.hypot(c,p)}return r.makeOutput(n,t.shape,"float32")},rW={kernelName:uu,backendName:"cpu",kernelFunc:rut};function Fi(e){let{inputs:t,backend:r}=e,{input:n}=t,o=r.data.get(n.dataId).complexTensorInfos.imag,s=r.data.get(o.dataId).values;return r.makeTensorInfo(o.shape,o.dtype,s)}var nW={kernelName:Lm,backendName:"cpu",kernelFunc:Fi};function fc(e){let{inputs:t,backend:r,attrs:n}=e,{axis:o}=n,s=w.parseAxisParam(o,t[0].shape)[0],i=t.map(h=>h.shape);T.assertParamsConsistent(i,s);let a=T.computeOutShape(t.map(h=>h.shape),s);if(w.sizeFromShape(a)===0)return r.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(h=>w.sizeFromShape(h.shape)>0);if(l.length===1)return rn({inputs:{x:l[0]},backend:r});if(l[0].dtype==="complex64"){let h=l.map(v=>ds({inputs:{input:v},backend:r})),x=l.map(v=>Fi({inputs:{input:v},backend:r})),g=fc({inputs:h,backend:r,attrs:{axis:s}}),y=fc({inputs:x,backend:r,attrs:{axis:s}}),b=Sr({inputs:{real:g,imag:y},backend:r});return h.forEach(v=>r.disposeIntermediateTensorInfo(v)),x.forEach(v=>r.disposeIntermediateTensorInfo(v)),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),b}let u=l.map(h=>{let g=[-1,w.sizeFromShape(h.shape.slice(s))];return jt({inputs:{x:h},backend:r,attrs:{shape:g}})}),c=u.map(h=>({vals:r.data.get(h.dataId).values,shape:h.shape}));a=T.computeOutShape(u.map(h=>h.shape),1);let p=u[0].shape[0]===1,f=gC(c,a,t[0].dtype,p),m=T.computeOutShape(l.map(h=>h.shape),s),d=r.makeTensorInfo(m,t[0].dtype,f);return u.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}var oW={kernelName:cu,backendName:"cpu",kernelFunc:fc};function B2(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=n;J([o,s],"conv2d");let p=T.convertConv2DDataFormat(l),f=T.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),m=f.filterHeight,d=f.filterWidth,h=f.dilationHeight,x=f.dilationWidth,g=f.padInfo.left,y=f.padInfo.top,b=f.dataFormat==="channelsLast",v=new ce(f.outShape,o.dtype),C=w.computeStrides(o.shape),S=w.computeStrides(s.shape),k=C[0],I=b?C[1]:C[2],D=b?C[2]:1,R=b?1:C[1],M=v.strides[0],U=b?v.strides[1]:v.strides[2],j=b?v.strides[2]:1,K=b?1:v.strides[1],W=r.data.get(o.dataId).values,q=r.data.get(s.dataId).values,X=v.values;for(let Q=0;Q<f.batchSize;++Q){let Y=Q*k,nt=Q*M;for(let rt=0;rt<f.outHeight;++rt){let at=nt+rt*U,lt=rt*f.strideHeight-y;for(let ut=0;ut<m;++ut){let it=lt+ut*h;if(it<0||it>=f.inHeight)continue;let dt=ut*S[0],wt=Y+it*I;for(let bt=0;bt<f.outWidth;++bt){let St=at+bt*j,Wt=bt*f.strideWidth-g;for(let Ht=0;Ht<d;++Ht){let $=Wt+Ht*x;if($<0||$>=f.inWidth)continue;let G=dt+Ht*S[1],P=wt+$*D,ot=G;for(let ct=0;ct<f.inChannels;++ct){let pt=W[P+ct*R];for(let Ft=0;Ft<f.outChannels;++Ft)X[St+Ft*K]+=pt*q[ot+Ft];ot+=f.outChannels}}}}}}return r.makeTensorInfo(v.shape,v.dtype,X)}var sW={kernelName:pu,backendName:"cpu",kernelFunc:B2};function nut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=n;J([o,s],"conv2dBackpropFilter");let p=T.convertConv2DDataFormat(l),f=T.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),{strideHeight:m,strideWidth:d,filterHeight:h,filterWidth:x}=f,g=f.dataFormat==="channelsLast",y=new ce(f.filterShape,"float32"),b=f.padInfo.left,v=f.padInfo.top,C=r.data.get(o.dataId).values,S=r.data.get(s.dataId).values,k=new ce(o.shape,o.dtype,C),I=new ce(s.shape,s.dtype,S);for(let D=0;D<h;++D){let R=Math.max(0,Math.ceil((v-D)/m)),M=Math.min(f.outHeight,(f.inHeight+v-D)/m);for(let U=0;U<x;++U){let j=Math.max(0,Math.ceil((b-U)/d)),K=Math.min(f.outWidth,(f.inWidth+b-U)/d);for(let W=0;W<f.inChannels;++W)for(let q=0;q<f.outChannels;++q){let X=0;for(let Q=0;Q<f.batchSize;++Q)for(let Y=R;Y<M;++Y){let nt=D+Y*m-v;for(let rt=j;rt<K;++rt){let at=U+rt*d-b;g?X+=k.get(Q,nt,at,W)*I.get(Q,Y,rt,q):X+=k.get(Q,W,nt,at)*I.get(Q,q,Y,rt)}}y.set(X,D,U,W,q)}}}return r.makeTensorInfo(y.shape,y.dtype,y.values)}var iW={kernelName:Cm,backendName:"cpu",kernelFunc:nut};function out(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=n;J([o,s],"conv2dBackpropInput");let p=w.computeStrides(s.shape),f=w.computeStrides(o.shape),m=T.convertConv2DDataFormat(u),d=T.computeConv2DInfo(i,s.shape,a,1,l,c,!1,m),h=new ce(d.inShape,"float32"),x=h.values,g=r.data.get(o.dataId).values,y=r.data.get(s.dataId).values,[b,v,C]=p,{batchSize:S,filterHeight:k,filterWidth:I,inChannels:D,inHeight:R,inWidth:M,outChannels:U,outHeight:j,outWidth:K,strideHeight:W,strideWidth:q}=d;m=d.dataFormat;let X=k-1-d.padInfo.top,Q=I-1-d.padInfo.left,Y=m==="channelsLast",nt=h.strides[0],rt=Y?h.strides[1]:h.strides[2],at=Y?h.strides[2]:1,lt=Y?1:h.strides[1],ut=f[0],it=Y?f[1]:f[2],dt=Y?f[2]:1,wt=Y?1:f[1];for(let bt=0;bt<S;++bt)for(let St=0;St<D;++St)for(let Wt=0;Wt<R;++Wt){let Ht=Wt-X,$=Math.max(0,Math.ceil(Ht/W)),G=Math.min(j,(k+Ht)/W);for(let P=0;P<M;++P){let ot=P-Q,ct=Math.max(0,Math.ceil(ot/q)),pt=Math.min(K,(I+ot)/q),Ft=0;for(let Bt=$;Bt<G;++Bt){let Me=Bt*W-Ht;for(let fr=ct;fr<pt;++fr){let mr=fr*q-ot,Ln=ut*bt+it*Bt+dt*fr,Uo=b*(k-1-Me)+v*(I-1-mr)+C*St;for(let Ds=0;Ds<U;++Ds){let Rs=g[Ln+wt*Ds],$s=y[Uo+Ds];Ft+=Rs*$s}}}let ne=nt*bt+rt*Wt+at*P+lt*St;x[ne]=Ft}}return r.makeTensorInfo(h.shape,h.dtype,h.values)}var aW={kernelName:fu,backendName:"cpu",kernelFunc:out};function sut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=n;J([o,s],"conv3d");let u=T.computeConv3DInfo(o.shape,s.shape,i,l,a),{filterDepth:c,filterHeight:p,filterWidth:f,dilationDepth:m,dilationHeight:d,dilationWidth:h,padInfo:x}=u,g=x.front,y=x.left,b=x.top,v=new ce(u.outShape,o.dtype),C=r.data.get(o.dataId).values,S=r.data.get(s.dataId).values,k=v.values,I=w.computeStrides(o.shape),D=w.computeStrides(s.shape);for(let R=0;R<u.batchSize;++R){let M=R*I[0],U=R*v.strides[0];for(let j=0;j<u.outDepth;++j){let K=U+j*v.strides[1],W=j*u.strideDepth-g;for(let q=0;q<c;++q){let X=W+q*m;if(X<0||X>=u.inDepth)continue;let Q=q*D[0],Y=M+X*I[1];for(let nt=0;nt<u.outHeight;++nt){let rt=K+nt*v.strides[2],at=nt*u.strideHeight-b;for(let lt=0;lt<p;++lt){let ut=at+lt*d;if(ut<0||ut>=u.inHeight)continue;let it=Q+lt*D[1],dt=Y+ut*I[2];for(let wt=0;wt<u.outWidth;++wt){let bt=rt+wt*u.outChannels,St=wt*u.strideWidth-y;for(let Wt=0;Wt<f;++Wt){let Ht=St+Wt*h;if(Ht<0||Ht>=u.inWidth)continue;let $=it+Wt*D[2],G=dt+Ht*u.inChannels,P=$;for(let ot=0;ot<u.inChannels;++ot){let ct=C[G+ot];for(let pt=0;pt<u.outChannels;++pt)k[bt+pt]+=ct*S[P+pt];P+=u.outChannels}}}}}}}}return r.makeTensorInfo(v.shape,v.dtype,v.values)}var lW={kernelName:mu,backendName:"cpu",kernelFunc:sut};function iut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:l}=n;J([o,s],"conv3dBackpropFilterV2");let u=w.computeStrides(o.shape),c=w.computeStrides(s.shape),p=T.computeConv3DInfo(o.shape,l,i,1,a),f=p.strideDepth,m=p.strideHeight,d=p.strideWidth,h=p.filterDepth,x=p.filterHeight,g=p.filterWidth,y=new ce(p.filterShape,"float32"),b=y.values,[v,C,S,k]=y.strides,I=r.data.get(s.dataId).values,[D,R,M,U]=c,j=r.data.get(o.dataId).values,[K,W,q,X]=u,Q=p.padInfo.front,Y=p.padInfo.left,nt=p.padInfo.top;for(let rt=0;rt<h;++rt){let at=Math.max(0,Math.ceil((Q-rt)/f)),lt=Math.min(p.outDepth,(p.inDepth+Q-rt)/f),ut=rt*v;for(let it=0;it<x;++it){let dt=Math.max(0,Math.ceil((nt-it)/m)),wt=Math.min(p.outHeight,(p.inHeight+nt-it)/m),bt=it*C+ut;for(let St=0;St<g;++St){let Wt=Math.max(0,Math.ceil((Y-St)/d)),Ht=Math.min(p.outWidth,(p.inWidth+Y-St)/d),$=St*S+bt;for(let G=0;G<p.inChannels;++G){let P=G*k+$;for(let ot=0;ot<p.outChannels;++ot){let ct=0;for(let pt=0;pt<p.batchSize;++pt){let Ft=pt*K,ne=pt*D;for(let Bt=at;Bt<lt;++Bt){let fr=(rt+Bt*f-Q)*W+Ft,mr=Bt*R+ne;for(let Ln=dt;Ln<wt;++Ln){let Ds=(it+Ln*m-nt)*q+fr,Rs=Ln*M+mr;for(let $s=Wt;$s<Ht;++$s){let JT=(St+$s*d-Y)*X+Ds,tN=$s*U+Rs;ct+=j[JT+G]*I[tN+ot]}}}}b[P+ot]=ct}}}}}return r.makeTensorInfo(y.shape,y.dtype,y.values)}var uW={kernelName:Sm,backendName:"cpu",kernelFunc:iut};function aut(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:l}=n;J([o],"conv3dBackpropInputV2");let u=w.computeStrides(o.shape),c=w.computeStrides(s.shape),p=T.computeConv3DInfo(l,s.shape,a,1,i),f=new ce(p.inShape,"float32"),m=f.values,[d,h,x,g]=f.strides,y=r.data.get(o.dataId).values,[b,v,C,S]=u,k=r.data.get(s.dataId).values,[I,D,R,M]=c,{batchSize:U,filterDepth:j,filterHeight:K,filterWidth:W,inChannels:q,inDepth:X,inHeight:Q,inWidth:Y,outChannels:nt,outDepth:rt,outHeight:at,outWidth:lt,strideDepth:ut,strideHeight:it,strideWidth:dt}=p,wt=j-1-p.padInfo.front,bt=K-1-p.padInfo.top,St=W-1-p.padInfo.left;for(let Wt=0;Wt<U;++Wt)for(let Ht=0;Ht<q;++Ht)for(let $=0;$<X;++$){let G=$-wt,P=Math.max(0,Math.ceil(G/ut)),ot=Math.min(rt,(j+G)/ut);for(let ct=0;ct<Q;++ct){let pt=ct-bt,Ft=Math.max(0,Math.ceil(pt/it)),ne=Math.min(at,(K+pt)/it);for(let Bt=0;Bt<Y;++Bt){let Me=Bt-St,fr=Math.max(0,Math.ceil(Me/dt)),mr=Math.min(lt,(W+Me)/dt),Ln=0;for(let Uo=P;Uo<ot;++Uo){let Ds=Uo*ut-G;for(let Rs=Ft;Rs<ne;++Rs){let $s=Rs*it-pt;for(let mg=fr;mg<mr;++mg){let JT=mg*dt-Me,tN=b*Wt+v*Uo+C*Rs+S*mg,YX=I*(j-1-Ds)+D*(K-1-$s)+R*(W-1-JT)+M*Ht;for(let A0=0;A0<nt;++A0){let QX=y[tN+A0],ZX=k[YX+A0];Ln+=QX*ZX}}}}m[d*Wt+h*$+x*ct+g*Bt+Ht]=Ln}}}return r.makeTensorInfo(f.shape,f.dtype,f.values)}var cW={kernelName:km,backendName:"cpu",kernelFunc:aut};var lut=Rt(ga,e=>Math.cos(e)),pW={kernelName:ga,backendName:"cpu",kernelFunc:lut};var uut=Rt(xa,e=>Math.cosh(e)),fW={kernelName:xa,backendName:"cpu",kernelFunc:uut};function cut(e){let{inputs:t,backend:r,attrs:n}=e,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=n,[c,p,f,m]=o.shape,d=s.shape[0],[h,x]=a,g=Ct([d,h,x,m],"float32"),y=r.data.get(s.dataId).values,b=r.data.get(i.dataId).values,v=r.data.get(o.dataId).values,C=w.computeStrides(o.shape),S=w.computeStrides(g.shape);for(let k=0;k<d;k++){let I=k*4,D=y[I],R=y[I+1],M=y[I+2],U=y[I+3],j=b[k];if(j>=c)continue;let K=h>1?(M-D)*(p-1)/(h-1):0,W=x>1?(U-R)*(f-1)/(x-1):0;for(let q=0;q<h;q++){let X=h>1?D*(p-1)+q*K:.5*(D+M)*(p-1);if(X<0||X>p-1){for(let Q=0;Q<x;Q++)for(let Y=0;Y<m;Y++){let nt=Y+Q*S[2]+q*S[1]+k*S[0];g.values[nt]=u}continue}if(l==="bilinear"){let Q=Math.floor(X),Y=Math.ceil(X),nt=X-Q;for(let rt=0;rt<x;rt++){let at=x>1?R*(f-1)+rt*W:.5*(R+U)*(f-1);if(at<0||at>f-1){for(let dt=0;dt<m;dt++){let wt=dt+rt*S[2]+q*S[1]+k*S[0];g.values[wt]=u}continue}let lt=Math.floor(at),ut=Math.ceil(at),it=at-lt;for(let dt=0;dt<m;dt++){let wt=dt+lt*C[2]+Q*C[1]+j*C[0],bt=v[wt];wt=dt+ut*C[2]+Q*C[1]+j*C[0];let St=v[wt];wt=dt+lt*C[2]+Y*C[1]+j*C[0];let Wt=v[wt];wt=dt+ut*C[2]+Y*C[1]+j*C[0];let Ht=v[wt],$=bt+(St-bt)*it,G=Wt+(Ht-Wt)*it;wt=dt+rt*S[2]+q*S[1]+k*S[0],g.values[wt]=$+(G-$)*nt}}}else for(let Q=0;Q<x;++Q){let Y=x>1?R*(f-1)+Q*W:.5*(R+U)*(f-1);if(Y<0||Y>f-1){for(let at=0;at<m;at++){let lt=at+Q*S[2]+q*S[1]+k*S[0];g.values[lt]=u}continue}let nt=Math.round(Y),rt=Math.round(X);for(let at=0;at<m;at++){let lt=at+nt*C[2]+rt*C[1]+j*C[0],ut=at+Q*S[2]+q*S[1]+k*S[0];g.values[ut]=v[lt]}}}}return r.makeTensorInfo(g.shape,g.dtype,g.values)}var mW={kernelName:Nm,backendName:"cpu",kernelFunc:cut};function put(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;J(o,"cumprod");let l=T.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Pe({inputs:{x:o},backend:r,attrs:{perm:l}}));let c=T.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=or(u.dtype,"int32"),f=w.makeOnesTypedArray(w.sizeFromShape(u.shape),p),m=r.data.get(u.dataId).values,d=u.shape[u.shape.length-1],h=a?(g,y)=>g+d-y-1:(g,y)=>g+y;for(let g=0;g<m.length;g+=d)for(let y=0;y<d;y++){let b=h(g,y);if(y===0)f[b]=i?1:m[b];else{let v=h(g,y-1);f[b]=i?m[v]*f[v]:m[b]*f[v]}}let x=r.makeTensorInfo(u.shape,p,f);if(l!=null){let g=T.getUndoAxesPermutation(l),y=Pe({inputs:{x},backend:r,attrs:{perm:g}});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(u),y}return x}var dW={kernelName:Tm,backendName:"cpu",kernelFunc:put};function fut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;J(o,"cumsum");let l=T.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Pe({inputs:{x:o},backend:r,attrs:{perm:l}}));let c=T.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=or(u.dtype,"int32"),f=w.makeZerosTypedArray(w.sizeFromShape(u.shape),p),m=r.data.get(u.dataId).values,d=u.shape[u.shape.length-1],h=a?(g,y)=>g+d-y-1:(g,y)=>g+y;for(let g=0;g<m.length;g+=d)for(let y=0;y<d;y++){let b=h(g,y);if(y===0)f[b]=i?0:m[b];else{let v=h(g,y-1);f[b]=i?m[v]+f[v]:m[b]+f[v]}}let x=r.makeTensorInfo(u.shape,p,f);if(l!=null){let g=T.getUndoAxesPermutation(l),y=Pe({inputs:{x},backend:r,attrs:{perm:g}});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(u),y}return x}var hW={kernelName:du,backendName:"cpu",kernelFunc:fut};function mut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let l=r.data.get(o.dataId).values,u=r.data.get(s.dataId).values,c=sh(l,u,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=r.bufferSync(o),u=r.bufferSync(s),c=hC(l,u,i,a);return r.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var gW={kernelName:Im,backendName:"cpu",kernelFunc:mut};function dut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockSize:s,dataFormat:i}=n;w.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],l=o.shape[1],u=o.shape[2],c=o.shape[3],p=l*s,f=u*s,m=c/(s*s),d=r.data.get(o.dataId).values,h=new Float32Array(a*p*f*m),x=0;for(let g=0;g<a;++g)for(let y=0;y<p;++y){let b=Math.floor(y/s),v=y%s;for(let C=0;C<f;++C){let S=Math.floor(C/s),k=C%s,I=(v*s+k)*m;for(let D=0;D<m;++D){let M=D+I+c*(S+u*(b+l*g));h[x++]=d[M]}}}return r.makeTensorInfo([a,p,f,m],o.dtype,h)}var xW={kernelName:Em,backendName:"cpu",kernelFunc:dut};function V2(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=n;J([o,s],"depthwiseConv2DNative");let c=w.computeStrides(o.shape),p=w.computeStrides(s.shape),f=l;f==null&&(f=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);let m=T.computeConv2DInfo(o.shape,s.shape,i,f,a,u,!0),{filterHeight:d,filterWidth:h,dilationHeight:x,dilationWidth:g,padInfo:y}=m,b=y.left,v=y.top,C=m.outChannels/m.inChannels,S=new ce(m.outShape,o.dtype),k=r.data.get(o.dataId).values,I=r.data.get(s.dataId).values,D=S.values;for(let R=0;R<m.batchSize;++R){let M=R*c[0],U=R*S.strides[0];for(let j=0;j<m.outHeight;++j){let K=U+j*S.strides[1],W=j*m.strideHeight-v;for(let q=0;q<d;++q){let X=W+q*x;if(X<0||X>=m.inHeight)continue;let Q=q*p[0],Y=M+X*c[1];for(let nt=0;nt<m.outWidth;++nt){let rt=K+nt*S.strides[2],at=nt*m.strideWidth-b;for(let lt=0;lt<h;++lt){let ut=at+lt*g;if(ut<0||ut>=m.inWidth)continue;let it=Q+lt*p[1],dt=Y+ut*m.inChannels,wt=rt,bt=it;for(let St=0;St<m.inChannels;++St){let Wt=k[dt+St];for(let Ht=0;Ht<C;++Ht)D[wt+Ht]+=Wt*I[bt+Ht];wt+=C,bt+=C}}}}}}return r.makeTensorInfo(S.shape,S.dtype,S.values)}var yW={kernelName:hu,backendName:"cpu",kernelFunc:V2};function hut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=n;J([o,s],"depthwiseConv2dNativeBackpropFilter");let p=T.computeConv2DInfo(o.shape,c,i,a,l,u,!0),{strideHeight:f,strideWidth:m,filterHeight:d,filterWidth:h}=p,x=new ce(p.filterShape,"float32"),g=p.padInfo.left,y=p.padInfo.top,b=p.outChannels/p.inChannels,v=r.data.get(o.dataId).values,C=new ce(o.shape,o.dtype,v),S=r.data.get(s.dataId).values,k=new ce(s.shape,s.dtype,S);for(let I=0;I<d;++I){let D=Math.max(0,Math.ceil((y-I)/f)),R=Math.min(p.outHeight,(p.inHeight+y-I)/f);for(let M=0;M<h;++M){let U=Math.max(0,Math.ceil((g-M)/m)),j=Math.min(p.outWidth,(p.inWidth+g-M)/m);for(let K=0;K<p.outChannels;++K){let W=Math.trunc(K/b),q=K%b,X=0;for(let Q=0;Q<p.batchSize;++Q)for(let Y=D;Y<R;++Y){let nt=I+Y*f-y;for(let rt=U;rt<j;++rt){let at=M+rt*m-g;X+=C.get(Q,nt,at,W)*k.get(Q,Y,rt,K)}}x.set(X,I,M,W,q)}}}return r.makeTensorInfo(x.shape,x.dtype,x.values)}var bW={kernelName:_m,backendName:"cpu",kernelFunc:hut};function gut(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=n;J([o,s],"depthwiseConv2DNativeBackpropInput");let p=w.computeStrides(o.shape),f=w.computeStrides(s.shape),m=T.computeConv2DInfo(c,s.shape,i,a,l,u,!0),d=new ce(m.inShape,"float32"),h=d.values,[x,g,y]=d.strides,b=r.data.get(o.dataId).values,[v,C,S]=p,k=r.data.get(s.dataId).values,[I,D,R]=f,{batchSize:M,filterHeight:U,filterWidth:j,inChannels:K,inHeight:W,inWidth:q,outChannels:X,outHeight:Q,outWidth:Y,strideHeight:nt,strideWidth:rt}=m,at=U-1-m.padInfo.top,lt=j-1-m.padInfo.left,ut=X/K;for(let it=0;it<M;++it)for(let dt=0;dt<K;++dt)for(let wt=0;wt<W;++wt){let bt=wt-at,St=Math.max(0,Math.ceil(bt/nt)),Wt=Math.min(Q,(U+bt)/nt);for(let Ht=0;Ht<q;++Ht){let $=Ht-lt,G=Math.max(0,Math.ceil($/rt)),P=Math.min(Y,(j+$)/rt),ot=0;for(let ct=St;ct<Wt;++ct){let pt=ct*nt-bt;for(let Ft=G;Ft<P;++Ft){let ne=Ft*rt-$,Bt=v*it+C*ct+S*Ft,Me=I*(U-1-pt)+D*(j-1-ne)+R*dt;for(let fr=0;fr<ut;++fr){let mr=dt*ut+fr,Ln=b[Bt+mr],Uo=k[Me+fr];ot+=Ln*Uo}}}h[x*it+g*wt+y*Ht+dt]=ot}}return r.makeTensorInfo(d.shape,d.dtype,d.values)}var vW={kernelName:Am,backendName:"cpu",kernelFunc:gut};function xut(e){let{inputs:t,backend:r}=e,{x:n}=t,o=w.sizeFromShape(n.shape),s=r.data.get(n.dataId).values,i=Ct([o,o],n.dtype),a=i.values;for(let u=0;u<s.length;u++)a[u*o+u]=s[u];let l=[...n.shape,...n.shape];return r.makeTensorInfo(l,i.dtype,i.values)}var wW={kernelName:nw,backendName:"cpu",kernelFunc:xut};var CW={kernelName:gu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:o}=e,{strides:s,pad:i,dilations:a}=r,l=t,u=l.data.get(n.dataId).values,c=n.shape.length,p=l.data.get(o.dataId).values,f=o.shape.length,{batchSize:m,inHeight:d,inWidth:h,inChannels:x,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:C,filterHeight:S,filterWidth:k,dilationHeight:I,dilationWidth:D,outShape:R}=T.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),M=w.sizeFromShape(R),U=R.length,j=w.getArrayFromDType(n.dtype,M);for(let W=0;W<m;++W)for(let q=0;q<g;++q){let X=q*v-b.top;for(let Q=0;Q<y;++Q){let Y=Q*C-b.left;for(let nt=0;nt<x;++nt){let rt=Number.MIN_SAFE_INTEGER;for(let lt=0;lt<S;++lt){let ut=X+lt*I;if(ut>=0&&ut<d)for(let it=0;it<k;++it){let dt=Y+it*D;if(dt>=0&&dt<h){let wt=w.locToIndex([W,ut,dt,nt],c,w.computeStrides(n.shape)),bt=w.locToIndex([lt,it,nt],f,w.computeStrides(o.shape)),St=u[wt]+p[bt];St>rt&&(rt=St)}}}let at=w.locToIndex([W,q,Q,nt],U,w.computeStrides(R));j[at]=rt}}}return{dataId:l.write(w.toTypedArray(j,n.dtype),R,n.dtype),shape:R,dtype:n.dtype}}};var SW={kernelName:Zg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:o,dy:s}=e,{strides:i,pad:a,dilations:l}=r,u=t,c=w.toNestedArray(n.shape,u.data.get(n.dataId).values),p=w.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:m,inWidth:d,inChannels:h,outHeight:x,outWidth:g,padInfo:y,strideHeight:b,strideWidth:v,filterHeight:C,filterWidth:S,dilationHeight:k,dilationWidth:I,outShape:D}=T.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",l);w.assert(s.rank===D.length,()=>`Error in ${Zg}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);let R=w.toNestedArray(D,u.data.get(s.dataId).values),M=w.makeZerosNestedTypedArray(o.shape,o.dtype);for(let j=0;j<f;++j)for(let K=0;K<x;++K){let W=K*b-y.top;for(let q=0;q<g;++q){let X=q*v-y.left;for(let Q=0;Q<h;++Q){let Y=Number.MIN_SAFE_INTEGER,nt=0,rt=0;for(let at=0;at<C;++at){let lt=W+at*k;if(lt>=0&&lt<m)for(let ut=0;ut<S;++ut){let it=X+ut*I;if(it>=0&&it<d){let dt=c[j][lt][it][Q]+p[at][ut][Q];dt>Y&&(Y=dt,nt=at,rt=ut)}}}M[nt][rt][Q]+=R[j][K][q][Q]}}}return{dataId:u.write(w.toTypedArray(M,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var kW={kernelName:Qg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:o,dy:s}=e,{strides:i,pad:a,dilations:l}=r,u=t,c=w.toNestedArray(n.shape,u.data.get(n.dataId).values),p=w.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:m,inWidth:d,inChannels:h,outHeight:x,outWidth:g,padInfo:y,strideHeight:b,strideWidth:v,filterHeight:C,filterWidth:S,dilationHeight:k,dilationWidth:I,outShape:D}=T.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",l);w.assert(s.rank===D.length,()=>`Error in ${Qg}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);let R=w.toNestedArray(D,u.data.get(s.dataId).values),M=w.makeZerosNestedTypedArray(n.shape,n.dtype);for(let j=0;j<f;++j)for(let K=0;K<x;++K){let W=K*b-y.top;for(let q=0;q<g;++q){let X=q*v-y.left;for(let Q=0;Q<h;++Q){let Y=Number.MIN_SAFE_INTEGER,nt=W<0?0:W,rt=X<0?0:X;for(let at=0;at<C;++at){let lt=W+at*k;if(lt>=0&&lt<m)for(let ut=0;ut<S;++ut){let it=X+ut*I;if(it>=0&&it<d){let dt=c[j][lt][it][Q]+p[at][ut][Q];dt>Y&&(Y=dt,nt=lt,rt=it)}}}M[j][nt][rt][Q]+=R[j][K][q][Q]}}}return{dataId:u.write(w.toTypedArray(M,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function wl(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;J(o,"sum");let a;o.dtype==="bool"?a=hs({inputs:{x:o},backend:r,attrs:{dtype:"int32"}}):a=rn({inputs:{x:o},backend:r});let l=a.shape.length,u=w.parseAxisParam(s,a.shape),c=T.getAxesPermutation(u,l),p=u,f=a;c!=null&&(f=Pe({inputs:{x:a},backend:r,attrs:{perm:c}}),p=T.getInnerMostAxes(p.length,l)),T.assertAxesAreInnerMostDims("sum",p,f.shape.length);let[m,d]=T.computeOutAndReduceShapes(f.shape,p),h=T.upcastType(f.dtype,"int32"),x=nh(r,m,h),g=w.sizeFromShape(d),y=r.data.get(x.dataId).values,b=r.data.get(f.dataId).values;for(let v=0;v<y.length;++v){let C=v*g,S=0;for(let k=0;k<g;++k)S+=b[C+k];y[v]=S}if(i){let v=T.expandShapeToKeepDim(x.shape,u),C=x;x=jt({inputs:{x},backend:r,attrs:{shape:v}}),r.disposeIntermediateTensorInfo(C)}return r.disposeIntermediateTensorInfo(a),c!=null&&r.disposeIntermediateTensorInfo(f),x}var TW={kernelName:Vu,backendName:"cpu",kernelFunc:wl};function yut(e){let{inputs:t,backend:r,attrs:n}=e,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:l}=T.decodeEinsumEquation(o,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=T.getEinsumComputePath(a,l),p=c.length,f=null,m=i.length,d=[];for(let h=0;h<p;++h){for(let x of c[h]){let{permutationIndices:g,expandDims:y}=T.getEinsumPermutation(m,l[x]),b;T.isIdentityPermutation(g)?b=s[x]:(b=Pe({inputs:{x:s[x]},backend:r,attrs:{perm:g}}),d.push(b));let v=b.shape.slice();for(let C=0;C<y.length;++C)v.splice(y[C],0,1);w.arraysEqual(b.shape,v)||(b=jt({inputs:{x:b},backend:r,attrs:{shape:v}}),d.push(b)),f===null?f=b:(f=Zp({inputs:{a:b,b:f},backend:r}),d.push(f))}h<p-1&&(u[h]>=0&&(f=wl({inputs:{x:f},backend:r,attrs:{axis:u[h]-(i.length-m),keepDims:!1}}),d.push(f)),m--)}for(let h of d)h!==f&&r.disposeIntermediateTensorInfo(h);return f}var NW={kernelName:Dm,backendName:"cpu",kernelFunc:yut};function but(e){let{inputs:t,backend:r}=e,{dy:n,y:o}=t;J([n,o],"eluGrad");let s=new Float32Array(w.sizeFromShape(o.shape)),i=r.data.get(o.dataId).values,a=r.data.get(n.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=1?s[l]=a[l]:s[l]=a[l]*(u+1)}return r.makeTensorInfo(o.shape,"float32",s)}var IW={kernelName:Rm,backendName:"cpu",kernelFunc:but};var vut=T.ERF_P,wut=T.ERF_A1,Cut=T.ERF_A2,Sut=T.ERF_A3,kut=T.ERF_A4,Tut=T.ERF_A5,Nut=Rt(va,e=>{let t=Math.sign(e),r=Math.abs(e),n=1/(1+vut*r);return t*(1-((((Tut*n+kut)*n+Sut)*n+Cut)*n+wut)*n*Math.exp(-r*r))}),EW={kernelName:va,backendName:"cpu",kernelFunc:Nut};function ch(e){let{inputs:t,backend:r,attrs:n}=e,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),jt({inputs:{x:o},backend:r,attrs:{shape:a}})}var _W={kernelName:xu,backendName:"cpu",kernelFunc:ch};var Iut=Xt((e,t)=>e/t),pb=Jt(ya,Iut),fb={kernelName:ya,backendName:"cpu",kernelFunc:pb};function PC(e,t,r){let n=e.shape,o=n[0],s=n[1],i=r.data.get(e.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[o,s],c=w.sizeFromShape(u),p=w.getTypedArrayFromDType("float32",c),f=w.getTypedArrayFromDType("float32",c);for(let x=0;x<o;x++){let g=ys({inputs:{x:a},backend:r,attrs:{begin:[x,0],size:[1,s]}}),y=ys({inputs:{x:l},backend:r,attrs:{begin:[x,0],size:[1,s]}}),b=Sr({inputs:{real:g,imag:y},backend:r}),{real:v,imag:C}=Eut(b,t,r),S=T.mergeRealAndImagArrays(v,C);for(let k=0;k<s;k++){let I=T.getComplexWithIndex(S,k);p[x*s+k]=I.real,f[x*s+k]=I.imag}r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(b)}let m=r.makeTensorInfo(u,"float32",p),d=r.makeTensorInfo(u,"float32",f),h=Sr({inputs:{real:m,imag:d},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(d),h}function Eut(e,t,r){let n=w.sizeFromShape(e.shape),o=r.data.get(e.dataId),s=r.data.get(o.complexTensorInfos.real.dataId).values,i=r.data.get(o.complexTensorInfos.imag.dataId).values;if(_ut(n)){let a=W2(s,i,n,t,r),l=[e.shape[0],e.shape[1]];if(t){let u=r.makeTensorInfo(l,"float32",a.real),c=r.makeTensorInfo(l,"float32",a.imag),p=r.makeTensorInfo([],"float32",w.createScalarValue(n,"float32")),f=rn({inputs:{x:p},backend:r}),m=fb.kernelFunc({inputs:{a:u,b:p},backend:r}),d=fb.kernelFunc({inputs:{a:c,b:f},backend:r}),h=r.data.get(m.dataId).values,x=r.data.get(d.dataId).values;return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(d),{real:h,imag:x}}return a}else{let a=T.mergeRealAndImagArrays(s,i),l=Aut(a,n,t);return T.splitRealAndImagArrays(l)}}function _ut(e){return(e&e-1)===0}function W2(e,t,r,n,o){if(r===1)return{real:e,imag:t};let s=T.mergeRealAndImagArrays(e,t),i=r/2,a=T.complexWithEvenIndex(s),l=a.real,u=a.imag,c=[l.length],p=o.makeTensorInfo(c,"float32",l),f=o.makeTensorInfo(c,"float32",u),m=Sr({inputs:{real:p,imag:f},backend:o}),d=T.complexWithOddIndex(s),h=d.real,x=d.imag,g=[h.length],y=o.makeTensorInfo(g,"float32",h),b=o.makeTensorInfo(g,"float32",x),v=Sr({inputs:{real:y,imag:b},backend:o}),C=W2(l,u,i,n,o),S=C.real,k=C.imag,I=[S.length],D=o.makeTensorInfo(I,"float32",S),R=o.makeTensorInfo(I,"float32",k),M=Sr({inputs:{real:D,imag:R},backend:o}),U=W2(h,x,i,n,o),j=U.real,K=U.imag,W=[j.length],q=o.makeTensorInfo(W,"float32",j),X=o.makeTensorInfo(W,"float32",K),Q=Sr({inputs:{real:q,imag:X},backend:o}),Y=T.exponents(r,n),nt=[Y.real.length],rt=o.makeTensorInfo(nt,"float32",Y.real),at=o.makeTensorInfo(nt,"float32",Y.imag),lt=Sr({inputs:{real:rt,imag:at},backend:o}),ut=Zp({inputs:{a:lt,b:Q},backend:o}),it=Oi({inputs:{a:M,b:ut},backend:o}),dt=ub({inputs:{a:M,b:ut},backend:o}),wt=ds({inputs:{input:it},backend:o}),bt=ds({inputs:{input:dt},backend:o}),St=Fi({inputs:{input:it},backend:o}),Wt=Fi({inputs:{input:dt},backend:o}),Ht=fc({inputs:[wt,bt],backend:o,attrs:{axis:0}}),$=fc({inputs:[St,Wt],backend:o,attrs:{axis:0}}),G=o.data.get(Ht.dataId).values,P=o.data.get($.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(D),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(q),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(rt),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(lt),o.disposeIntermediateTensorInfo(ut),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(dt),o.disposeIntermediateTensorInfo(wt),o.disposeIntermediateTensorInfo(St),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(Wt),o.disposeIntermediateTensorInfo(Ht),o.disposeIntermediateTensorInfo($),{real:G,imag:P}}function Aut(e,t,r){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let l=T.exponent(o*a,t,r),u=T.getComplexWithIndex(e,a);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}r&&(s/=t,i/=t),T.assignToTypedArray(n,s,i,o)}return n}function Dut(e){let{inputs:t,backend:r}=e,{input:n}=t,o=w.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=jt({inputs:{x:n},backend:r,attrs:{shape:[i,s]}}),l=PC(a,!1,r),u=jt({inputs:{x:l},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}var AW={kernelName:$m,backendName:"cpu",kernelFunc:Dut};function mb(e){let{backend:t,attrs:r}=e,{shape:n,value:o,dtype:s}=r,i=s||w.inferDtype(o),a=w.getArrayFromDType(i,w.sizeFromShape(n));return Rut(a,o,i),t.makeTensorInfo(n,i,a)}var DW={kernelName:Om,backendName:"cpu",kernelFunc:mb};function Rut(e,t,r){e.fill(t)}var RW={kernelName:Fm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,o=r,s=w.getTypedArrayFromDType(n.dtype,w.sizeFromShape(n.shape)),[i,a,l,u]=n.shape,c=o.data.get(n.dataId).values;for(let f=0;f<i;f++){let m=f*l*a*u;for(let d=0;d<a;d++){let h=d*(l*u);for(let x=0;x<l;x++){let g=x*u;for(let y=0;y<u;y++){let b=Math.round(l-x-1),v=m+h+g+y,C=c[v];if(b>=0&&b<l){let S=b*u,k=m+h+S+y;C=c[k]}s[v]=C}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var $ut=Xt((e,t)=>Math.floor(e/t)),Out=Jt(ka,$ut,null,"int32"),$W={kernelName:ka,backendName:"cpu",kernelFunc:Out};function Fut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:d}=n,h=B2({inputs:{x:o,filter:s},backend:r,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let x=h;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let g=jt({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}});h=Oi({inputs:{a:h,b:g},backend:r}),r.disposeIntermediateTensorInfo(g)}else h=Oi({inputs:{a:h,b:i},backend:r});r.disposeIntermediateTensorInfo(x)}if(m){let x=h;if(c==="NCHW"&&m==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let g=jt({inputs:{x:a},backend:r,attrs:{shape:[a.shape[0],1,1]}});h=Jp(r,h,m,g,d),r.disposeIntermediateTensorInfo(g)}else h=Jp(r,h,m,a,d);r.disposeIntermediateTensorInfo(x)}return h}var OW={kernelName:pp,backendName:"cpu",kernelFunc:Fut};function Put(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:d}=n,h=V2({inputs:{x:o,filter:s},backend:r,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let x=h;h=Oi({inputs:{a:h,b:i},backend:r}),r.disposeIntermediateTensorInfo(x)}if(m){let x=h;h=Jp(r,h,m,a,d),r.disposeIntermediateTensorInfo(x)}return h}var FW={kernelName:fp,backendName:"cpu",kernelFunc:Put};function Lut(e){let{inputs:t,backend:r}=e,{params:n,indices:o}=t,s=w.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[l,u,c,p]=T.prepareAndValidate(n,o);if(u===0)return r.makeTensorInfo(l,n.dtype,[]);let f=r.data.get(o.dataId).values,m=r.bufferSync(n),d=xC(f,m,n.dtype,u,a,c,p,n.shape,s);return r.makeTensorInfo(l,n.dtype,d.values)}var PW={kernelName:ow,backendName:"cpu",kernelFunc:Lut};function Mut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;J([o,s],"gatherV2");let l=w.parseAxisParam(i,o.shape)[0],u=r.data.get(s.dataId).values,c=o.shape[l];for(let v=0;v<u.length;++v){let C=u[v];w.assert(C<=c-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let f=w.sizeFromShape(s.shape),m=T.segment_util.collectGatherOpShapeInfo(o,s,l,p),d=jt({inputs:{x:o},backend:r,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),h=jt({inputs:{x:s},backend:r,attrs:{shape:[m.batchSize,f/m.batchSize]}}),x=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],g=r.bufferSync(h),y=r.bufferSync(d),b=yC(y,g,x);return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.makeTensorInfo(m.outputShape,b.dtype,b.values)}var LW={kernelName:bu,backendName:"cpu",kernelFunc:Mut};function zut(e){let{inputs:t,backend:r}=e,{input:n}=t,o=w.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=jt({inputs:{x:n},backend:r,attrs:{shape:[i,s]}}),l=PC(a,!0,r),u=jt({inputs:{x:l},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}var MW={kernelName:Pm,backendName:"cpu",kernelFunc:zut};var But=Rt(Na,e=>Number.isFinite(e)?1:0,"bool"),zW={kernelName:Na,backendName:"cpu",kernelFunc:But};var Vut=Rt(Ia,e=>Math.abs(e)===1/0?1:0,"bool"),BW={kernelName:Ia,backendName:"cpu",kernelFunc:Vut};var Wut=Rt(Ea,e=>Number.isNaN(e)?1:0,"bool"),VW={kernelName:Ea,backendName:"cpu",kernelFunc:Wut};function Gut(e){let{backend:t,attrs:r}=e,{start:n,stop:o,num:s}=r,i=bC(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var WW={kernelName:sw,backendName:"cpu",kernelFunc:Gut};var Uut=Rt(Aa,e=>Math.log1p(e)),GW={kernelName:Aa,backendName:"cpu",kernelFunc:Uut};var Hut=Xt((e,t)=>e&&t),qut=Jt(ip,Hut,null,"bool"),UW={kernelName:ip,backendName:"cpu",kernelFunc:qut};var jut=Rt(ap,e=>e?0:1,"bool"),HW={kernelName:ap,backendName:"cpu",kernelFunc:jut};var Kut=Xt((e,t)=>e||t),Xut=Jt(lp,Kut,null,"bool"),qW={kernelName:lp,backendName:"cpu",kernelFunc:Xut};function Yut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=n;J(o,"LRN");let u=o.shape[3],c=u-1,p=r.data.get(o.dataId).values,f=w.sizeFromShape(o.shape),m=new Float32Array(f);function d(h){let x=h%u,g=h-x+Math.max(0,x-s),y=h-x+Math.min(x+s,c),b=0;for(;g<=y;g++){let v=p[g];b+=v*v}return b}for(let h=0;h<f;h++){let x=d(h),g=p[h]*Math.pow(i+a*x,-l);m[h]=g}return r.makeTensorInfo(o.shape,o.dtype,m)}var jW={kernelName:wu,backendName:"cpu",kernelFunc:Yut};function Qut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=n;J(i,"LRNGrad");let p=w.sizeFromShape(i.shape),f=i.shape[3],m=r.data.get(i.dataId).values,d=r.data.get(o.dataId).values,h=r.data.get(s.dataId).values,x=new Float32Array(p),g=p;for(let y=0;y<g;y++){let b=y%f,v=y-b+Math.max(0,b-a),C=y-b+Math.min(f,b+a+1),S=0;for(let k=v;k<C;k++)S+=Math.pow(d[k],2);S=u*S+l;for(let k=v;k<C;k++){let I=-2*u*c*d[k]*h[y]/S;y===k&&(I+=Math.pow(S,-c)),I*=m[y],x[k]+=I}}return r.makeTensorInfo(i.shape,o.dtype,x)}var KW={kernelName:Mm,backendName:"cpu",kernelFunc:Qut};function G2(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=r,l=o.shape,u=l.length,c=w.parseAxisParam(s,l),p=c,f=T.getAxesPermutation(p,u),m=a.data.get(o.dataId).values;if(f!=null){let v=new Array(u);for(let C=0;C<v.length;C++)v[C]=l[f[C]];m=ih(m,l,o.dtype,f,v),p=T.getInnerMostAxes(p.length,u),l=v}J(o,"max"),T.assertAxesAreInnerMostDims("max",p,u);let[d,h]=T.computeOutAndReduceShapes(l,p),x=w.sizeFromShape(h),g=vC(m,x,d,o.dtype),y=a.write(g,d,o.dtype),b=d;return i&&(b=T.expandShapeToKeepDim(d,c)),{dataId:y,shape:b,dtype:o.dtype}}var XW={kernelName:Cu,backendName:"cpu",kernelFunc:G2};function Zut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t;J(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=n,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=T.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))p=rn({inputs:{x:o},backend:r});else{let f=r.data.get(o.dataId).values,m=w.computeStrides(o.shape),d=uh(f,o.shape,o.dtype,m,c,"max");p=r.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var YW={kernelName:Su,backendName:"cpu",kernelFunc:Zut};function Jut(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=n;J(o,"maxPool3d");let c=T.computePool3DInfo(o.shape,s,i,1,a,l,u),p=r.data.get(o.dataId).values,f=FC(p,o.shape,o.dtype,w.computeStrides(o.shape),c,"max");return r.makeTensorInfo(f.shape,"float32",f.values)}var QW={kernelName:ku,backendName:"cpu",kernelFunc:Jut};function tct(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=n;J([o,s],"maxPool3DGrad");let c=T.computePool3DInfo(s.shape,i,a,1,l,u),p=r.bufferSync(s),f=qV(p,c),m=c.strideDepth,d=c.strideHeight,h=c.strideWidth,x=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,C=c.effectiveFilterWidth,S=b-1-c.padInfo.front,k=C-1-c.padInfo.left,I=v-1-c.padInfo.top,D=Ct(s.shape,"float32"),R=r.bufferSync(o);for(let M=0;M<c.batchSize;++M)for(let U=0;U<c.inChannels;++U)for(let j=0;j<c.inDepth;++j)for(let K=0;K<c.inHeight;++K)for(let W=0;W<c.inWidth;++W){let q=j-S,X=K-I,Q=W-k,Y=0;for(let nt=0;nt<b;nt+=x){let rt=(q+nt)/m;if(!(rt<0||rt>=c.outDepth||Math.floor(rt)!==rt))for(let at=0;at<v;at+=g){let lt=(X+at)/d;if(!(lt<0||lt>=c.outHeight||Math.floor(lt)!==lt))for(let ut=0;ut<C;ut+=y){let it=(Q+ut)/h;if(it<0||it>=c.outWidth||Math.floor(it)!==it)continue;let dt=b*v*C-1-f.get(M,rt,lt,it,U),wt=nt*v*C+at*C+ut,bt=dt===wt?1:0;if(bt===0)continue;let St=R.get(M,rt,lt,it,U);Y+=St*bt}}}D.set(Y,M,j,K,W,U)}return r.makeTensorInfo(D.shape,D.dtype,D.values)}var ZW={kernelName:Bm,backendName:"cpu",kernelFunc:tct};function ect(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s,output:i}=t,a=s;J([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=n,f=T.computePool2DInfo(a.shape,l,u,1,c,p),m=r.data.get(a.dataId).values,d=Ct(f.outShape,a.dtype,OC(m,a.shape,a.dtype,f).values),h=f.strideHeight,x=f.strideWidth,g=f.dilationHeight,y=f.dilationWidth,b=f.effectiveFilterHeight,v=f.effectiveFilterWidth,C=v-1-f.padInfo.left,S=b-1-f.padInfo.top,k=Ct(a.shape,"float32"),I=r.data.get(o.dataId).values,D=Ct(o.shape,"float32",I);for(let R=0;R<f.batchSize;++R)for(let M=0;M<f.inChannels;++M)for(let U=0;U<f.inHeight;++U)for(let j=0;j<f.inWidth;++j){let K=U-S,W=j-C,q=0;for(let X=0;X<b;X+=g){let Q=(K+X)/h;if(!(Q<0||Q>=f.outHeight||Math.floor(Q)!==Q))for(let Y=0;Y<v;Y+=y){let nt=(W+Y)/x;if(nt<0||nt>=f.outWidth||Math.floor(nt)!==nt)continue;let rt=b*v-1-d.get(R,Q,nt,M),at=X*v+Y,lt=rt===at?1:0;if(lt===0)continue;let ut=D.get(R,Q,nt,M);q+=ut*lt}}k.set(q,R,U,j,M)}return r.makeTensorInfo(k.shape,k.dtype,k.values)}var JW={kernelName:zm,backendName:"cpu",kernelFunc:ect};function t4(e,t,r,n,o){let s=w.computeStrides(t),i=uh(e,t,r,s,o,"max"),a=OC(e,t,r,o,!0,n);return[i.values,a.values]}var e4={kernelName:iw,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,l=r;J(n,"MaxPoolWithArgmax");let u=l.data.get(n.dataId).values,c=T.computePool2DInfo(n.shape,o,s,[1,1],i),[p,f]=t4(u,n.shape,n.dtype,a,c),m=l.write(p,c.outShape,n.dtype),d=l.write(f,c.outShape,n.dtype);return[{dataId:m,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function rct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n,a=w.parseAxisParam(s,o.shape),u=T.computeOutAndReduceShapes(o.shape,a)[1],c=w.sizeFromShape(u),p=[],f=r.makeTensorInfo([],"float32",new Float32Array([c]));p.push(f);let m=hs({inputs:{x:o},backend:r,attrs:{dtype:"float32"}});p.push(m);let d=pb({inputs:{a:m,b:f},backend:r});p.push(d);let h=wl({inputs:{x:d},backend:r,attrs:{axis:s,keepDims:i}});return p.forEach(x=>r.disposeIntermediateTensorInfo(x)),h}var r4={kernelName:Tu,backendName:"cpu",kernelFunc:rct};function nct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;J(o,"min");let a=w.parseAxisParam(s,o.shape),l=a,u=T.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Pe({inputs:{x:o},backend:r,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,o.shape.length)),T.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,f]=T.computeOutAndReduceShapes(c.shape,l),m=w.sizeFromShape(f),d=w.makeZerosTypedArray(w.sizeFromShape(p),c.dtype),h=r.data.get(c.dataId).values;for(let g=0;g<d.length;++g){let y=g*m,b=h[y];for(let v=0;v<m;++v){let C=h[y+v];(Number.isNaN(C)||C<b)&&(b=C)}d[g]=b}u!=null&&r.disposeIntermediateTensorInfo(c);let x=r.makeTensorInfo(p,c.dtype,d);if(i){let g=T.expandShapeToKeepDim(p,a),y=jt({inputs:{x},backend:r,attrs:{shape:g}});return r.disposeIntermediateTensorInfo(x),y}return x}var n4={kernelName:Nu,backendName:"cpu",kernelFunc:nct};function oct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{paddings:s,mode:i}=n;J(o,"mirrorPad");let a=s.map((b,v)=>b[0]+o.shape[v]+b[1]),l=s.map(b=>b[0]),u=s.map((b,v)=>b[0]+o.shape[v]),c=i==="reflect"?0:1,p=r.data.get(o.dataId).values,f=o.shape.length,m=w.computeStrides(o.shape),d=w.sizeFromShape(a),h=a.length,x=w.computeStrides(a),g=w.getTypedArrayFromDType(o.dtype,d);for(let b=0;b<d;b++){let v=w.indexToLoc(b,h,x);for(let S=0;S<h;S++)v[S]<l[S]?v[S]=l[S]*2-v[S]-c:v[S]>=u[S]&&(v[S]=(u[S]-1)*2-v[S]+c);v=v.map((S,k)=>S-l[k]);let C=w.locToIndex(v,f,m);g[b]=p[C]}return{dataId:r.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var o4={kernelName:Iu,backendName:"cpu",kernelFunc:oct};var sct=Xt((e,t)=>{let r=e%t;return e<0&&t<0||e>=0&&t>=0?r:(r+t)%t}),ict=Jt($a,sct),s4={kernelName:$a,backendName:"cpu",kernelFunc:ict};var a4=Yt(wx());function U2(e){let{inputs:t,backend:r,attrs:n}=e,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let l=w.parseAxisParam([a],o.shape),u=G2({inputs:{x:o},backend:r,attrs:{reductionIndices:l,keepDims:!1}}),c=T.expandShapeToKeepDim(u.shape,l),p=jt({inputs:{x:u},backend:r,attrs:{shape:c}}),f=ub({inputs:{a:o,b:p},backend:r}),m=d2({inputs:{x:f},backend:r}),d=wl({inputs:{x:m},backend:r,attrs:{axis:l,keepDims:!1}}),h=jt({inputs:{x:d},backend:r,attrs:{shape:c}}),x=pb({inputs:{a:m,b:h},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),x}var i4={kernelName:Uu,backendName:"cpu",kernelFunc:U2};function act(e){let{inputs:t,backend:r,attrs:n}=e,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;J(o,"multinomial");let l=a?o:U2({inputs:{logits:o},backend:r,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=r.data.get(l.dataId).values,f=[u,s],m=w.makeZerosTypedArray(w.sizeFromShape(f),"int32");for(let d=0;d<u;++d){let h=d*c,x=new Float32Array(c-1);x[0]=p[h];for(let b=1;b<x.length;++b)x[b]=x[b-1]+p[h+b];let g=a4.alea(i.toString()),y=d*s;for(let b=0;b<s;++b){let v=g();m[y+b]=x.length;for(let C=0;C<x.length;C++)if(v<x[C]){m[y+b]=C;break}}}return a||r.disposeIntermediateTensorInfo(l),r.makeTensorInfo(f,"int32",m)}var l4={kernelName:aw,backendName:"cpu",kernelFunc:act};var lct=tn.nonMaxSuppressionV3Impl;function uct(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=n;J(o,"NonMaxSuppression");let u=r.data.get(o.dataId).values,c=r.data.get(s.dataId).values,{selectedIndices:p}=lct(u,c,i,a,l);return r.makeTensorInfo([p.length],"int32",new Int32Array(p))}var u4={kernelName:Vm,backendName:"cpu",kernelFunc:uct};var cct=tn.nonMaxSuppressionV4Impl;function pct(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=n;J(o,"NonMaxSuppressionPadded");let c=r.data.get(o.dataId).values,p=r.data.get(s.dataId).values,{selectedIndices:f,validOutputs:m}=cct(c,p,i,a,l,u);return[r.makeTensorInfo([f.length],"int32",new Int32Array(f)),r.makeTensorInfo([],"int32",new Int32Array([m]))]}var c4={kernelName:Wm,backendName:"cpu",kernelFunc:pct};var fct=tn.nonMaxSuppressionV5Impl;function mct(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=n;J(o,"NonMaxSuppressionWithScore");let c=r.data.get(o.dataId).values,p=r.data.get(s.dataId).values,f=i,m=a,d=l,h=u,{selectedIndices:x,selectedScores:g}=fct(c,p,f,m,d,h);return[r.makeTensorInfo([x.length],"int32",new Int32Array(x)),r.makeTensorInfo([g.length],"float32",new Float32Array(g))]}var p4={kernelName:Gm,backendName:"cpu",kernelFunc:mct};function dct(e){let{inputs:t,backend:r,attrs:n}=e,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:l}=n;J(o,"oneHot");let u=w.sizeFromShape(o.shape),c=new Float32Array(u*i);c.fill(l);let p=r.data.get(o.dataId).values;for(let f=0;f<u;++f)p[f]>=0&&p[f]<i&&(c[f*i+p[f]]=a);return r.makeTensorInfo([...o.shape,i],s,c)}var f4={kernelName:Au,backendName:"cpu",kernelFunc:dct};function db(e){let{inputs:t,backend:r}=e,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=ds({inputs:{input:n},backend:r}),s=db({inputs:{x:o},backend:r}),i=Fi({inputs:{input:n},backend:r}),a=db({inputs:{x:i},backend:r}),l=Sr({inputs:{real:s,imag:a},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),l}else return mb({backend:r,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var m4={kernelName:ju,backendName:"cpu",kernelFunc:db};function d4(e){let{inputs:t,backend:r}=e,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=ds({inputs:{input:n},backend:r}),s=d4({inputs:{x:o},backend:r}),i=Fi({inputs:{input:n},backend:r}),a=db({inputs:{x:i},backend:r}),l=Sr({inputs:{real:s,imag:a},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),l}else return mb({backend:r,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var h4={kernelName:_u,backendName:"cpu",kernelFunc:d4};function H2(e){let{inputs:t,backend:r,attrs:n}=e,{axis:o}=n;if(t.length===1)return ch({inputs:{input:t[0]},backend:r,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=ch({inputs:{input:c},backend:r,attrs:{dim:o}});return a.push(p),p}),u=fc({inputs:l,backend:r,attrs:{axis:o}});return a.forEach(c=>r.disposeIntermediateTensorInfo(c)),u}var g4={kernelName:Du,backendName:"cpu",kernelFunc:H2};function hct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{paddings:s,constantValue:i}=n;J(o,"pad");let a=s.map((y,b)=>y[0]+o.shape[b]+y[1]),l=s.map(y=>y[0]),u=r.data.get(o.dataId).values,c=w.sizeFromShape(o.shape),p=o.shape.length,f=w.computeStrides(o.shape),m=w.sizeFromShape(a),d=a.length,h=w.computeStrides(a),x=w.getTypedArrayFromDType(o.dtype,m);i!==0&&x.fill(i);for(let y=0;y<c;y++){let v=w.indexToLoc(y,p,f).map((S,k)=>S+l[k]),C=w.locToIndex(v,d,h);x[C]=u[y]}return{dataId:r.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var LC={kernelName:Ru,backendName:"cpu",kernelFunc:hct};var gct=Xt((e,t)=>Math.pow(e,t)),xct=Jt(Fa,gct),x4={kernelName:Fa,backendName:"cpu",kernelFunc:xct};function yct(e){let{inputs:t,backend:r,attrs:n}=e,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=n,l=o.map(g=>r.data.get(g.dataId).values),u=o.map(g=>g.shape),c=r.data.get(s.dataId).values,p=r.data.get(i.dataId).values,[f,m,d]=wC(l,u,c,s.shape,s.dtype,p,i.shape,a),h=f.map(g=>r.makeTensorInfo([g.length],"int32",g)),x=r.makeTensorInfo(d,s.dtype,m);return h.concat([x])}var y4={kernelName:lw,backendName:"cpu",kernelFunc:yct};function bct(e){let{inputs:t,backend:r}=e,{starts:n,limits:o,deltas:s}=t,i=r.data.get(n.dataId).values,a=r.data.get(o.dataId).values,l=r.data.get(s.dataId).values,[u,c]=CC(i,n.shape,n.dtype,a,o.shape,l,s.shape),p=r.makeTensorInfo([u.length],"int32",u),f=r.makeTensorInfo([c.length],n.dtype,c);return[p,f]}var b4={kernelName:uw,backendName:"cpu",kernelFunc:bct};function vct(e){let{inputs:t,backend:r,attrs:n}=e,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=n,u=r.data.get(o.dataId).values,c=r.data.get(s.dataId).values,p=r.data.get(i.dataId).values,f=a.map(x=>r.data.get(x.dataId).values),m=a.map(x=>x.shape),[d,h]=SC(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,m,l);return r.makeTensorInfo(d,s.dtype,h)}var v4={kernelName:cw,backendName:"cpu",kernelFunc:vct};function wct(e){let{backend:t,attrs:r}=e,{start:n,stop:o,dtype:s,step:i}=r,a=kC(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var w4={kernelName:Um,backendName:"cpu",kernelFunc:wct};var Cct=Rt(Pa,e=>1/e),C4={kernelName:Pa,backendName:"cpu",kernelFunc:Cct};function Sct(e){let{inputs:t,backend:r,attrs:n}=e,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;J(o,"resizeBilinear");let l=w.computeStrides(o.shape),[u,c]=a,[p,f,m,d]=o.shape,h=r.data.get(o.dataId).values,x=new Float32Array(w.sizeFromShape([p,u,c,d])),g=[s&&u>1?f-1:f,s&&c>1?m-1:m],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],b=0,v=g[0]/y[0],C=g[1]/y[1];for(let S=0;S<p;S++)for(let k=0;k<u;k++){let I;i?I=v*(k+.5)-.5:I=v*k;let D=Math.max(0,Math.floor(I)),R=I-D,M=Math.min(f-1,Math.ceil(I)),U=S*l[0]+D*l[1],j=S*l[0]+M*l[1];for(let K=0;K<c;K++){let W;i?W=C*(K+.5)-.5:W=C*K;let q=Math.max(0,Math.floor(W)),X=W-q,Q=Math.min(m-1,Math.ceil(W)),Y=U+q*l[2],nt=j+q*l[2],rt=U+Q*l[2],at=j+Q*l[2];for(let lt=0;lt<d;lt++){let ut=h[Y+lt],it=h[nt+lt],dt=h[rt+lt],wt=h[at+lt],bt=ut+(dt-ut)*X,St=it+(wt-it)*X,Wt=bt+(St-bt)*R;x[b++]=Wt}}}return r.makeTensorInfo([p,u,c,d],"float32",x)}var S4={kernelName:Lu,backendName:"cpu",kernelFunc:Sct};function kct(e){let{inputs:t,backend:r,attrs:n}=e,{images:o,dy:s}=t,{alignCorners:i}=n;J([s,o],"resizeBilinearGrad");let a=w.computeStrides(o.shape),[l,u,c,p]=o.shape,[,f,m]=s.shape,d=new Float32Array(l*u*c*p),h=[i&&f>1?u-1:u,i&&m>1?c-1:c],x=[i&&f>1?f-1:f,i&&m>1?m-1:m],g=h[0]/x[0],y=h[1]/x[1],b=r.data.get(s.dataId).values,v=0;for(let C=0;C<l;C++){let S=C*a[0];for(let k=0;k<f;k++){let I=k*g,D=Math.floor(I),R=Math.min(Math.ceil(I),u-1),M=S+D*a[1],U=S+R*a[1],j=I-D,K=1-j;for(let W=0;W<m;W++){let q=W*y,X=Math.floor(q),Q=Math.min(Math.ceil(q),c-1),Y=q-X,nt=1-Y,rt=M+X*a[2],at=M+Q*a[2],lt=U+X*a[2],ut=U+Q*a[2],it=K*nt,dt=K*Y,wt=j*nt,bt=j*Y;for(let St=0;St<p;St++){let Wt=b[v++];d[rt+St]+=Wt*it,d[at+St]+=Wt*dt,d[lt+St]+=Wt*wt,d[ut+St]+=Wt*bt}}}}return r.makeTensorInfo([l,c,u,p],"float32",d)}var k4={kernelName:jm,backendName:"cpu",kernelFunc:kct};function Tct(e){let{inputs:t,backend:r,attrs:n}=e,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;J(o,"resizeNearestNeighbor");let l=w.computeStrides(o.shape),[u,c]=a,[p,f,m,d]=o.shape,h=r.data.get(o.dataId).values,x=new Float32Array(p*u*c*d),g=[s&&u>1?f-1:f,s&&c>1?m-1:m],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],b=g[0]/y[0],v=g[1]/y[1],C=0;for(let S=0;S<p;S++){let k=S*l[0];for(let I=0;I<u;I++){let D=i?b*(I+.5):b*I,R=Math.min(f-1,s?Math.round(D):Math.floor(D));i&&(R=Math.max(0,R));let M=k+R*l[1];for(let U=0;U<c;U++){let j=i?v*(U+.5):v*U,K=Math.min(m-1,s?Math.round(j):Math.floor(j));i&&(K=Math.max(0,K));let W=M+K*l[2];for(let q=0;q<d;q++){let X=h[W+q];x[C++]=X}}}}return r.makeTensorInfo([p,u,c,d],o.dtype,x)}var T4={kernelName:Pu,backendName:"cpu",kernelFunc:Tct};function Nct(e){let{inputs:t,backend:r,attrs:n}=e,{images:o,dy:s}=t,{alignCorners:i}=n;J([s,o],"resizeNearestNeighborGrad");let a=w.computeStrides(o.shape),l=w.computeStrides(s.shape),[u,c,p,f]=o.shape,[,m,d]=s.shape,h=new Float32Array(u*c*p*f),x=r.data.get(s.dataId).values,g=[i&&m>1?c-1:c,i&&d>1?p-1:p],y=[i&&m>1?m-1:m,i&&d>1?d-1:d],b=g[0]/y[0],v=g[1]/y[1],C=1/b,S=1/v,k=Math.ceil(C)*2+2,I=Math.ceil(S)*2+2;for(let D=0;D<u;D++){let R=D*a[0];for(let M=0;M<c;M++){let U=R+M*a[1],j=Math.floor(M*C),K=Math.floor(j-k/2);for(let W=0;W<p;W++){let q=U+W*a[2],X=Math.floor(W*S),Q=Math.floor(X-I/2);for(let Y=0;Y<f;Y++){let nt=0;for(let rt=0;rt<k;rt++){let at=rt+K;if(at<0||at>=m)continue;let lt=R+at*l[1],ut=at*b,it=Math.min(c-1,i?Math.round(ut):Math.floor(ut));if(M===it)for(let dt=0;dt<I;dt++){let wt=dt+Q;if(wt<0||wt>=d)continue;let bt=lt+wt*l[2],St=wt*v,Wt=Math.min(p-1,i?Math.round(St):Math.floor(St));W===Wt&&(nt+=x[bt+Y])}}h[q+Y]=nt}}}}return r.makeTensorInfo(o.shape,o.dtype,h)}var N4={kernelName:qm,backendName:"cpu",kernelFunc:Nct};function Ict(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{dims:s}=n;J(o,"reverse");let i=o.shape.length,a=w.parseAxisParam(s,o.shape);if(i===0)return rn({inputs:{x:o},backend:r});let l=new ce(o.shape,o.dtype),u=r.bufferSync(o);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),f=p.slice();a.forEach(m=>f[m]=o.shape[m]-1-f[m]),l.set(u.get(...f),...p)}return r.makeTensorInfo(l.shape,l.dtype,l.values)}var I4={kernelName:Mu,backendName:"cpu",kernelFunc:Ict};var E4={kernelName:Jm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:o,fillValue:s,center:i}=t,a=r,l=w.getTypedArrayFromDType(n.dtype,w.sizeFromShape(n.shape)),[u,c,p,f]=n.shape,[m,d]=T.getImageCenter(i,c,p),h=255,x=Math.sin(o),g=Math.cos(o),y=a.data.get(n.dataId).values;for(let v=0;v<u;v++){let C=v*p*c*f;for(let S=0;S<c;S++){let k=S*(p*f);for(let I=0;I<p;I++){let D=I*f;for(let R=0;R<f;R++){let M=[u,S,I,R],U=M[2],j=M[1],K=(U-m)*g-(j-d)*x,W=(U-m)*x+(j-d)*g;K=Math.round(K+m),W=Math.round(W+d);let q=s;if(typeof s!="number"&&(R===3?q=h:q=s[R]),K>=0&&K<p&&W>=0&&W<c){let Q=W*(p*f),Y=K*f,nt=C+Q+Y+R;q=y[nt]}let X=C+k+D+R;l[X]=q}}}}return{dataId:a.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Ect=Rt(za,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),_4={kernelName:za,backendName:"cpu",kernelFunc:Ect};function _ct(e){let{inputs:t,backend:r,attrs:n}=e,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=T.calculateShapes(s,o,i),f=!0,m=r.bufferSync(o),d=r.bufferSync(s),h=vl(m,d,i,p,u,l,a,c,0,f);return r.makeTensorInfo(i,h.dtype,h.values)}var A4={kernelName:pw,backendName:"cpu",kernelFunc:_ct};function Act(e,t){let r=0,n=e.length,o=0;for(;r<n;)o=Math.floor((r+n)/2),e[o]<t?r=o+1:n=o;return n}function Dct(e,t){let r=0,n=e.length,o=0;for(;r<n;)o=Math.floor((r+n)/2),e[o]<=t?r=o+1:n=o;return n}function D4(e,t,r,n,o,s){let i=w.getArrayFromDType("int32",r*o);for(let a=0;a<r;++a){let l=e.slice(a*n,(a+1)*n),u=a*o;for(let c=0;c<o;++c)i[u+c]=s==="left"?Act(l,t[c+u]):Dct(l,t[c+u])}return i}function Rct(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:o,values:s}=t,{side:i}=n,a=r.data.get(o.dataId).values,l=r.data.get(s.dataId).values,u=D4(a,l,o.shape[0],o.shape[1],s.shape[1],i);return r.makeTensorInfo(s.shape,"int32",u)}var R4={kernelName:fw,backendName:"cpu",kernelFunc:Rct};function $ct(e){let{inputs:t,backend:r}=e,{condition:n,t:o,e:s}=t;J([n,o,s],"select");let i=n.shape.length,a=r.data.get(n.dataId).values,l=r.data.get(o.dataId).values,u=r.data.get(s.dataId).values,c=or(o.dtype,s.dtype),p=w.makeZerosTypedArray(w.sizeFromShape(o.shape),c),f=0,m=i===0||i>1||o.shape.length===1?1:w.sizeFromShape(o.shape.slice(1));for(let d=0;d<a.length;d++)for(let h=0;h<m;h++)a[d]===1?p[f++]=l[d]:p[f++]=u[d];return r.makeTensorInfo(o.shape,c,p)}var $4={kernelName:zu,backendName:"cpu",kernelFunc:$ct};var Oct=T.SELU_SCALEALPHA,Fct=T.SELU_SCALE,Pct=Rt(Va,e=>e>=0?Fct*e:Oct*(Math.exp(e)-1)),O4={kernelName:Va,backendName:"cpu",kernelFunc:Pct};var Lct=Rt(Ua,e=>e<0?-1:e>0?1:0),F4={kernelName:Ua,backendName:"cpu",kernelFunc:Lct};var Mct=Rt(Wa,e=>Math.sin(e)),P4={kernelName:Wa,backendName:"cpu",kernelFunc:Mct};var zct=Rt(Ga,e=>Math.sinh(e)),L4={kernelName:Ga,backendName:"cpu",kernelFunc:zct};var Bct=11920928955078125e-23,M4=Math.log(Bct)+2,Vct=Rt(qa,e=>{let t=e>-M4,r=e<M4,n=Math.exp(e),o;return r?o=n:t?o=e:o=Math.log(1+n),o}),z4={kernelName:qa,backendName:"cpu",kernelFunc:Vct};function Wct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockShape:s,paddings:i}=n;J([o],"spaceToBatchND");let a=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let S=1+s.length;S<o.shape.length;++S)l.push([0,0]);let u=LC.kernelFunc({inputs:{x:o},backend:r,attrs:{paddings:l,constantValue:0}}),c=T.getReshaped(u.shape,s,a,!1),p=T.getPermuted(c.length,s.length,!1),f=T.getReshapedPermuted(u.shape,s,a,!1),h=jt({inputs:{x:u},backend:r,attrs:{shape:c}}),y=Pe({inputs:{x:h},backend:r,attrs:{perm:p}}),C=jt({inputs:{x:y},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(y),C}var B4={kernelName:Wu,backendName:"cpu",kernelFunc:Wct};function Gct(e){let{inputs:t,backend:r}=e,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=r.data.get(n.dataId).values,l=r.data.get(o.dataId).values,u=r.data.get(s.dataId).values,c=r.data.get(i.dataId).values[0],[p,f,m,d,h]=TC(a,n.shape,n.dtype,l,o.dtype,u,c);return[r.makeTensorInfo(f,n.dtype,p),r.makeTensorInfo([f[0]],o.dtype,m),r.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(x=>Number(x)))),r.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var V4={kernelName:mw,backendName:"cpu",kernelFunc:Gct};function Uct(e){let{inputs:t,backend:r}=e,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(r.data.get(o.dataId).values),a=r.data.get(n.dataId).values,l=Array.from(r.data.get(s.dataId).values),[u,c,p]=NC(a,n.shape,n.dtype,i,l);return[r.makeTensorInfo(c,n.dtype,u),r.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var W4={kernelName:dw,backendName:"cpu",kernelFunc:Uct};function Hct(e){let{inputs:t,backend:r}=e,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=r.data.get(n.dataId).values,a=r.data.get(o.dataId).values,l=r.data.get(s.dataId).values,[u,c]=lh(i,n.shape,n.dtype,a,l,!0);return r.makeTensorInfo(c,n.dtype,u)}var G4={kernelName:hw,backendName:"cpu",kernelFunc:Hct};function qct(e){let{inputs:t,backend:r}=e,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=r.data.get(n.dataId).values,a=r.data.get(o.dataId).values,l=r.data.get(s.dataId).values,[u,c]=lh(i,n.shape,n.dtype,a,l);return r.makeTensorInfo(c,n.dtype,u)}var U4={kernelName:gw,backendName:"cpu",kernelFunc:qct};function jct(e){let{inputs:t,backend:r,attrs:n}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=T.calculateShapes(s,o,a),m=!1,d=r.bufferSync(o),h;switch(s.dtype){case"bool":{let x=r.bufferSync(s),g=Boolean(r.data.get(i.dataId).values[0]);h=vl(d,x,a,f,c,u,l,p,g,m);break}case"float32":{let x=r.bufferSync(s),g=r.data.get(i.dataId).values[0];h=vl(d,x,a,f,c,u,l,p,g,m);break}case"int32":{let x=r.bufferSync(s),g=r.data.get(i.dataId).values[0];h=vl(d,x,a,f,c,u,l,p,g,m);break}case"string":{let x=r.bufferSync(s),g=w.decodeString(r.data.get(i.dataId).values[0]);h=vl(d,x,a,f,c,u,l,p,g,m);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return r.makeTensorInfo(a,h.dtype,h.values)}var H4={kernelName:xw,backendName:"cpu",kernelFunc:jct};function Kct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=w.parseAxisParam(i,o.shape)[0],l=T.prepareSplitSize(o,s,a),u=new Array(o.shape.length).fill(0),c=o.shape.slice();return l.map(p=>{let f=[...c];f[a]=p;let m=ys({inputs:{x:o},backend:r,attrs:{begin:u,size:f}});return u[a]+=p,m})}var q4={kernelName:Gu,backendName:"cpu",kernelFunc:Kct};var j4={kernelName:Km,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:r}=e,n=t;J(r,"square");let o=n.data.get(r.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let l=o[a];s[a]=l*l}return{dataId:n.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var Xct=Rt(Za,(e,t)=>{let r=t;return isNaN(e)?NaN:e>0?1:r.alpha}),K4={kernelName:Za,backendName:"cpu",kernelFunc:Xct};function Yct(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=n;J(o,"stridedSlice");let{finalShapeSparse:m,finalShape:d,isIdentity:h,sliceDim0:x,isSimpleSlice:g,begin:y,end:b,strides:v}=Er.sliceInfo(o.shape,s,i,a,l,u,c,p,f),C;if(h)C=jt({inputs:{x:o},backend:r,attrs:{shape:d}});else if(x||g){w.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let S=Er.computeOutShape(y,b,v),k=ys({inputs:{x:o},backend:r,attrs:{begin:y,size:S}});C=jt({inputs:{x:k},backend:r,attrs:{shape:d}}),r.disposeIntermediateTensorInfo(k)}else{let S=r.bufferSync(o),k=IC(m,S,v,y);C=r.makeTensorInfo(d,k.dtype,k.values)}return C}var X4={kernelName:Xm,backendName:"cpu",kernelFunc:Yct};function Qct(e){let{inputs:t,backend:r,attrs:n}=e,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=n,{data:c,dataSplits:p}=t,f=r.data.get(c.dataId).values,m=r.data.get(p.dataId).values,[d,h]=EC(f,m,o,s,i,a,l,u);return[r.makeTensorInfo([d.length],"string",d),r.makeTensorInfo(p.shape,"int32",h)]}var Y4={kernelName:yw,backendName:"cpu",kernelFunc:Qct};function Zct(e){let{inputs:t,backend:r,attrs:n}=e,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=r.data.get(s.dataId).values,l=r.data.get(i.dataId).values[0],[u,c,p]=_C(a,l,o),f=c.length;return[r.makeTensorInfo([f,2],"int32",u),r.makeTensorInfo([f],"string",c),r.makeTensorInfo([2],"int32",new Int32Array(p))]}var Q4={kernelName:bw,backendName:"cpu",kernelFunc:Zct};function Jct(e){let{inputs:t,backend:r,attrs:n}=e,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=r.data.get(s.dataId).values,a=AC(i,o);return r.makeTensorInfo(s.shape,"int32",a)}var Z4={kernelName:vw,backendName:"cpu",kernelFunc:Jct};var tpt=Rt(Ya,e=>Math.tan(e)),J4={kernelName:Ya,backendName:"cpu",kernelFunc:tpt};var ept=Rt(Qa,e=>Math.tanh(e)),tG={kernelName:Qa,backendName:"cpu",kernelFunc:ept};function rpt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{reps:s}=n;J(o,"tile");let i=DC(r.bufferSync(o),s);return r.makeTensorInfo(i.shape,i.dtype,i.values)}var eG={kernelName:bi,backendName:"cpu",kernelFunc:rpt};function npt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{k:s,sorted:i}=n;J(o,"topk");let a=r.data.get(o.dataId).values,[l,u]=RC(a,o.shape,o.dtype,s,i);return[r.makeTensorInfo(l.shape,l.dtype,l.values),r.makeTensorInfo(u.shape,u.dtype,u.values)]}var rG={kernelName:Ym,backendName:"cpu",kernelFunc:npt};function opt(e){let{inputs:t,attrs:r,backend:n}=e,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,p,f,m]=o.shape,[d,h]=u!=null?u:[p,f],x=[c,d,h,m],g=w.computeStrides(o.shape),y=g[0],b=g[1],v=g[2],C=w.computeStrides(x),S=C[0],k=C[1],I=C[2],D=w.getTypedArrayFromDType(o.dtype,w.sizeFromShape(x));D.fill(l);let R=n.data.get(o.dataId).values,M=n.data.get(s.dataId).values;for(let j=0;j<c;++j){let K=s.shape[0]===1?M:M.subarray(j*8,j*8+8);for(let W=0;W<d;++W)for(let q=0;q<h;++q)for(let X=0;X<m;++X){let Q,Y=K[6]*q+K[7]*W+1;if(Y===0)continue;let nt=(K[0]*q+K[1]*W+K[2])/Y,rt=(K[3]*q+K[4]*W+K[5])/Y,at=nG(nt,f,a),lt=nG(rt,p,a);switch(i){case"nearest":Q=upt(R,p,f,y,b,v,j,lt,at,X,l);break;case"bilinear":Q=cpt(R,p,f,y,b,v,j,lt,at,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ut=j*S+W*k+q*I+X;D[ut]=Q}return n.makeTensorInfo(x,o.dtype,D)}return{dataId:n.write(D,x,o.dtype),shape:o.shape,dtype:o.dtype}}var oG={kernelName:Qm,backendName:"cpu",kernelFunc:opt};function nG(e,t,r){switch(r){case"reflect":return spt(e,t);case"wrap":return ipt(e,t);case"nearest":return lpt(e,t);case"constant":default:return apt(e,t)}}function spt(e,t){let r=e;if(r<0)if(t<=1)r=0;else{let n=2*t;r<n&&(r=n*Math.trunc(-r/n)+r),r=r<-t?r+n:-r-1}else if(r>t-1)if(t<=1)r=0;else{let n=2*t;r-=n*Math.trunc(r/n),r>=t&&(r=n-r-1)}return w.clamp(0,r,t-1)}function ipt(e,t){let r=e;if(r<0)if(t<=1)r=0;else{let n=t-1;r+=t*(Math.trunc(-r/n)+1)}else if(r>t-1)if(t<=1)r=0;else{let n=t-1;r-=t*Math.trunc(r/n)}return w.clamp(0,r,t-1)}function apt(e,t){return e}function lpt(e,t){return w.clamp(0,e,t-1)}function hb(e,t,r,n,o,s,i,a,l,u,c){let p=i*n+a*o+l*s+u;return 0<=a&&a<t&&0<=l&&l<r?e[p]:c}function upt(e,t,r,n,o,s,i,a,l,u,c){let p=Math.round(a),f=Math.round(l);return hb(e,t,r,n,o,s,i,p,f,u,c)}function cpt(e,t,r,n,o,s,i,a,l,u,c){let p=Math.floor(a),f=Math.floor(l),m=p+1,d=f+1,h=(d-l)*hb(e,t,r,n,o,s,i,p,f,u,c)+(l-f)*hb(e,t,r,n,o,s,i,p,d,u,c),x=(d-l)*hb(e,t,r,n,o,s,i,m,f,u,c)+(l-f)*hb(e,t,r,n,o,s,i,m,d,u,c);return(m-a)*h+(a-p)*x}function ppt(e){let{inputs:t,attrs:r,backend:n}=e,{axis:o}=r,{x:s}=t;J(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:u}=$C(i,o,s.shape,s.dtype);return[n.makeTensorInfo(l,s.dtype,a),n.makeTensorInfo([u.length],"int32",u)]}var sG={kernelName:Zm,backendName:"cpu",kernelFunc:ppt};function fpt(e){let{inputs:t,backend:r,attrs:n}=e,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],l=new Array(i-1),u=0;for(let m=0;m<i;m++)m!==s&&(l[u++]=o.shape[m]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let f=new Array(a);for(let m=0;m<f.length;m++){c[s]=m;let d=ys({inputs:{x:o},backend:r,attrs:{begin:c,size:p}});f[m]=jt({inputs:{x:d},backend:r,attrs:{shape:l}}),r.disposeIntermediateTensorInfo(d)}return f}var iG={kernelName:Hu,backendName:"cpu",kernelFunc:fpt};function mpt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,segmentIds:s}=t,{numSegments:i}=n;J(o,"unsortedSegmentSum");let a=o.shape.length,l=s.shape.length,u=[],c=[],p=a-l,f=s;for(let d=0;d<p;++d){let h=ch({inputs:{input:f},backend:r,attrs:{dim:d+1}});f=h,c.push(h)}for(let d=0;d<i;++d){let h=w.createScalarValue(d,"int32"),x=r.makeTensorInfo([],"int32",h),g=f2({inputs:{a:x,b:f},backend:r}),y=hs({inputs:{x:g},backend:r,attrs:{dtype:"float32"}}),b=Zp({inputs:{a:y,b:o},backend:r}),v=wl({inputs:{x:b},backend:r,attrs:{axis:0,keepDims:!1}});u.push(v),c.push(x),c.push(g),c.push(y),c.push(b),c.push(v)}let m=H2({inputs:u,backend:r,attrs:{axis:0}});return c.forEach(d=>r.disposeIntermediateTensorInfo(d)),m}var aG={kernelName:qu,backendName:"cpu",kernelFunc:mpt};var dpt=[$V,UB,OV,FV,XB,PV,LV,MV,zV,BV,VV,WV,GV,UV,HV,jV,KV,XV,YV,RV,QV,ZV,JV,tW,KB,YB,eW,HB,rW,oW,sW,iW,aW,lW,uW,cW,pW,fW,mW,dW,hW,gW,xW,yW,bW,vW,wW,CW,SW,kW,NW,NV,IW,QB,EW,ZB,_W,JB,AW,DW,RW,tV,$W,OW,FW,PW,LW,eV,rV,qB,MW,nW,zW,BW,VW,IV,nV,oV,WW,sV,GW,UW,HW,qW,jW,KW,XW,iV,YW,QW,ZW,JW,e4,r4,n4,aV,o4,s4,l4,lV,uV,u4,c4,p4,cV,f4,h4,g4,LC,x4,EV,fV,y4,b4,v4,w4,jB,fb,C4,_V,AV,DV,S4,k4,T4,N4,I4,E4,_4,xV,A4,R4,$4,O4,bV,F4,P4,L4,vV,i4,z4,B4,V4,W4,G4,U4,H4,q4,CV,j4,SV,K4,X4,Y4,Q4,Z4,kV,TW,J4,tG,eG,rG,oG,pV,sG,iG,aG,m4];for(let e of dpt)Cw(e);var tf={},MC={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function lG(e,t){tf[e]=t}function xo(e,t){if(!(e in tf)||t!=null){let n=gpt(e,t);if(n!==null)tf[e]=n;else return console.log("Could not get context for WebGL version",e),null}let r=tf[e];return r==null||r.isContextLost()?(delete tf[e],xo(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),tf[e])}function hpt(e){if(typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function gpt(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let r=t==null?hpt(e):t;return r.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete tf[e]},!1),B().getBool("SOFTWARE_WEBGL_ENABLED")&&(MC.failIfMajorPerformanceCaveat=!1),e===1?r.getContext("webgl",MC)||r.getContext("experimental-webgl",MC):r.getContext("webgl2",MC)}var mc;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(mc||(mc={}));var nn;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(nn||(nn={}));var Wr;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Wr||(Wr={}));function ef(e,t){return[t,e]}function uG(e,t){return e*t}function gb(e){let t=w.sizeFromShape(e),r=Math.ceil(t/4);return w.sizeToSquarishShape(r)}function Pi(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function cG(e,t){let[r,n]=Pi(e,t);return r*n*4}function xb(e,t){let r=e,n,o,s,i,a,l,u,c,p,f;return B().getNumber("WEBGL_VERSION")===2?(n=r.R32F,o=r.R16F,s=r.RGBA16F,i=r.RGBA32F,a=r.RED,u=4,c=1,p=r.HALF_FLOAT,f=r.FLOAT,l=r.RGBA8):(n=e.RGBA,o=e.RGBA,s=e.RGBA,i=r.RGBA,a=e.RGBA,u=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,f=e.FLOAT,l=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:f}}function xt(e,t){let r=t();return B().getBool("DEBUG")&&xpt(e),r}function xpt(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+vpt(e,t))}var ypt=596e-10,bpt=65504;function pG(e){return!!(B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||ypt<Math.abs(e)&&Math.abs(e)<bpt)}function vpt(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function yb(e,t){return Cl(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function fG(e,t){let r=Cl(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(xt(e,()=>e.shaderSource(r,t)),xt(e,()=>e.compileShader(r)),e.getShaderParameter(r,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function mG(e,t){let r=Cl(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(xt(e,()=>e.shaderSource(r,t)),xt(e,()=>e.compileShader(r)),B().get("ENGINE_COMPILE_ONLY"))return r;if(e.getShaderParameter(r,e.COMPILE_STATUS)===!1)throw Y2(t,e.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var wpt=/ERROR: [0-9]+:([0-9]+):/g;function Y2(e,t){let r=wpt.exec(t);if(r==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let n=+r[1],o=e.split(`
`),s=o.length.toString().length+2,i=o.map((p,f)=>w.rightPad((f+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let l=i.slice(0,n-1),u=i.slice(n-1,n),c=i.slice(n);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function dG(e){return Cl(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function hG(e,t){if(xt(e,()=>e.linkProgram(t)),!B().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function BC(e,t){if(xt(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function gG(e,t){let r=Cl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return xt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),xt(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function xG(e,t){let r=Cl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return xt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)),xt(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function yG(e){return Cl(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function bG(e,t){let r=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>r||t>r){let n=`[${e}x${t}]`,o=`[${r}x${r}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function vG(e){return Cl(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Q2(e,t,r,n,o,s,i){let a=e.getAttribLocation(t,r);return a===-1?!1:(xt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),xt(e,()=>e.vertexAttribPointer(a,o,e.FLOAT,!1,s,i)),xt(e,()=>e.enableVertexAttribArray(a)),!0)}function Cpt(e,t,r){kpt(e,r),xt(e,()=>e.activeTexture(e.TEXTURE0+r)),xt(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function wG(e,t,r){return Cl(e,()=>e.getUniformLocation(t,r),'uniform "'+r+'" not present in program.')}function CG(e,t,r){return e.getUniformLocation(t,r)}function SG(e,t,r,n){xt(e,()=>Cpt(e,t,n)),xt(e,()=>e.uniform1i(r,n))}function VC(e,t,r){xt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),xt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Z2(e,t){xt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),xt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function bb(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Spt(e,t))}function Spt(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Cl(e,t,r){let n=xt(e,()=>t());if(n==null)throw new Error(r);return n}function kpt(e,t){let r=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+e.TEXTURE0;if(n<e.TEXTURE0||n>r){let o=`[gl.TEXTURE0, gl.TEXTURE${r}]`;throw new Error(`textureUnit must be in ${o}.`)}}function dc(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function hc(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function vb(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[dc(e),...hc(e)]),t}function kG(e,t=!1){let r=B().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=B().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&B().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=r/2),t&&(r=r*2,n=n*2,e=e.map((a,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let o=w.sizeFromShape(e),s=null;e.length<=1&&o<=r?s=[1,o]:e.length===2&&e[0]<=r&&e[1]<=r?s=e:e.length===3&&e[0]*e[1]<=r&&e[2]<=r?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=r&&e[1]*e[2]<=r?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=r&&e[3]<=r?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=r&&e[1]*e[2]*e[3]<=r&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>n&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let a=dc(e),l=2,u=2;e.length&&([l,u]=hc(e)),o=a*(l/2)*(u/2),s=w.sizeToSquarishShape(o).map(c=>c*2)}else s=w.sizeToSquarishShape(o);return s}function zC(e){return e%2===0}function rf(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let r=e.slice(-1)[0],n=t.slice(-1)[0];if(r===n||zC(r)&&zC(n)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&zC(e[0])&&zC(t[0])}var j2,K2;function TG(e){if(j2==null){let t=xo(e);j2=t.getParameter(t.MAX_TEXTURE_SIZE)}return j2}function NG(e){if(K2==null){let t=xo(e);K2=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,K2)}function IG(e){if(e===0)return 0;let t,r=xo(e);return Fo(r,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Fo(r,"EXT_disjoint_timer_query")?t=1:t=0,t}function Fo(e,t){return e.getExtension(t)!=null}function J2(e){try{if(xo(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function EG(e){if(e===0)return!1;let t=xo(e);if(e===1){if(!Fo(t,"OES_texture_float"))return!1}else if(!Fo(t,"EXT_color_buffer_float"))return!1;return X2(t)}function _G(e){if(e===0)return!1;let t=xo(e);if(e===1){if(!Fo(t,"OES_texture_float")||!Fo(t,"WEBGL_color_buffer_float"))return!1}else{if(Fo(t,"EXT_color_buffer_float"))return X2(t);let n="EXT_color_buffer_half_float";if(Fo(t,n)){let o=t.getExtension(n);return Tpt(t,o)}return!1}return X2(t)}function X2(e){let t=xb(e),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let n=1,o=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),i}function Tpt(e,t){let r=xb(e,t),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let o=1,s=1;e.texImage2D(e.TEXTURE_2D,0,r.internalFormatHalfFloat,o,s,0,r.textureFormatFloat,r.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(i),a}function AG(e){return e!==2?!1:xo(e).fenceSync!=null}function Li(e,t){Array.isArray(e)||(e=[e]),e.forEach(r=>{r!=null&&w.assert(r.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Dt=B();Dt.registerFlag("HAS_WEBGL",()=>Dt.getNumber("WEBGL_VERSION")>0);Dt.registerFlag("WEBGL_VERSION",()=>J2(2)?2:J2(1)?1:0);Dt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Dt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Dt.get("WEBGL_VERSION")===2);Dt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Dt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Dt.registerFlag("WEBGL_PACK",()=>Dt.getBool("HAS_WEBGL"));Dt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_CLIP",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_PACK_REDUCE",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_CONV_IM2COL",()=>Dt.getBool("WEBGL_PACK"));Dt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>TG(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>NG(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Dt.getNumber("WEBGL_VERSION");return e===0?0:IG(e)});Dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Dt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yu.isMobile());Dt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>EG(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Dt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Dt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Dt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>_G(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>AG(Dt.getNumber("WEBGL_VERSION")));Dt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Dt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Dt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Dt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yu.isMobile()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Dt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Dt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Dt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Dt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Dt.registerFlag("WEBGL_EXP_CONV",()=>!1);Dt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Dt.getBool("IS_TEST"));Dt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Dt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Dt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Dt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Le(){let e,t,r,n,o,s,i,a,l,u;return B().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",r="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=B().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",r="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:r,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Ks(e,t,r="index"){let n=w.computeStrides(t);return n.map((o,s)=>{let i=`int ${e[s]} = ${r} / ${o}`,a=s===n.length-1?`int ${e[s+1]} = ${r} - ${e[s]} * ${o}`:`index -= ${e[s]} * ${o}`;return`${i}; ${a};`}).join("")}function nf(e,t,r="index"){let n=w.computeStrides(t);return n.map((o,s)=>{let i=`int ${e[s]} = ${r} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${e[s+1]} = ${r} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Npt(e,t){let r=e.length,n=e.map(s=>`${t}[${s}]`),o=new Array(r-1);o[r-2]=n[r-1];for(let s=r-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function DG(e,t,r="index"){let n=e.map((s,i)=>i),o=Npt(n,t);return o.map((s,i)=>{let a=`int ${e[i]} = ${r} / ${o[i]}`,l=i===o.length-1?`int ${e[i+1]} = ${r} - ${e[i]} * ${o[i]}`:`index -= ${e[i]} * ${o[i]}`;return`${a}; ${l};`}).join("")}function ph(e){let t=w.computeStrides(e).map(r=>r.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function fh(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var GC=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:RG}=T;function $G(e,t,r){let n=[];if(e.forEach(m=>{let d=w.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?n.push(`uniform float ${m.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${m.name};`),n.push(`uniform int offset${m.name};`)),r.enableShapeUniforms){let{uniformShape:h}=UC(r.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${m.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${m.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${m.name}TexShape;`)}}),r.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}r.customUniforms&&r.customUniforms.forEach(m=>{n.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});let o=n.join(`
`),s=e.map(m=>Ipt(m,t,r.packedInputs,r.enableShapeUniforms)).join(`
`),i=t.texShape,a=Le(),l=Apt(a),u,c,p=$pt(a);return t.isPacked?(u=Ept(t.logicalShape,i,r.enableShapeUniforms),c=Rpt(a)):(u=_pt(t.logicalShape,i,r.enableShapeUniforms),c=Dpt(a)),r.packedInputs&&(p+=Lpt),[p,l,c,o,u,s,r.userCode].join(`
`)}function dh(e,t=!1){let r=e.shapeInfo.logicalShape;switch(r.length){case 0:return Xpt(e,t);case 1:return Qpt(e,t);case 2:return Jpt(e,t);case 3:return eft(e,t);case 4:return nft(e,t);case 5:return oft(e);case 6:return sft(e);default:throw new Error(`${r.length}-D input sampling is not yet supported`)}}function OG(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Kpt(e);case 1:return Ypt(e,t);case 2:return Zpt(e,t);case 3:return tft(e,t);default:return rft(e,t)}}function Ipt(e,t,r=!1,n){let o="";r?o+=OG(e,n):o+=dh(e,n);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(r?o+=ift(e,t):o+=aft(e,t)),o}function Ept(e,t,r){switch(e.length){case 0:return FG();case 1:return Mpt(e,t,r);case 2:return qpt(e,t,r);case 3:return Bpt(e,t,r);default:return Wpt(e,t,r)}}function _pt(e,t,r){switch(e.length){case 0:return FG();case 1:return zpt(e,t,r);case 2:return jpt(e,t,r);case 3:return Vpt(e,t,r);case 4:return Gpt(e,t,r);case 5:return Upt(e,t);case 6:return Hpt(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Apt(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Dpt(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Rpt(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function $pt(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Opt}
    ${Fpt}
    ${Ppt}
  `}var Opt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Fpt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ppt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Lpt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function FG(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Mpt(e,t,r){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?r?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?r?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:r?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function zpt(e,t,r){return t[0]===1?r?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?r?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:r?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Bpt(e,t,r){if(r)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[2]/2),s=o*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Vpt(e,t,r){if(r)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${nf(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let n=Ks(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Wpt(e,t,r){if(r)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[e.length-1]/2),s=o*Math.ceil(e[e.length-2]/2),i=s,a="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${e.length}(${l});
    }
  `}function Gpt(e,t,r){if(r)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${nf(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let n=Ks(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function Upt(e,t){let r=Ks(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${r}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Hpt(e,t){let r=Ks(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${r}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function qpt(e,t,r){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return r?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(e[1]/2);return r?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function jpt(e,t,r){return w.arraysEqual(e,t)?r?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?r?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?r?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:r?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function of(e){return`offset${e}`}function Kpt(e){let t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=Le();return`
    vec4 ${r}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function Xpt(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${r};}`;let[o,s]=e.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${r}, halfCR);
      }
    `;let i=of(r);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], ${i});
      return sampleTexture(${r}, uv);
    }
  `;let[a,l]=e.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${r}, uv);
    }
  `}function Ypt(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,s=Le();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${r}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${r}, uv);
    }
  `}function Qpt(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${hh(e)}
      }
    `;let o=e.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${r}, halfCR);
      }
    `;let a=of(r);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${r}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${r}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${a});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${r}, uv);
    }
  `}function Zpt(e,t){let r=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=s[0],a=s[1],l=Le();if(s!=null&&w.arraysEqual(r,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${l.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(r[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `}function Jpt(e,t){let r=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(r,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let f=s[0],m=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=w.squeezeShape(r),l=i;if(l.length<r.length){let f=gh(e,l),m=["row","col"];return`
      ${dh(f,t)}
      float ${o}(int row, int col) {
        return ${o}(${xh(m,a)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${r[1]}, 1)));
        ${hh(e)}
      }
    `;let u=s[0],c=s[1],p=of(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${n}, uv);
    }
  `:u===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${r[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function tft(e,t){let r=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(r[0]===1){let f=r.slice(1),m=[1,2],d=gh(e,f),h=["b","row","col"];return`
        ${OG(d,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${xh(h,m)});
        }
      `}let a=Le();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(r[2]/2),p=c*Math.ceil(r[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function eft(e,t){let r=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r[1]*r[2],i=r[2],{newShape:a,keptDims:l}=w.squeezeShape(r),u=a;if(u.length<r.length){let h=gh(e,u),x=["row","col","depth"];return`
        ${dh(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${xh(x,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${hh(e)}
      }
    `;let c=e.shapeInfo.texShape,p=c[0],f=c[1],m=e.shapeInfo.flatOffset;if(f===s&&m==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(f===i&&m==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${r[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=of(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${f}, index);
        return sampleTexture(${n}, uv);
      }
  `}function rft(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=Le();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${r}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${r}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${r}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,a=e.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],p=Math.ceil(s[i-1]/2),f=p*Math.ceil(s[i-2]/2),m="int b, int row, int col",d=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)m=`int b${h}, `+m,f*=s[i-h-1],d=`b${h} * ${f} + `+d;return`
    vec4 ${n}(${m}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${o.texture2D}(${r}, uv);
    }
  `}function nft(e,t){let r=e.shapeInfo.logicalShape,n=e.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r[3],i=r[2]*s,a=r[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(r);if(l.length<r.length){let y=gh(e,l),b=["row","col","depth","depth2"];return`
      ${dh(y,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${xh(b,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${hh(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,x=`int stride0 = ${n}Shape[1] * stride1;`;if(m===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r[1]*r[2]}, ${r[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=of(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${g});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${m}, index + ${g});
      return sampleTexture(${n}, uv);
    }
  `}function oft(e){let t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(t);if(l.length<t.length){let h=gh(e,l),x=["row","col","depth","depth2","depth3"];return`
      ${dh(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${xh(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${hh(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];if(m===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(m===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let d=of(r);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${r}, uv);
    }
  `}function sft(e){let t=e.shapeInfo.logicalShape,r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),{newShape:o,keptDims:s}=w.squeezeShape(t);if(o.length<t.length){let x=gh(e,o),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${dh(x)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${xh(g,s)});
      }
    `}let i=t[5],a=t[4]*i,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${hh(e)}
      }
    `;let p=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,m=f[0],d=f[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${r}, uv);
      }
    `;let h=of(r);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${m}, ${d}, index);
      return sampleTexture(${r}, uv);
    }
  `}function hh(e){let t=e.name,r=w.sizeFromShape(e.shapeInfo.logicalShape);return r<2?`return ${t};`:`
    for (int i = 0; i < ${r}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function ift(e,t){let r=e.name,n=r.charAt(0).toUpperCase()+r.slice(1),o="get"+n+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=RG(e.shapeInfo.logicalShape,t.logicalShape),l=zt(i),u=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(y=>`coords.${p[y+u]} = 0;`).join(`
`);let f="";i<2&&s>0?f="coords":f=e.shapeInfo.logicalShape.map((y,b)=>`coords.${p[b+u]}`).join(", ");let m="return outputValue;",h=w.sizeFromShape(e.shapeInfo.logicalShape)===1,g=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!g)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!g)i===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(a.length){let y=s-2,b=s-1;a.indexOf(y)>-1&&a.indexOf(b)>-1?m="return vec4(outputValue.x);":a.indexOf(y)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${f});
      ${m}
    }
  `}function aft(e,t){let r=e.name,n=r.charAt(0).toUpperCase()+r.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${r}, resultUV);
      }
    `;let u=zt(l),c=RG(e.shapeInfo.logicalShape,t.logicalShape),p=l-a,f,m=["x","y","z","w","u","v"];a===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(h=>`coords.${m[h+p]} = 0;`).join(`
`);let d="";return l<2&&a>0?d="coords":d=e.shapeInfo.logicalShape.map((h,x)=>`coords.${m[x+p]}`).join(", "),`
    float ${o}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${n}(${d});
    }
  `}function zt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function UC(e,t,r){let{newShape:n,keptDims:o}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,a=i?t.slice(1):n,l=!e&&s>1&&!w.arraysEqual(t,r)&&n.length<s||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:o}}function gh(e,t){let r=JSON.parse(JSON.stringify(e));return r.shapeInfo.logicalShape=t,r}function xh(e,t){return t.map(r=>e[r]).join(", ")}function LG(e,t,r,n){let o=r.map((c,p)=>{let f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:f}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=$G(o,i,t),l=mG(e.gl,a),u=e.createProgram(l);return B().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},tA(e,t,u))}function tA(e,t,r){let n={},o={},s={},i=[],a,l,u,c=null,p=null;p=e.getUniformLocation(r,"NAN",!1),B().getNumber("WEBGL_VERSION")===1&&(c=e.getUniformLocation(r,"INFINITY",!1));let f=!1;for(let m=0;m<t.variableNames.length;m++){let d=t.variableNames[m];n[d]=e.getUniformLocation(r,d,f),n[`offset${d}`]=e.getUniformLocation(r,`offset${d}`,f),t.enableShapeUniforms&&(o[`${d}Shape`]=e.getUniformLocation(r,`${d}Shape`,f),s[`${d}TexShape`]=e.getUniformLocation(r,`${d}TexShape`,f))}return t.enableShapeUniforms&&(a=e.getUniformLocation(r,"outShape",f),u=e.getUniformLocation(r,"outShapeStrides",f),l=e.getUniformLocation(r,"outTexShape",f)),t.customUniforms&&t.customUniforms.forEach((m,d)=>{i[d]=e.getUniformLocation(r,m.name,f)}),{uniformLocations:n,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}}function PG(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((r,n)=>{let o=r.logicalShape,s=t[n],i=s.shape;if(!w.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(r.isUniform&&s.isUniform)return;let a=r.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function MG(e,t,r,n,o){t.program.enableShapeUniforms||(PG(t.inShapeInfos,r),PG([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),B().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),r.forEach((l,u)=>{let c=t.program.variableNames[u],p=t.uniformLocations[c],f=t.uniformLocations[`offset${c}`],m=t.inShapesLocations[`${c}Shape`],d=t.inTexShapesLocations[`${c}TexShape`];if(m){let{uniformShape:h}=UC(t.program.packedInputs,l.shape,l.texData.texShape);switch(h.length){case 1:e.gl.uniform1iv(m,new Int32Array(h));break;case 2:e.gl.uniform2iv(m,new Int32Array(h));break;case 3:e.gl.uniform3iv(m,new Int32Array(h));break;case 4:e.gl.uniform4iv(m,new Int32Array(h));break;default:break}}if(d&&e.gl.uniform2i(d,l.texData.texShape[0],l.texData.texShape[1]),p!=null){if(l.isUniform){if(w.sizeFromShape(l.shape)<2)e.gl.uniform1f(p,l.uniformValues[0]);else{let h=l.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),e.gl.uniform1fv(p,h)}return}l.texData.slice!=null&&f!=null&&e.gl.uniform1i(f,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture.texture,p,u)}});let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:e.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:e.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:e.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:e.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let l=w.computeStrides(n.shape);switch(n.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((l,u)=>{let c=t.customUniformLocations[u],p=o[u];if(l.type==="float")e.gl.uniform1fv(c,p);else if(l.type==="vec2")e.gl.uniform2fv(c,p);else if(l.type==="vec3")e.gl.uniform3fv(c,p);else if(l.type==="vec4")e.gl.uniform4fv(c,p);else if(l.type==="int")e.gl.uniform1iv(c,p);else if(l.type==="ivec2")e.gl.uniform2iv(c,p);else if(l.type==="ivec3")e.gl.uniform3iv(c,p);else if(l.type==="ivec4")e.gl.uniform4iv(c,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}),e.executeProgram()}function zG(e,t,r){let n="";t.concat(r).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=UC(e.packedInputs,i.shape,l),f="",m="",d="";if(c.length===1&&e.packedInputs){let C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${C[0]>1}_${C[1]>1}`}else if(c.length===2&&!e.packedInputs)m=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let C=w.computeStrides(c);d=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}let h=i.shape.length,x=c.length===2&&w.arraysEqual(i.shape,l),g=w.sizeFromShape(i.shape)===1,y=T.getBroadcastDims(i.shape,r.shape),b=!e.packedInputs&&h===r.shape.length&&w.arraysEqual(l,r.texData.texShape),v=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;n+=`${h}_${b}_${u?p:""}_${c.length}_${g}_${y}_${x}_${f}_${m}_${d}_${v}_${a}`}else{let l=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${l}_${a}`}});let o=e.userCode,s=e.constructor.name;return s+="_"+n+"_"+o+`${B().getNumber("WEBGL_VERSION")}`,s}function he(e){return B().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var HC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=mc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Le();this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?nf(["r","c","d"],t):Ks(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${r.output} = result;
      }
    `}};var qC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=mc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Le();this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?nf(["r","c","d"],t):Ks(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${r.output} = result;
      }
    `}};var jC=class{constructor(t){this.variableNames=["A"],this.outTexUsage=nn.DOWNLOAD;let r=Le();this.outputShape=t,this.userCode=`
      ${GC}

      void main() {
        float x = getAAtOutCoords();
        ${r.output} = encode_float(x);
      }
    `}};var KC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=nn.DOWNLOAD;let r=Le();this.outputShape=t,this.userCode=`
      ${GC}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${r.output} = encode_float(x);
      }
    `}};var cft={R:0,G:1,B:2,A:3},wb=class{constructor(t,r=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=Le();this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length);let s="result";r&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<n.length;a++){let l=n[a];i+=`
          if(offset == ${a}) {
            result = values[${cft[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?fh():ph(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var XC=class{constructor(t,r=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Le();this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length);let o="",s="result";r&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let l=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?fh():ph(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};function BG(e){let t=Le(),r=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return fG(e,r)}function VG(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return gG(e,t)}function WG(e){let t=new Uint16Array([0,1,2,2,1,3]);return xG(e,t)}function Cb(e,t,r,n,o,s){bG(t,r);let i=yG(e),a=e.TEXTURE_2D;return xt(e,()=>e.bindTexture(a,i)),xt(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),xt(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),xt(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),xt(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),B().getNumber("WEBGL_VERSION")===1?xt(e,()=>e.texImage2D(a,0,n,t,r,0,o,s,null)):xt(e,()=>e.texStorage2D(a,1,n,t,r)),xt(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[r,t]}}function eA(e){return e.internalFormatFloat}function GG(e,t,r,n){let[o,s]=ef(t,r);return Cb(e,o,s,eA(n),n.textureFormatFloat,e.FLOAT)}function rA(e){return e.internalFormatHalfFloat}function UG(e,t,r,n){let[o,s]=ef(t,r);return Cb(e,o,s,rA(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function nA(e){return e.downloadTextureFormat}function HG(e,t,r,n){let[o,s]=ef(t,r);return Cb(e,o,s,nA(n),e.RGBA,e.UNSIGNED_BYTE)}function oA(e){return e.internalFormatPackedFloat}function qG(e,t,r,n){let[o,s]=Pi(t,r);return Cb(e,o,s,oA(n),e.RGBA,e.FLOAT)}function sA(e){return e.internalFormatPackedHalfFloat}function jG(e,t,r,n){let[o,s]=Pi(t,r);return Cb(e,o,s,sA(n),e.RGBA,n.textureTypeHalfFloat)}function KG(e,t,r){return xt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Q2(e,t,"clipSpacePos",r,3,20,0)&&Q2(e,t,"uv",r,2,20,12)}function XG(e,t,r,n,o,s){xt(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,a,l;o instanceof Uint8Array?(i=new Uint8Array(r*n*4),a=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(r*n*4),a=e.FLOAT,l=s.internalFormatPackedFloat),i.set(o),B().getNumber("WEBGL_VERSION")===2?xt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r,n,e.RGBA,a,i)):xt(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,r,n,0,e.RGBA,a,i)),xt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function YG(e,t,r){xt(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r.data instanceof Uint8Array?B().getNumber("WEBGL_VERSION")===2?xt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r.width,r.height,e.RGBA,e.UNSIGNED_BYTE,r.data)):xt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r.width,r.height,0,e.RGBA,e.UNSIGNED_BYTE,r.data)):B().getNumber("WEBGL_VERSION")===2?xt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,r)):xt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)),xt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function QG(e,t,r,n){let o=e.createBuffer();xt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o));let a=4*4*t*r;return xt(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),xt(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,0)),xt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),o}function ZG(e,t,r){let n=e,o=new Float32Array(r);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function JG(e,t,r,n){let[o,s]=ef(t,r),i=4,a=new Uint8Array(uG(t*r,i));return xt(e,()=>e.readPixels(0,0,o,s,n.downloadTextureFormat,e.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function tU(e,t,r,n,o,s,i,a){let l=e,u=new Float32Array(cG(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function eU(e,t,r){let n=new Float32Array(t*r*4);return xt(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,n)),n}var yh=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let r=B().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,lG(r,t)):this.gl=xo(r),t=this.gl,B().getNumber("WEBGL_VERSION")===2){let s=t;this.createVertexArray=()=>xt(s,()=>s.createVertexArray()),this.bindVertexArray=i=>xt(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>xt(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>xt(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){let s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>xt(t,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>xt(t,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>xt(t,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>xt(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),B().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=yb(this.gl,s),Fo(this.gl,i))this.textureHalfFloatExtension=yb(this.gl,i);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Fo(this.gl,o))this.colorBufferHalfFloatExtension=yb(this.gl,o);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Fo(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Fo(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=VG(this.gl),this.indexBuffer=WG(this.gl),this.framebuffer=vG(this.gl),this.textureConfig=xb(this.gl,this.textureHalfFloatExtension)}get debug(){return B().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;xt(t,()=>t.finish()),xt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),xt(t,()=>t.deleteFramebuffer(this.framebuffer)),xt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),xt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),xt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,r){return this.throwIfDisposed(),GG(this.gl,t,r,this.textureConfig)}createFloat16MatrixTexture(t,r){return this.throwIfDisposed(),UG(this.gl,t,r,this.textureConfig)}createUnsignedBytesMatrixTexture(t,r){return this.throwIfDisposed(),HG(this.gl,t,r,this.textureConfig)}uploadPixelDataToTexture(t,r){this.throwIfDisposed(),YG(this.gl,t,r)}uploadDenseMatrixToTexture(t,r,n,o){this.throwIfDisposed(),XG(this.gl,t,r,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,r){return this.throwIfDisposed(),jG(this.gl,t,r,this.textureConfig)}createPackedMatrixTexture(t,r){return this.throwIfDisposed(),qG(this.gl,t,r,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Z2(this.gl,this.framebuffer),this.outputTexture=null),xt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,r,n){return this.downloadMatrixDriver(t,()=>JG(this.gl,r,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,r,n,o,s,i){return tU(this.gl,t,r,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,r){return ZG(this.gl,t,r)}createBufferFromTexture(t,r,n){this.bindTextureToFrameBuffer(t);let o=QG(this.gl,r,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let r,n;if(B().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},r=s}else B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(r=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(r,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:r,isFencePassed:n}}downloadMatrixFromPackedTexture(t,r,n){return this.downloadMatrixDriver(t,()=>eU(this.gl,r,n))}createProgram(t){this.throwIfDisposed();let r=this.gl;this.vertexShader==null&&(this.vertexShader=BG(r));let n=dG(r);xt(r,()=>r.attachShader(n,this.vertexShader)),xt(r,()=>r.attachShader(n,t)),hG(r,n);let o;return o=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(o.vao),xt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(KG(r,o,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&BC(r,o),this.setProgram(o),o}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(xt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&BC(this.gl,this.program)),xt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,r,n=!0){return this.throwIfDisposed(),n?wG(this.gl,t,r):CG(this.gl,t,r)}getAttributeLocation(t,r){return this.throwIfDisposed(),xt(this.gl,()=>this.gl.getAttribLocation(t,r))}getUniformLocationNoThrow(t,r){return this.throwIfDisposed(),this.gl.getUniformLocation(t,r)}setInputMatrixTexture(t,r,n){this.throwIfDisposed(),this.throwIfNoProgram(),SG(this.gl,t,r,n)}setOutputMatrixTexture(t,r,n){this.setOutputMatrixTextureDriver(t,n,r)}setOutputPackedMatrixTexture(t,r,n){this.throwIfDisposed();let[o,s]=Pi(r,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,r,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,r)}setOutputPackedMatrixWriteRegion(t,r,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&BC(this.gl,this.program),bb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;if(this.debug){let r=this.getVertexArray();console.assert(r===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}xt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),xt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yb(this.gl,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),r=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,r),r}endQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,n=this.getQueryTimerExtensionWebGL2();r.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){return H(this,null,function*(){return yield w.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(t,r){if(r===0)return null;if(r===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,r){if(r===0)return!0;if(r===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(r=>{this.addItemToPoll(()=>t.isFencePassed(),()=>r())})}pollItems(){let t=fft(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=t;++r){let{resolveFn:n}=this.itemsToPoll[r];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,r){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:r}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in B().platform&&(n=B().platform.setTimeoutCustom.bind(B().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),VC(this.gl,t,this.framebuffer),this.debug&&bb(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(VC(this.gl,this.outputTexture,this.framebuffer),this.debug&&bb(this.gl)):Z2(this.gl,this.framebuffer)}downloadMatrixDriver(t,r){this.bindTextureToFrameBuffer(t);let n=r();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,r,n){this.throwIfDisposed();let o=this.gl;VC(o,t,this.framebuffer),this.debug&&bb(o),this.outputTexture=t,xt(o,()=>o.viewport(0,0,r,n)),xt(o,()=>o.scissor(0,0,r,n))}setOutputMatrixWriteRegionDriver(t,r,n,o){this.throwIfDisposed(),xt(this.gl,()=>this.gl.scissor(t,r,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function fft(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:rU,bincountImpl:YC,bincountReduceImpl:nU,castImpl:oU,ceilImpl:sU,concatImpl:iU,equalImpl:aU,expImpl:lU,expm1Impl:uU,floorImpl:cU,gatherNdImpl:pU,gatherV2Impl:fU,greaterImpl:mU,greaterEqualImpl:dU,lessImpl:hU,lessEqualImpl:gU,linSpaceImpl:xU,logImpl:yU,maxImpl:bU,maximumImpl:vU,minimumImpl:wU,multiplyImpl:CU,negImpl:SU,notEqualImpl:kU,prodImpl:TU,raggedGatherImpl:NU,raggedRangeImpl:IU,raggedTensorToTensorImpl:EU,rangeImpl:_U,rsqrtImpl:AU,scatterImpl:DU,sigmoidImpl:RU,simpleAbsImpl:QC,sliceImpl:$U,sparseFillEmptyRowsImpl:OU,sparseReshapeImpl:FU,sparseSegmentReductionImpl:ZC,sqrtImpl:PU,stridedSliceImpl:LU,stringNGramsImpl:MU,stringSplitImpl:zU,stringToHashBucketFastImpl:BU,subImpl:VU,tileImpl:WU,topKImpl:GU,transposeImpl:sf,uniqueImpl:UU}=$2;function iA(e,t){return["x","y","z","w","u","v"].slice(0,t).map(r=>`${e}.${r}`)}function Ke(e,t){return t===1?[e]:iA(e,t)}function HU(e,t){if(e===1)return"rc";let r="";for(let n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}var JC=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=he(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let r=Ke("rc",this.rank),n=zt(this.rank),o=this.getOutOfBoundsCondition(r),s=this.getSetup(r),i=this.getOutput(r);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let r=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;r.push(s)}return r}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let r="";for(let n=this.rank-2;n<this.rank;n++)r+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(r+="||");return r}getSetup(t){if(this.rank===1)return"";let r=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${r[0]};
      int c = ${r[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let r=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${r[0]}),
            cEdge ? 0. : getA(${r[1]}),
            rEdge ? 0. : getA(${r[2]}),
            rEdge || cEdge ? 0. : getA(${r[3]})`}};var bh=class{constructor(t,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${mft(r,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?fh():ph(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function mft(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?DG(["r","c","d"],"inputShape"):Ks(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var tS=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,r,n){let o=jU(r,n),s=KU(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=qU(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return o===Wr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Wr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Wr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Wr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Wr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,r,n,o){if(this.freeTextures==null)return;let s=jU(n,o),i=KU(r,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=qU(r,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=B().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let u=this.usedTextures[i],c=u.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let r=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*r)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(r=>{this.gpgpu.deleteMatrixTexture(r.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(r=>{this.gpgpu.deleteMatrixTexture(r.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function dft(e,t){let r=e;if(t===r.R32F)return 4;if(t===r.R16F)return 2;if(t===r.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===r.RGBA16F)return 8;if(t===r.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function qU(e,t,r,n,o){let s=hft(t,n),i;if(o){let[l,u]=Pi(e[0],e[1]);i=l*u}else{let[l,u]=ef(e[0],e[1]);i=l*u}let a=dft(r,s);return i*a}function hft(e,t){switch(e){case Wr.PACKED_2X2_FLOAT32:return oA(t);case Wr.PACKED_2X2_FLOAT16:return sA(t);case Wr.UNPACKED_FLOAT32:return eA(t);case Wr.UNPACKED_FLOAT16:return rA(t);case Wr.PACKED_4X1_UNSIGNED_BYTE:return nA(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function gft(e){return B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Wr.PACKED_2X2_FLOAT32:Wr.UNPACKED_FLOAT32:e?Wr.PACKED_2X2_FLOAT16:Wr.UNPACKED_FLOAT16}function jU(e,t){if(e===nn.UPLOAD)return Wr.PACKED_2X2_FLOAT32;if(e===nn.RENDER||e==null)return gft(t);if(e===nn.DOWNLOAD||e===nn.PIXELS)return Wr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function KU(e,t,r){return`${e[0]}_${e[1]}_${t}_${r}`}var Gr=class{constructor(t,r){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${r}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},xr="if (isnan(x)) return x;",XU="return x;",aA="return abs(x);";var YU="return (x >= 0.0) ? x : (exp(x) - 1.0);",QU=xr+`
  return (x < 0.0) ? 0.0 : x;
`,ZU=xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Mi="return x;",JU="return 1.0 / (1.0 + exp(-1.0 * x));";var eH="return x;",rH=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,nH=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oH=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sH="return 1.0 / (1.0 + exp(-1.0 * x));",qn=class{constructor(t,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${r}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var eS=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length);let r=t.length,n=Ke("rc",r),o=zt(r),s=HU(r,n),i=n.slice(-2),a=r<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var yft=tn.whereImpl,bft=1e-7,vft=1e-4,rS={};function wft(e){return e in rS||(rS[e]={}),rS[e]}var Cft=B().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Sft=600;function kft(){return B().global.screen==null?1024:B().global.screen.height*B().global.screen.width*window.devicePixelRatio*Sft/1024/1024}var af=class extends sa{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!B().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(t!=null){if(t instanceof yh)r=t;else{let n=xo(B().getNumber("WEBGL_VERSION"),t);r=new yh(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=xo(B().getNumber("WEBGL_VERSION"));r=new yh(n),this.binaryCache=wft(B().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new tS(this.gpgpu),this.numMBBeforeWarning=kft(),this.texData=new Zc(this,ts())}nextDataId(){return af.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,r,n,o,s,i){let a=this.makeTensorInfo(r,n),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[o,s]},l.texShape=[o,s];let u=vb(r),c=new wb(u,!1,i),p=this.runWebGLProgram(c,[a],n,[[o,s]]);return p.shape=r,l.texture=null,this.disposeIntermediateTensorInfo(a),p.dataId}write(t,r,n){if((B().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||B().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:n,values:t,usage:nn.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let r=this.texData.get(t);r.refCount++}decRef(t){if(this.texData.has(t)){let r=this.texData.get(t);r.refCount--}}move(t,r,n,o,s){if(B().getBool("DEBUG")&&this.checkNumericalProblems(r),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:r,usage:nn.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let r=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:l}=r;if(i!=null){let f;l?f=new qn(a,Mi):f=new Gr(a,Mi);let m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:o}],o),d=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),d}if(n!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return n;let u=this.activeTimers!=null,c;u&&(c=w.now());let p;if(o==="complex64"){let f=this.readSync(s.real.dataId),m=this.readSync(s.imag.dataId);p=T.mergeRealAndImagArrays(f,m)}else p=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=w.now()-c),this.convertAndCacheOnCPU(t,p)}read(t){return H(this,null,function*(){if(this.pendingRead.has(t)){let d=this.pendingRead.get(t);return new Promise(h=>d.push(h))}let r=this.texData.get(t),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:l}=r;if(s!=null){let d;l?d=new qn(o,Mi):d=new Gr(o,Mi);let h=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:i}],i),x=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),x}if(n!=null)return this.convertAndCacheOnCPU(t);if(B().getBool("DEBUG")&&!B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&B().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&B().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let d=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(d.texture.texture,...gb(o))}this.pendingRead.set(t,[]),i!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let p;if(i==="complex64"){let d=yield Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],x=d[1];p=T.mergeRealAndImagArrays(h,x)}else if(u==null)p=this.getValuesFromTexture(t);else{let d=w.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(u,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let d=this.gpgpu.gl;xt(d,()=>d.deleteBuffer(u))}let f=this.convertAndCacheOnCPU(t,p),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(d=>d(f)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ts().removeDataId(t,this),this.pendingDeletes--),f})}readToGPU(t,r={}){let n=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,isPacked:l,texture:u}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let m;l?m=new qn(s,Mi):m=new Gr(s,Mi);let d=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:a}],a),h=this.readToGPU(d,r);return this.disposeIntermediateTensorInfo(d),h}if(u==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,r.customTexShape),p=ts().makeTensorFromTensorInfo(c),f=this.texData.get(c.dataId);return Object.assign({tensorRef:p},f.texture)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let n=r.map(o=>w.decodeString(o));return Ct(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(t.shape,t.dtype,r)}checkNumericalProblems(t){if(t!=null)for(let r=0;r<t.length;r++){let n=t[r];if(!pG(n))throw B().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:r,dtype:n,isPacked:o}=this.texData.get(t),s=w.sizeFromShape(r);if(B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let f=this.decode(t),m=this.texData.get(f.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...gb(r)).subarray(0,s);return this.disposeIntermediateTensorInfo(f),d}let i=B().getBool("WEBGL_PACK")&&o===!0,a=i?vb(r):r,l=i?new KC(a):new jC(a),u=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),p}timerAvailable(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let r=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=w.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=w.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=r,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(()=>H(this,null,function*(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=yield Promise.all(s);a.kernelMs=w.sum(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}))()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(t){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=w.now(),t)}getQueryTime(t){return H(this,null,function*(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let r=t;return r.endMs-r.startMs})}disposeData(t,r=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(r?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!r&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,r),this.disposeData(n.imag.dataId,r)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:r,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(t),l=a&&a.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),r!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(r,o,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,r=Cft){return B().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&w.sizeFromShape(n.shape)<r)}getGPGPUContext(){return this.gpgpu}where(t){T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=t.dataSync();return yft(t.shape,r)}packedUnaryOp(t,r,n){let o=new qn(t.shape,r),s=this.compileAndRun(o,[t],n);return ts().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let o=QC(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(B().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,aA,t.dtype);let r=new Gr(t.shape,aA),n=this.compileAndRun(r,[t]);return ts().makeTensorFromTensorInfo(n)}makeTensorInfo(t,r,n){let o;if(r==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(i=>w.encodeString(i));o=this.write(s,t,r)}else o=this.write(n,t,r);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:r}}makeOutput(t,r,n){return ts().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,n),this)}unpackTensor(t){let r=new eS(t.shape);return this.runWebGLProgram(r,[t],t.dtype)}packTensor(t){let r=new JC(t.shape),n=!0;return this.runWebGLProgram(r,[t],t.dtype,null,n)}packedReshape(t,r){let n=[dc(t.shape),...hc(t.shape)],o={dtype:t.dtype,shape:n,dataId:t.dataId},s=[dc(r),...hc(r)],i=new bh(s,n),a=!0,l=[n],u=this.runWebGLProgram(i,[o],t.dtype,l,a);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(t,r){let n=this.texData.get(t),{isPacked:o,shape:s,dtype:i}=n;if(r!=null){let f=w.sizeFromShape(s),m=r[0]*r[1]*4;w.assert(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=vb(s),l;o?l=new qC(a):l=new HC(a);let u=!0,c=[r!=null?r:gb(a)],p=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:t}],i,c,u,r);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,r,n,o,s=!1,i){let a=this.makeTensorInfo(t.outputShape,n),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===mc.DENSE){let g=i!=null?i:gb(t.outputShape);l.texShape=g.map(y=>y*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),w.sizeFromShape(a.shape)===0)return l.values=w.getTypedArrayFromDType(a.dtype,0),a;let u=[],c=r.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!t.packedInputs&&w.sizeFromShape(g.shape)<=B().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!y.isPacked!=!!t.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),u.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!rf(y.shape,g.shape)){let b=g,v=g.shape;g.shape=y.shape,g=this.packedReshape(g,v),u.push(g),y=this.texData.get(g.dataId),b.shape=v}return{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:l,isUniform:!1},f=zG(t,c,p),m=this.getAndSaveBinary(f,()=>LG(this.gpgpu,t,c,p)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),B().get("ENGINE_COMPILE_ONLY")||MG(this.gpgpu,m,c,p,o),u.forEach(g=>this.disposeIntermediateTensorInfo(g)),d&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let x=B().get("WEBGL_FLUSH_THRESHOLD");if(x>0){let g=w.now();g-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!B().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(t,r,n,o,s=!1){return n=n||r[0].dtype,this.runWebGLProgram(t,r,n,o,s)}getAndSaveBinary(t,r){return t in this.binaryCache||(this.binaryCache[t]=r()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(B().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=V(()=>{if(!B().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=B().getBool("DEBUG");B().set("DEBUG",!1);let r=this.abs(At(1e-8)).dataSync()[0];if(B().set("DEBUG",t),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?bft:vft}uploadToGPU(t){let r=this.texData.get(t),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:l}=r;if(i!=null)return;let u=this.activeTimers!=null,c;u&&(c=w.now());let p=r.texShape;if(p==null&&(p=kG(n,l),r.texShape=p),s!=null){let f=vb(n),m,d=p[1],h=p[0],x=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!x)&&([d,h]=Pi(p[0],p[1])),l?m=new XC(f,x):m=new wb(f,x);let g=x?[h,d]:p,y=this.makeTensorInfo(g,o),b=this.texData.get(y.dataId);x?b.usage=nn.PIXELS:b.usage=nn.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),d,h,s);let v=[[h,d]],C=!0,S=this.runWebGLProgram(m,[y],o,v,C),k=this.texData.get(S.dataId);r.texShape=k.texShape,r.isPacked=k.isPacked,r.usage=k.usage,B().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(r.texture=k.texture,r.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(y),u&&(this.uploadWaitMs+=w.now()-c)}else{let f=this.acquireTexture(p,a,o,l);r.texture=f}}convertAndCacheOnCPU(t,r){let n=this.texData.get(t),{dtype:o}=n;return r!=null&&(n.values=Tft(r,o)),n.values}acquireTexture(t,r,n,o){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,r,o)}computeBytes(t,r){return t[0]*t[1]*w.bytesPerElement(r)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}checkCompileCompletionAsync(){return H(this,null,function*(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(r));return Promise.all(t)}else{for(let[,r]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(r),o(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}})}checkCompletionAsync_(t){return H(this,null,function*(){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(yield $x(),this.checkCompletionAsync_(t))})}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Y2(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:r,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:u,outTexShapeLocation:c}=tA(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=r,t.customUniformLocations=n,t.infLoc=o,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=l,t.outShapeStridesLocation=u,t.outTexShapeLocation=c}}createTensorFromTexture(t,r,n){let{texture:o,height:s,width:i,channels:a}=t,l=ts().backend;if(!l.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(o,r,n,s,i,a);return ts().makeTensorFromDataId(u,r,n,l)}};af.nextDataId=0;function Tft(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let r=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let n=0;n<r.length;++n)r[n]=Math.round(e[n]);return r}else throw new Error(`Unknown dtype ${t}`)}Yu.isBrowser()&&zw("webgl",()=>new af,2);var vh=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Po=class{constructor(t,r,n){this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(r,n),this.enableShapeUniforms=he(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var zi=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var bs=class{constructor(t,r,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(r,n);let s=this.outputShape.length;this.enableShapeUniforms=he(s);let i="";if(o)if(s===0||w.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${zt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=Ke("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Xe(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var iH={kernelName:yi,backendName:"webgl",kernelFunc:Xe};function jn(e){let{inputs:t,backend:r}=e,{real:n,imag:o}=t,s=r.makeTensorInfo(n.shape,"complex64"),i=r.texData.get(s.dataId),a=Xe({inputs:{x:n},backend:r}),l=Xe({inputs:{x:o},backend:r});return i.complexTensorInfos={real:a,imag:l},s}var aH={kernelName:wm,backendName:"webgl",kernelFunc:jn};var lA="return (a < 0.) ? b * a : a;",uA=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Nft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{alpha:s}=n,i=r.makeTensorInfo([],"float32",w.createScalarValue(s,"float32")),a=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bs(uA,o.shape,i.shape):new Po(lA,o.shape,i.shape),l=r.runWebGLProgram(a,[o,i],"float32");return r.disposeIntermediateTensorInfo(i),l}var lH={kernelName:vu,backendName:"webgl",kernelFunc:Nft};var cA="return (a < 0.) ? b * a : a;",pA=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ift(e){let{inputs:t,backend:r}=e,{x:n,alpha:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bs(pA,n.shape,o.shape):new Po(cA,n.shape,o.shape);return r.runWebGLProgram(s,[n,o],"float32")}var uH={kernelName:$u,backendName:"webgl",kernelFunc:Ift};var vs="if (isnan(x)) return x;";function vt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:r,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,l=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&r!=null){let p=a.texData.get(i.dataId),f=r(p.values,l);return a.makeTensorInfo(i.shape,l,f)}let u=B().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new qn(i.shape,t):c=new Gr(i.shape,e),a.runWebGLProgram(c,[i],l)}}function re({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:r=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:l,b:u}=i,c=a;if(n&&l.dtype==="complex64"){let d=c.texData.get(l.dataId),h=c.texData.get(u.dataId),[x,g]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(b=>{let[v,C]=b,S={dataId:v.dataId,dtype:v.dtype,shape:l.shape},k={dataId:C.dataId,dtype:C.dtype,shape:u.shape},I=new Po(e,l.shape,u.shape);return c.runWebGLProgram(I,[S,k],or(v.dtype,C.dtype))}),y=jn({inputs:{real:x,imag:g},backend:c});return c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(g),y}let p=s||or(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&o!=null){let d=c.texData.get(l.dataId).values,h=c.texData.get(u.dataId).values,x=l.dtype==="string"?T.fromUint8ToStringArray(d):d,g=l.dtype==="string"?T.fromUint8ToStringArray(h):h,[y,b]=o(l.shape,u.shape,x,g,p),v=c.makeTensorInfo(b,p),C=c.texData.get(v.dataId);return C.values=y,v}let f=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,m;return f?m=new bs(t,l.shape,u.shape,r):m=new Po(e,l.shape,u.shape),c.runWebGLProgram(m,[l,u],p)}}function Sl(e,t=!1){if(e==="linear")return t?eH:XU;if(e==="relu")return t?nH:QU;if(e==="elu")return t?rH:YU;if(e==="relu6")return t?oH:ZU;if(e==="prelu")return t?pA:cA;if(e==="leakyrelu")return t?uA:lA;if(e==="sigmoid")return t?sH:JU;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var wh=class{constructor(t,r,n,o=!1,s=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=he(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),f=o?"i * 2, rc.y":"rc.y, i * 2",m=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],x="",g="";a&&(l?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:x=`vec4 activation(vec4 x) {
          ${a}
        }`,g="result = activation(result);");let y=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";t[0]<r[0]?b=`int(min(float(rc.x), ${t[0]-1}.))`:r[0]<t[0]&&(v=`int(min(float(rc.x), ${r[0]-1}.))`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${b};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}};var fA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Sb=class{constructor(t,r,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=T.assertAndGetBroadcastShape(r,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var cH="return a * b;";function kb(e){let{inputs:t,backend:r}=e,{a:n,b:o}=t,s=T.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=r.texData.get(n.dataId),l=r.texData.get(o.dataId),u=new Sb(fA.REAL,n.shape,o.shape),c=new Sb(fA.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],f=r.runWebGLProgram(u,p,"float32"),m=r.runWebGLProgram(c,p,"float32"),d=jn({inputs:{real:f,imag:m},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),d}if(r.shouldExecuteOnCPU([n,o])){let a=r.texData.get(n.dataId),l=r.texData.get(o.dataId),[u,c]=CU(n.shape,o.shape,a.values,l.values,s),p=r.makeTensorInfo(c,s),f=r.texData.get(p.dataId);return f.values=u,p}let i;return B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new bs(cH,n.shape,o.shape):i=new Po(cH,n.shape,o.shape),r.runWebGLProgram(i,[n,o],s)}var pH={kernelName:Oa,backendName:"webgl",kernelFunc:kb};function fH(e,t,r){let n=[dc(e.shape),...hc(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[dc(t),...hc(t)],i=new bh(s,n),a=!0,l=[n],u=r.runWebGLProgram(i,[o],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function st(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{shape:s}=n,i=r,a=w.sizeFromShape(o.shape),l=w.inferFromImplicitShape(s,a),u=w.sizeFromShape(l);w.assert(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!rf(o.shape,l)&&!(c.texture!==null&&rf(c.shape,l))?fH(o,l,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}var mH={kernelName:Fu,backendName:"webgl",kernelFunc:st};var Tb=class{constructor(t,r){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,l=n%4,u="sumValue += dot(values, ones);";if(r!=null){let p=1/r;u=`sumValue += dot(values * ${w.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var nS=class{constructor(t,r){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",l="";r==="prod"?a="1.0":r==="min"?(a="1.0 / 1e-20",l="min"):r==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;r==="sum"?u="sumValue":r==="prod"?u="prodValue":r==="all"?u="allValue":r==="any"&&(u="anyValue");let c=Math.floor(n/4)*4,p=n%4,f=`
      if (${r==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${r==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${r==="min"} || ${r==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";r==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):r==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function _ft(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let r=t.length?t[t.length-1].outSize:e[1],n=T.computeOptimalWindowSize(r);t.push({inSize:r,windowSize:n,outSize:Math.ceil(r/n)})}return t}function yo(e,t,r,n){let o=_ft(e.shape),s=e;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:l,outSize:u}=o[i],c,p;r==="mean"?c=i===0?new Tb({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u},a):new Tb({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u}):c=new nS({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u},r),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==e.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var oS=class{constructor(t,r){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[r[i]];this.outputShape=n,this.rank=n.length;let o=zt(this.rank),s=Aft(r);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Aft(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<e.length;o++)n[e[o]]=r[o];return n.join()}var sS=class{constructor(t,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[r[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=zt(this.rank),s=iA("rc",this.rank),i=new Array(this.rank);for(let c=0;c<r.length;c++)i[r[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function gc(e,t,r){let n=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sS(e.shape,t):new oS(e.shape,t);return r.runWebGLProgram(n,[e],e.dtype)}function dH(e,t,r,n){let o=t,s=e.shape.length,i=w.parseAxisParam(o,e.shape),a=i,l=T.getAxesPermutation(a,s),u=l!=null,c=e;u&&(c=gc(e,l,n),a=T.getInnerMostAxes(a.length,s)),T.assertAxesAreInnerMostDims("sum",a,s);let[p,f]=T.computeOutAndReduceShapes(c.shape,a),m=p;r&&(m=T.expandShapeToKeepDim(p,i));let d=w.sizeFromShape(f),x=w.sizeFromShape(e.shape)/d,g=st({inputs:{x:c},attrs:{shape:[x,d]},backend:n}),y=yp(e.dtype),b=yo(g,y,"sum",n),v=st({inputs:{x:b},attrs:{shape:m},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),u&&n.disposeIntermediateTensorInfo(c),v}function lf(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n;return dH(o,s,i,r)}var hH={kernelName:Vu,backendName:"webgl",kernelFunc:lf};function Ae(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{perm:s}=n,i=r,a=o.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=o.shape[s[c]];let u;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,f=sf(p,o.shape,o.dtype,s,l);u=i.makeTensorInfo(l,o.dtype);let m=i.texData.get(u.dataId);m.values=f}else u=gc(o,s,i);return u}var gH={kernelName:vi,backendName:"webgl",kernelFunc:Ae};var mA=1e3;function uf({a:e,b:t,transposeA:r,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,p=r?e.shape[u-2]:e.shape[u-1],f=n?t.shape[c-1]:t.shape[c-2],m=r?e.shape[u-1]:e.shape[u-2],d=n?t.shape[c-2]:t.shape[c-1],h=e.shape.slice(0,-2),x=t.shape.slice(0,-2),g=w.sizeFromShape(h),y=w.sizeFromShape(x),v=uo.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([m,d]);w.assert(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${r} and transposeB=${n} must match.`);let C=r?[g,p,m]:[g,m,p],S=n?[y,d,f]:[y,f,d],k=st({inputs:{x:e},backend:o,attrs:{shape:C}}),I=st({inputs:{x:t},backend:o,attrs:{shape:S}}),D=[k,I],R=Math.max(g,y),M=r?k.shape[1]:k.shape[2],U=s!=null,j=i!=null,K=l==="leakyrelu",W=l!=null?Sl(l,!0):null,q=U||j||K||W!=null,X;if((m===1||d===1)&&M>mA&&q===!1){let Y=k,nt=I;r&&(Y=Ae({inputs:{x:k},backend:o,attrs:{perm:[0,2,1]}}),D.push(Y)),n&&(nt=Ae({inputs:{x:I},backend:o,attrs:{perm:[0,2,1]}}),D.push(nt));let rt=d!==1,at=d===1,lt=Y;rt&&(lt=st({inputs:{x:Y},backend:o,attrs:{shape:[R,M,1]}}),D.push(lt));let ut=d===1?2:1,it=nt;at&&(it=st({inputs:{x:nt},backend:o,attrs:{shape:[R,1,M]}}),D.push(it));let dt=kb({inputs:{a:lt,b:it},backend:o});X=lf({inputs:{x:dt},backend:o,attrs:{axis:ut,keepDims:!0}}),D.push(dt)}else{let Y=or(e.dtype,t.dtype),nt=new wh(C,S,[R,m,d],r,n,U,W,j,K),rt=[k,I];if(s!=null&&rt.push(s),j&&rt.push(i),K){let at=o.makeTensorInfo([],"float32",w.createScalarValue(a,"float32"));rt.push(at),D.push(at)}X=o.runWebGLProgram(nt,rt,Y)}let Q=st({inputs:{x:X},backend:o,attrs:{shape:v}});D.push(X);for(let Y of D)o.disposeIntermediateTensorInfo(Y);return Q}function Dft(e){let{inputs:t,backend:r,attrs:n}=e,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=n;return uf({a:o,b:s,transposeA:l,transposeB:u,backend:r,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var xH={kernelName:cp,backendName:"webgl",kernelFunc:Dft};var yH="return abs(x);";function Rft(e){let{inputs:t,backend:r}=e,{x:n}=t;if(r.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=r.texData.get(n.dataId),i=QC(s.values);return r.makeTensorInfo(n.shape,n.dtype,i)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new qn(n.shape,yH):o=new Gr(n.shape,yH),r.runWebGLProgram(o,[n],n.dtype)}var bH={kernelName:ru,backendName:"webgl",kernelFunc:Rft};var $ft=xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Oft=vt({opSnippet:$ft}),vH={kernelName:aa,backendName:"webgl",kernelFunc:Oft};var Fft=xr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Pft=vt({opSnippet:Fft}),wH={kernelName:la,backendName:"webgl",kernelFunc:Pft};var CH="return a + b;",Lft=re({opSnippet:CH,packedOpSnippet:CH,supportsComplex:!0,cpuKernelImpl:rU}),SH={kernelName:Fs,backendName:"webgl",kernelFunc:Lft};var iS=class{constructor(t,r){this.outputShape=[],this.outputShape=t,this.variableNames=r.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var aS=class{constructor(t,r){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=r.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function lS(e){let{inputs:t,backend:r}=e,n=t;if(n.length===1)return Xe({inputs:{x:n[0]},backend:r});if(n.length>B().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(n.length/2),u=lS({inputs:n.slice(0,l),backend:r}),c=lS({inputs:n.slice(l),backend:r});return lS({inputs:[u,c],backend:r})}let o=n.map(l=>l.dtype).reduce((l,u)=>or(l,u)),s=n.map(l=>l.shape),a=B().getBool("WEBGL_PACK")?new aS(n[0].shape,s):new iS(n[0].shape,s);return r.runWebGLProgram(a,n,o)}var kH={kernelName:hm,backendName:"webgl",kernelFunc:lS};function Mft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,l=w.parseAxisParam(s,o.shape),u=l,c=T.getAxesPermutation(u,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:r,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,a)),T.assertAxesAreInnerMostDims("all",u,a);let[f,m]=T.computeOutAndReduceShapes(p.shape,u),d=w.sizeFromShape(m),h=st({inputs:{x:p},backend:r,attrs:{shape:[-1,d]}}),x=yo(h,h.dtype,"all",r),g;if(i){let y=T.expandShapeToKeepDim(f,l);g=st({inputs:{x},backend:r,attrs:{shape:y}})}else g=st({inputs:{x},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),c!=null&&r.disposeIntermediateTensorInfo(p),g}var TH={kernelName:gm,backendName:"webgl",kernelFunc:Mft};function zft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,l=w.parseAxisParam(s,o.shape),u=l,c=T.getAxesPermutation(u,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:r,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,a)),T.assertAxesAreInnerMostDims("any",u,a);let[f,m]=T.computeOutAndReduceShapes(p.shape,u),d=w.sizeFromShape(m),h=st({inputs:{x:p},backend:r,attrs:{shape:[-1,d]}}),x=yo(h,h.dtype,"any",r),g;if(i){let y=T.expandShapeToKeepDim(f,l);g=st({inputs:{x},backend:r,attrs:{shape:y}})}else g=st({inputs:{x},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),c!=null&&r.disposeIntermediateTensorInfo(p),g}var NH={kernelName:xm,backendName:"webgl",kernelFunc:zft};var uS=class{constructor(t,r,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=r==="max"?">":"<",l=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var cS=class{constructor(t,r,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/r);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,l=a.length,u=zt(l),c=Ke("coords",l),p,f;if(i===1){f=l+1;let I=zt(f);p=`
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l-1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l-2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l-1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let m=["x","y","z","w","u","v"].slice(0,f),d="."+m[f-1],h=m.map(I=>"int "+I),x=Ke("sourceLocR",f-1).concat("inIdx.r"),g=Ke("sourceLocG",f-1).concat("inIdx.g"),y=Ke("sourceLocB",f-1).concat("inIdx.b"),b=Ke("sourceLocA",f-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",C=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,S=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${r};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${r}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function IH(e,t,r,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=T.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},l=new uS(a,r,n==null),u=[t];n!=null&&u.push(n);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=IH(e,t,r,c);return e.disposeIntermediateTensorInfo(c),p}function EH(e,t,r,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=T.computeOptimalWindowSize(s),a=new cS(o,i,r,n==null),l=n==null?[t]:[t,n],u=e.runWebGLProgram(a,l,"int32");if(u.shape.length===t.shape.length){let c=EH(e,t,r,u);return e.disposeIntermediateTensorInfo(u),c}return u}function pS(e,t,r,n){let o=[r];if(T.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!B().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),a=i!==null&&i.isPacked,l=t;a&&(l=e.unpackTensor(t),s.push(l));let[u,c]=T.computeOutAndReduceShapes(l.shape,o),p=w.sizeFromShape(c),f=st({inputs:{x:l},backend:e,attrs:{shape:[-1,p]}});s.push(f);let m=IH(e,f,n);s.push(m);let d=st({inputs:{x:m},backend:e,attrs:{shape:u}});return s.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}return EH(e,t,n)}function Bft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s}=n,i=w.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Ae({inputs:{x:o},backend:r,attrs:{perm:a}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=pS(r,l,i[0],"max");return u.forEach(p=>r.disposeIntermediateTensorInfo(p)),c}var _H={kernelName:nu,backendName:"webgl",kernelFunc:Bft};function Vft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s}=n,i=w.parseAxisParam(s,o.shape),a=T.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Ae({inputs:{x:o},backend:r,attrs:{perm:a}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=pS(r,l,i[0],"min");return u.forEach(p=>r.disposeIntermediateTensorInfo(p)),c}var AH={kernelName:ou,backendName:"webgl",kernelFunc:Vft};var Wft=xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Gft=vt({opSnippet:Wft}),DH={kernelName:ua,backendName:"webgl",kernelFunc:Gft};var Uft=xr+"return log(x + sqrt(x * x + 1.0));",Hft=vt({opSnippet:Uft}),RH={kernelName:ca,backendName:"webgl",kernelFunc:Hft};var qft=xr+`
  return atan(x);
`,jft=vt({opSnippet:qft}),$H={kernelName:pa,backendName:"webgl",kernelFunc:jft};var Kft=vh+`
  return atan(a, b);
`,Xft=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+zi+`
  return result;
`,Yft=re({opSnippet:Kft,packedOpSnippet:Xft}),OH={kernelName:ma,backendName:"webgl",kernelFunc:Yft};var Qft=xr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Zft=vt({opSnippet:Qft}),FH={kernelName:fa,backendName:"webgl",kernelFunc:Zft};var Xs=class{constructor(t,r,n,o=!1,s=!1){if(this.variableNames=["x"],r==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.top,d=t.padInfo.left;this.outputShape=t.outShape;let h=r==="avg",x=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,y="0.0";if(h||(y="-1.0 / 1e-20"),n){let I=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${m}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?x:g:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",v=`${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;r==="avg"&&(v="avgValue / count");let C=Math.floor(i/4)*4,S=i%4,k=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${m}, ${d});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${C};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${v});
      }
    `}},xc=class{constructor(t,r,n,o=!1,s=!1){if(this.variableNames=["x"],r==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,x=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;let b=r==="avg",v="0.0";if(b||(v="-1.0 / 1e-20"),n){let R=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${x}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${R} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",S=`${r}(${r}(${r}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;r==="avg"&&(S="avgValue / count");let k=Math.floor(i/4)*4,I=i%4,D=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${x}, ${g}, ${y});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${k};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${D}
            }
          }
          setOutput(${S});
        }
      }
    `}};function Jft(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t;Li(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=n,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=T.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return Xe({inputs:{x:o},backend:r});let p=new Xs(c,"avg",!1);return r.runWebGLProgram(p,[o],"float32")}var PH={kernelName:su,backendName:"webgl",kernelFunc:Jft};function tmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,l,u),f=new xc(p,"avg",!1);return r.runWebGLProgram(f,[o],"float32")}var LH={kernelName:iu,backendName:"webgl",kernelFunc:tmt};var fS=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let r=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,p=u-1-t.padInfo.left,f=1/(r*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},mS=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let r=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,d=p-1-t.padInfo.front,h=f-1-t.padInfo.top,x=m-1-t.padInfo.left,g=1/(r*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${x});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function emt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=n,p=[1,1,1],f=T.computePool3DInfo(i.shape,a,l,p,u,c),m=new mS(f);return r.runWebGLProgram(m,[o],i.dtype)}var MH={kernelName:bm,backendName:"webgl",kernelFunc:emt};function rmt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,i=s;Li([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=n,c=T.computePool2DInfo(i.shape,a,l,1,u),p=new fS(c);return r.runWebGLProgram(p,[o],i.dtype)}var zH={kernelName:ym,backendName:"webgl",kernelFunc:rmt};function nmt(e){let{inputs:t,backend:r,attrs:n}=e,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return uf({a:o,b:s,transposeA:i,transposeB:a,backend:r})}var BH={kernelName:au,backendName:"webgl",kernelFunc:nmt};var dS=class{constructor(t,r,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(t,r),T.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(T.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(T.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var hS=class{constructor(t,r,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(t,r),T.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(T.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(T.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var omt=({inputs:e,backend:t,attrs:r})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=e;w.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=r;l==null&&(l=.001);let u=[n,o,s],c=null;i!=null&&(c=i.shape,u.push(i));let p=null;a!=null&&(p=a.shape,u.push(a));let f=B().getBool("WEBGL_PACK_NORMALIZATION")?new hS(n.shape,o.shape,s.shape,c,p,l):new dS(n.shape,o.shape,s.shape,c,p,l);return t.runWebGLProgram(f,u,u[0].dtype)},VH={kernelName:yu,backendName:"webgl",kernelFunc:omt};var gS=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let r=zt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=smt(this.rank),o,s=t.map((i,a)=>`sourceLoc.${dA[a]} = start[${a}] + coords.${dA[a]};`);o=`
        ${r} sourceLoc;
        ${r} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},dA=["x","y","z","w","u","v"];function smt(e){if(e===1)return"sourceLoc";if(e<=6)return dA.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var xS=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=zt(this.rank),n=Ke("coords",this.rank),o=Ke("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${r}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${r} coords = getOutputCoords();
        ${r} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}};function imt(e,t,r,n){let o=n.texData.get(e.dataId),s=n.makeTensorInfo(r,e.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=r,i.dtype=e.dtype;let a=Er.computeFlatOffset(t,w.computeStrides(e.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||e.dataId};let l=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,l+1),s}function Ys(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{begin:s,size:i}=n,[a,l]=Er.parseSliceParams(o,s,i);if(Er.assertParamsValid(o,a,l),w.sizeFromShape(l)===0)return r.makeTensorInfo(l,o.dtype,[]);if(r.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=r.texData.get(o.dataId),f=$U(p.values,a,l,o.shape,o.dtype);return r.makeTensorInfo(l,o.dtype,f)}let{isPacked:u}=r.texData.get(o.dataId),c=Er.isSliceContinous(o.shape,a,l);if(u||!c){let p=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xS(l):new gS(l),f=[a];return r.runWebGLProgram(p,[o],o.dtype,f)}return r.uploadToGPU(o.dataId),imt(o,a,l,r)}var WH={kernelName:Bu,backendName:"webgl",kernelFunc:Ys};var amt=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockShape:s,crops:i}=n;w.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,b)=>y*b),l=T.getReshaped(o.shape,s,a),u=T.getPermuted(l.length,s.length),c=T.getReshapedPermuted(o.shape,s,a),p=T.getSliceBeginCoords(i,s.length),f=T.getSliceSize(c,i,s.length),m=[],d=st({inputs:{x:o},backend:r,attrs:{shape:l}}),h=Ae({inputs:{x:d},backend:r,attrs:{perm:u}}),x=st({inputs:{x:h},backend:r,attrs:{shape:c}}),g=Ys({inputs:{x},backend:r,attrs:{begin:p,size:f}});return m.push(d),m.push(h),m.push(x),m.forEach(y=>r.disposeIntermediateTensorInfo(y)),g},GH={kernelName:lu,backendName:"webgl",kernelFunc:amt};function lmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,weights:s}=t,{size:i}=n,a=r.readSync(o.dataId),l=r.readSync(s.dataId),u=YC(a,l,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,u)}var UH={kernelName:vm,backendName:"webgl",kernelFunc:lmt};function umt(e){let{inputs:t,backend:r}=e,{s0:n,s1:o}=t,s=r.readSync(n.dataId),i=r.readSync(o.dataId),a=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return r.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var HH={kernelName:rw,backendName:"webgl",kernelFunc:umt};var cmt="return float(a != b);",hA=re({opSnippet:cmt,cpuKernelImpl:kU,dtype:"bool"}),qH={kernelName:up,backendName:"webgl",kernelFunc:hA};function kl(e){let{inputs:t,backend:r}=e,{input:n}=t,o=r.texData.get(n.dataId);return Xe({inputs:{x:o.complexTensorInfos.real},backend:r})}var jH={kernelName:Hm,backendName:"webgl",kernelFunc:kl};var pmt="return float(int(x));";function KH(e,t){let r=new Gr(e.shape,pmt),n=t.runWebGLProgram(r,[e],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function gA(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Xe({inputs:{x:o},backend:r});let i=ke(o.shape),a=gA({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),l=jn({inputs:{real:a,imag:i},backend:r});return i.dispose(),r.disposeIntermediateTensorInfo(a),l}if(o.dtype==="complex64"){let i=kl({inputs:{input:o},backend:r}),a=gA({inputs:{x:i},backend:r,attrs:{dtype:s}});return r.disposeIntermediateTensorInfo(i),a}if(!w.hasEncodingLoss(o.dtype,s)){let i=Xe({inputs:{x:o},backend:r});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(r.shouldExecuteOnCPU([o])){let i=r.texData.get(o.dataId).values,[a,l,u]=oU(i,o.shape,o.dtype,s);return r.makeTensorInfo(a,l,u)}if(s==="int32")return KH(o,r);if(s==="bool"){let i=r.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),l=hA({inputs:{a:o,b:i},backend:r});return r.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var XH={kernelName:xi,backendName:"webgl",kernelFunc:gA};var YH="return ceil(x);",fmt=vt({opSnippet:YH,packedOpSnippet:YH,cpuKernelImpl:sU}),QH={kernelName:da,backendName:"webgl",kernelFunc:fmt};var yS=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var bS=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function mmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;B().getBool("WEBGL_PACK_CLIP")?a=new bS(o.shape):a=new yS(o.shape);let l=[[s],[i]];return r.runWebGLProgram(a,[o],o.dtype,l)}var ZH={kernelName:ha,backendName:"webgl",kernelFunc:mmt};var vS=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function JH(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function dmt(e){let{inputs:t,backend:r}=e,{x:n}=t,o=r.texData.get(n.dataId),s=new vS(n.shape),i=[JH(n,o.complexTensorInfos.real),JH(n,o.complexTensorInfos.imag)];return r.runWebGLProgram(s,i,i[0].dtype)}var t5={kernelName:uu,backendName:"webgl",kernelFunc:dmt};var wS=class{constructor(t){this.outputShape=[],this.outputShape=T.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let r=new Array(t.length-1);r[0]=t[0][1];for(let i=1;i<r.length;i++)r[i]=r[i-1]+t[i][1];let n=[`if (yC < ${r[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<r.length;i++){let a=r[i-1];n.push(`else if (yC < ${r[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=r.length,s=r[r.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var SS=class{constructor(t,r){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(t,r);let n=this.outputShape,o=n.length,s=zt(o),i=Ke("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,x)=>`T${x}`);let l=new Array(t.length-1);l[0]=t[0][r];for(let h=1;h<l.length;h++)l[h]=l[h-1]+t[h][r];let u=a[r],c=a.slice(-2),p=a.join(),f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<l.length;h++){let x=l[h-1];f+=`
        if (${u} < ${l[h]}  && ${u} >= ${l[h-1]}) {
          return getChannel(
            getT${h}(${CS(a,u,x)}),
            vec2(${CS(c,u,x)}));
        }`}let m=l.length,d=l[l.length-1];f+=`
        return getChannel(
          getT${m}(${CS(a,u,d)}),
          vec2(${CS(c,u,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function CS(e,t,r){let n=e.indexOf(t);return e.map((s,i)=>i===n?`${s} - ${r}`:s).join()}function cf(e){let{inputs:t,backend:r}=e,{input:n}=t,o=r.texData.get(n.dataId);return Xe({inputs:{x:o.complexTensorInfos.imag},backend:r})}var e5={kernelName:Lm,backendName:"webgl",kernelFunc:cf};function Ch(e,t,r){let n=e[0].dtype;if(n==="complex64"){let m=e.map(y=>kl({inputs:{input:y},backend:r})),d=e.map(y=>cf({inputs:{input:y},backend:r})),h=Ch(m,t,r),x=Ch(d,t,r),g=jn({inputs:{real:h,imag:x},backend:r});return m.forEach(y=>r.disposeIntermediateTensorInfo(y)),d.forEach(y=>r.disposeIntermediateTensorInfo(y)),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),g}let o=r.shouldExecuteOnCPU(e);if(n==="string"&&(o=!0),o){let m=e.map(v=>{let S=[-1,w.sizeFromShape(v.shape.slice(t))];return st({inputs:{x:v},backend:r,attrs:{shape:S}})}),d=m.map(v=>({vals:r.readSync(v.dataId),shape:v.shape})),h=T.computeOutShape(m.map(v=>v.shape),1),x=m[0].shape[0]===1,g=iU(d,h,n,x),y=T.computeOutShape(e.map(v=>v.shape),t),b=r.makeTensorInfo(y,n,g);return m.forEach(v=>r.disposeIntermediateTensorInfo(v)),b}let s=e.filter(m=>w.sizeFromShape(m.shape)>0),i=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let m=i?new Gr(e[0].shape,Mi):new qn(e[0].shape,Mi);return r.runWebGLProgram(m,e,n)}let a=B().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let m=[];for(let h=0;h<s.length;h+=a){let x=s.slice(h,h+a);m.push(Ch(x,t,r))}let d=Ch(m,t,r);for(let h of m)r.disposeIntermediateTensorInfo(h);return d}if(i){let m=new SS(s.map(d=>d.shape),t);return r.runWebGLProgram(m,s,n)}let{tensors2D:l,outShape:u}=hmt(s,t,r),c=new wS(l.map(m=>m.shape)),p=r.runWebGLProgram(c,l,n);l.forEach(m=>r.disposeIntermediateTensorInfo(m));let f=st({inputs:{x:p},attrs:{shape:u},backend:r});return r.disposeIntermediateTensorInfo(p),f}function hmt(e,t,r){let n=T.computeOutShape(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>st({inputs:{x:s},attrs:{shape:[-1,w.sizeFromShape(s.shape.slice(t))]},backend:r})),outShape:n}}function xA(e){let{inputs:t,backend:r,attrs:n}=e,{axis:o}=n,s=w.parseAxisParam(o,t[0].shape)[0],i=t.map(u=>u.shape);T.assertParamsConsistent(i,s);let a=T.computeOutShape(t.map(u=>u.shape),s);if(w.sizeFromShape(a)===0)return r.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(u=>w.sizeFromShape(u.shape)>0);return l.length===1?Xe({inputs:{x:l[0]},backend:r}):Ch(l,s,r)}var r5={kernelName:cu,backendName:"webgl",kernelFunc:xA};var Sh=class{constructor(t,r=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,x=t.dataFormat==="channelsLast",g=x?1:2,y=x?2:3,b=x?3:1,v="",C="";n&&(o?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,C="result = activation(result);");let S=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${C}
        setOutput(result);
      }
    `}},kS=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let r=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,f=t.filterHeight,m=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${r}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var kh=class{constructor(t,r=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=he(this.outputShape.length);let i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,p=c,f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)f+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let x=0;x<c;x++)f+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(p+1)/2;x++){let g=x*2;if(f+=`
           xC = xCCorner + ${g*l};
           `,a===1){if(g<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,l===1&&g>0?f+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<c)){let y=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:f+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?f+=`
                     xC${g+1} = xTexelC${g};
                     `:f+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<c&&(f+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<c&&(f+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<c&&(f+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let m="",d="";n&&(o?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:m=`vec4 activation(vec4 x) {
           ${n}
         }`,d="result = activation(result);");let h=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${d}
         setOutput(result);
       }
     `}};var TS=class{constructor(t,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=he(this.outputShape.length);let{dataFormat:n}=r,o=Le(),s=n==="channelsLast",i=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,u="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${o.output} = result;
      }
    `}};function NS(e,t){let r=e.length;return r>=3?t?[...e.slice(0,-3),e[r-3]*e[r-2],e[r-1]]:[...e.slice(0,-3),e[r-3],e[r-2]*e[r-1]]:!t&&r===1&&e[0]>1?[e[0],1]:null}function IS({x:e,filter:t,convInfo:r,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let l=e.shape,u=n.texData.get(e.dataId),c=r.inChannels,p=l[0]*l[1]*l[2],f=r.outChannels,m=r.dataFormat==="channelsLast",d=!1,h=!1,x,g=[];if(s!=null){let v=NS(s.shape,m);v!=null&&(s=st({inputs:{x:s},backend:n,attrs:{shape:v}}),g.push(s))}if(o!=null){let v=NS(o.shape,m);v!=null&&(o=st({inputs:{x:o},backend:n,attrs:{shape:v}}),g.push(o))}if(!((p===1||f===1)&&c>mA)&&u.isPacked&&m&&u.texture!=null&&l[2]%2!==0&&w.arraysEqual(u.shape.slice(-3),l.slice(-3))){let v=l[0]*l[1]*(l[2]+1),C={dataId:e.dataId,shape:[1,v,r.inChannels],dtype:e.dtype},S=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,w.assert(rf(u.shape,C.shape),()=>`packed reshape ${u.shape} to ${C.shape} isn't free`);let k=st({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}});g.push(k);let I=uf({a:C,b:k,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),D=n.texData.get(I.dataId);w.assert(D.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=S,D.shape=r.outShape,x=Xe({inputs:{x:I},backend:n}),x.shape=r.outShape,g.push(I)}else{let v=r.outHeight*r.outWidth,C=st({inputs:{x:e},backend:n,attrs:{shape:m?[r.batchSize,v,r.inChannels]:[r.batchSize,r.inChannels,v]}}),S=st({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}}),k=uf({a:m?C:S,b:m?S:C,transposeA:!m,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});x=st({inputs:{x:k},backend:n,attrs:{shape:r.outShape}}),g.push(C),g.push(S),g.push(k)}for(let v of g)n.disposeIntermediateTensorInfo(v);return x}function ES({x:e,filter:t,convInfo:r,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:f,dataFormat:m}=r,d=m==="channelsLast",h=l*u*c,x=f*p,g=[r.batchSize,h,x],y=!0,b=!1,v=[];if(s!=null){let Q=NS(s.shape,d);Q!=null&&(s=st({inputs:{x:s},backend:n,attrs:{shape:Q}}),v.push(s))}if(o!=null){let Q=NS(o.shape,d);Q!=null&&(o=st({inputs:{x:o},backend:n,attrs:{shape:Q}}),v.push(o))}let C=st({inputs:{x:t},backend:n,attrs:{shape:[1,h,w.sizeFromShape(t.shape)/h]}});v.push(C);let S=new TS(g,r),k=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],I=n.runWebGLProgram(S,[e],"float32",k),D=st({inputs:{x:I},backend:n,attrs:{shape:g}});v.push(I),v.push(D);let R=o!=null,M=s!=null,U=a==="leakyrelu",j=a?Sl(a,!0):null,K=new wh(d?D.shape:C.shape,d?C.shape:D.shape,d?[r.batchSize,x,r.outChannels]:[r.batchSize,r.outChannels,x],y,b,R,j,M,U),W=d?[D,C]:[C,D];if(o&&W.push(o),M&&W.push(s),U){let Q=n.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));W.push(Q),v.push(Q)}let q=n.runWebGLProgram(K,W,"float32"),X=st({inputs:{x:q},backend:n,attrs:{shape:r.outShape}});v.push(q);for(let Q of v)n.disposeIntermediateTensorInfo(Q);return X}function gmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(l),f=T.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),m;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))m=IS({x:o,filter:s,convInfo:f,backend:r});else if(f.strideWidth<=2&&p==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let h=new kh(f),x=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];m=r.runWebGLProgram(h,[o,s],"float32",x)}else if(B().getBool("WEBGL_CONV_IM2COL"))m=ES({x:o,filter:s,convInfo:f,backend:r});else{let h=new Sh(f);m=r.runWebGLProgram(h,[o,s],"float32")}let d=st({inputs:{x:m},backend:r,attrs:{shape:f.outShape}});return r.disposeIntermediateTensorInfo(m),d}var n5={kernelName:pu,backendName:"webgl",kernelFunc:gmt};var _S=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let r=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${r} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},AS=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let r=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=r-1-t.padInfo.top,l=n-1-t.padInfo.left,u=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${r} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},DS=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let r=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${r} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},RS=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let r=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=r-1-t.padInfo.front,u=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${r}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${r} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function xmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=n,p=T.convertConv2DDataFormat(l),f=T.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),m=new _S(f);return r.runWebGLProgram(m,[o,s],"float32")}var o5={kernelName:Cm,backendName:"webgl",kernelFunc:xmt};function ymt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=n,p=T.convertConv2DDataFormat(u),f=T.computeConv2DInfo(i,s.shape,a,1,l,c,!1,p),m=new AS(f);return r.runWebGLProgram(m,[o,s],"float32")}var s5={kernelName:fu,backendName:"webgl",kernelFunc:ymt};function bmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=n,u=T.computeConv3DInfo(o.shape,s.shape,i,l,a),c=new kS(u);return r.runWebGLProgram(c,[o,s],"float32")}var i5={kernelName:mu,backendName:"webgl",kernelFunc:bmt};function vmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:l}=n,u=T.computeConv3DInfo(o.shape,l,i,1,a),c=new DS(u);return r.runWebGLProgram(c,[o,s],"float32")}var a5={kernelName:Sm,backendName:"webgl",kernelFunc:vmt};function wmt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:l}=n,u=T.computeConv3DInfo(l,s.shape,a,1,i),c=new RS(u);return r.runWebGLProgram(c,[o,s],"float32")}var l5={kernelName:km,backendName:"webgl",kernelFunc:wmt};var Cmt=vs+`
  return cos(x);
`,Smt=vt({opSnippet:Cmt}),u5={kernelName:ga,backendName:"webgl",kernelFunc:Smt};var kmt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Tmt=vt({opSnippet:kmt}),c5={kernelName:xa,backendName:"webgl",kernelFunc:Tmt};var $S=class{constructor(t,r,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,l,u]=t,[c]=r,[p,f]=n;this.outputShape=[c,p,f,u];let m=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${l-1}.0`],[x,g,y]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[b,v,C]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${v};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Nmt=e=>{let{inputs:t,backend:r,attrs:n}=e,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=n,c=new $S(o.shape,s.shape,a,l,u);return r.runWebGLProgram(c,[o,s,i],"float32")},p5={kernelName:Nm,backendName:"webgl",kernelFunc:Nmt};var pf;(function(e){e.Prod="*",e.Sum="+"})(pf||(pf={}));var Nb=class{constructor(t,r,n,o){this.op=t,this.outputShape=r,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===pf.Prod?"1.0":"0.0",a=n?i:`getX(${f5(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1],u="",c="";n?(u=o?`end != ${l-1}`:"end != 0",c=o?"end + 1":"end - 1"):(u=o?`end + pow2 < ${l}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${zt(s)} coords = getOutputCoords();
        int end = ${m5(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${m5(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${f5(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function f5(e,t,r){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${r} for rank ${e} is not yet supported`)}function m5(e,t,r){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${r} for rank ${e} is not yet supported`)}function OS(e,t,r,n,o,s){let i=t.shape.length,a=T.getAxesPermutation([n],i),l=t;a!=null&&(l=Ae({inputs:{x:t},backend:r,attrs:{perm:a}}));let u=T.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=l.shape[u],p=Xe({inputs:{x:l},backend:r});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){let m=new Nb(e,l.shape,!1,s),d=[[f]],h=p;p=r.runWebGLProgram(m,[p],p.dtype,d),r.disposeIntermediateTensorInfo(h)}if(o){let f=new Nb(e,l.shape,o,s),m=p;p=r.runWebGLProgram(f,[p],p.dtype),r.disposeIntermediateTensorInfo(m)}if(a!=null){let f=T.getUndoAxesPermutation(a),m=Ae({inputs:{x:p},backend:r,attrs:{perm:f}});return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(l),m}return p}function Imt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return OS(pf.Prod,o,r,s,i,a)}var d5={kernelName:Tm,backendName:"webgl",kernelFunc:Imt};function Emt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return OS(pf.Sum,o,r,s,i,a)}var h5={kernelName:du,backendName:"webgl",kernelFunc:Emt};function _mt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let l=r.readSync(o.dataId),u=r.readSync(s.dataId),c=YC(l,u,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=r.bufferSync(o),u=r.bufferSync(s),c=nU(l,u,i,a);return r.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var g5={kernelName:Im,backendName:"webgl",kernelFunc:_mt};var FS=class{constructor(t,r,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=r,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${r};
      int offset_h = imod(h, ${r});
      int in_w = w / ${r};
      int offset_w = imod(w, ${r});
      int offset_d = (offset_h * ${r} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Amt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],l=i==="NHWC"?o.shape[1]:o.shape[2],u=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=l*s,f=u*s,m=c/(s*s),d=i==="NHWC"?[a,p,f,m]:[a,m,p,f],h=new FS(d,s,i);return r.runWebGLProgram(h,[o],o.dtype)}var x5={kernelName:Em,backendName:"webgl",kernelFunc:Amt};var Th=class{constructor(t,r=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=he(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels,u="",c="";n&&(o?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Nh=class{constructor(t,r=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=he(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,f=p,m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)m+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;m+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let g=0;g<p;g++)m+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(f+1)/2;g++){let y=g*2;if(m+=`
          xC = xCCorner + ${y*u};
          `,l===1){if(y<p&&(a%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,u===1&&y>0?m+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<p)){let b=a%2===0?w.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:m+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?m+=`
                    xC${y+1} = xTexelC${y};
                    `:m+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<p&&(a%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<p&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<p&&(m+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<p&&(m+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<p&&(m+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let x=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${h}
        setOutput(result);
      }
    `}};function Dmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=n,c=l;c==null&&(c=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=T.computeConv2DInfo(o.shape,s.shape,i,c,a,u,!0),f;B().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?f=new Nh(p):f=new Th(p);let m=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return r.runWebGLProgram(f,[o,s],"float32",m)}var y5={kernelName:hu,backendName:"webgl",kernelFunc:Dmt};var PS=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let r=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${r} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},LS=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let r=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=r-1-t.padInfo.top,a=n-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${r}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${r} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=n,p=T.computeConv2DInfo(o.shape,c,i,a,l,u,!0),f=new PS(p);return r.runWebGLProgram(f,[o,s],"float32")}var b5={kernelName:_m,backendName:"webgl",kernelFunc:Rmt};function $mt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=n,p=T.computeConv2DInfo(c,s.shape,i,a,l,u,!0),f=new LS(p);return r.runWebGLProgram(f,[o,s],"float32")}var v5={kernelName:Am,backendName:"webgl",kernelFunc:$mt};var MS=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Omt(e){let{inputs:t,backend:r}=e,{x:n}=t,o=[...n.shape,...n.shape],s=w.sizeFromShape(n.shape),i=st({inputs:{x:n},backend:r,attrs:{shape:[s]}}),a=new MS(s),l=r.runWebGLProgram(a,[i],i.dtype),u=st({inputs:{x:l},backend:r,attrs:{shape:o}});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}var w5={kernelName:nw,backendName:"webgl",kernelFunc:Omt};var zS=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:r,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:p,left:f}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${r}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Fmt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=n,u=T.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",l),c,p=new zS(u);c=r.runWebGLProgram(p,[o,s],"float32");let f=st({inputs:{x:c},backend:r,attrs:{shape:u.outShape}});return r.disposeIntermediateTensorInfo(c),f}var C5={kernelName:gu,backendName:"webgl",kernelFunc:Fmt};function Pmt(e){let{inputs:t,backend:r,attrs:n}=e,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:l}=T.decodeEinsumEquation(o,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=T.getEinsumComputePath(a,l),p=c.length,f=null,m=i.length,d=[];for(let h=0;h<p;++h){for(let x of c[h]){let{permutationIndices:g,expandDims:y}=T.getEinsumPermutation(m,l[x]),b;T.isIdentityPermutation(g)?b=s[x]:(b=Ae({inputs:{x:s[x]},backend:r,attrs:{perm:g}}),d.push(b));let v=b.shape.slice();for(let C=0;C<y.length;++C)v.splice(y[C],0,1);w.arraysEqual(b.shape,v)||(b=st({inputs:{x:b},backend:r,attrs:{shape:v}}),d.push(b)),f===null?f=b:(f=kb({inputs:{a:b,b:f},backend:r}),d.push(f))}h<p-1&&(u[h]>=0&&(f=lf({inputs:{x:f},backend:r,attrs:{axis:u[h]-(i.length-m),keepDims:!1}}),d.push(f)),m--)}for(let h of d)h!==f&&r.disposeIntermediateTensorInfo(h);return f}var S5={kernelName:Dm,backendName:"webgl",kernelFunc:Pmt};var Lmt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Mmt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,zmt=vt({opSnippet:Lmt,packedOpSnippet:Mmt}),k5={kernelName:ba,backendName:"webgl",kernelFunc:zmt};var Bmt="return (b >= 1.0) ? a : a * (b + 1.0);",Vmt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Wmt=e=>{let{inputs:t,backend:r}=e,{dy:n,y:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bs(Vmt,n.shape,o.shape):new Po(Bmt,n.shape,o.shape);return r.runWebGLProgram(s,[n,o],n.dtype)},T5={kernelName:Rm,backendName:"webgl",kernelFunc:Wmt};var Gmt=`
  return vec4(equal(a, b));
`,Umt="return float(a == b);",Hmt=re({opSnippet:Umt,packedOpSnippet:Gmt,dtype:"bool",cpuKernelImpl:aU}),N5={kernelName:rp,backendName:"webgl",kernelFunc:Hmt};var qmt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T.ERF_P};
  float a1 = ${T.ERF_A1};
  float a2 = ${T.ERF_A2};
  float a3 = ${T.ERF_A3};
  float a4 = ${T.ERF_A4};
  float a5 = ${T.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,jmt=vt({opSnippet:qmt}),I5={kernelName:va,backendName:"webgl",kernelFunc:jmt};var Kmt=vs+`
  return exp(x);
`,Xmt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yA=vt({opSnippet:Kmt,packedOpSnippet:Xmt,cpuKernelImpl:lU,dtype:"float32"}),E5={kernelName:wa,backendName:"webgl",kernelFunc:yA};function BS(e){let{inputs:t,attrs:r,backend:n}=e,{dim:o}=r,{input:s}=t,i=s.shape.length,a=s.shape.slice(),l=o;return o<0&&(w.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),st({inputs:{x:s},backend:n,attrs:{shape:a}})}var _5={kernelName:xu,backendName:"webgl",kernelFunc:BS};var A5="return exp(x) - 1.0;",Ymt=vt({opSnippet:A5,packedOpSnippet:A5,cpuKernelImpl:uU}),D5={kernelName:Ca,backendName:"webgl",kernelFunc:Ymt};var Ib=class{constructor(t,r,n){this.variableNames=["real","imag"];let o=r[1];this.outputShape=r;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function VS(e,t,r){let n=r.texData.get(e.dataId),o=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=o/s,a=st({inputs:{x:e},backend:r,attrs:{shape:[i,s]}}),l=a.shape,u=new Ib("real",l,t),c=new Ib("imag",l,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],f=r.runWebGLProgram(u,p,"float32"),m=r.runWebGLProgram(c,p,"float32"),d=jn({inputs:{real:f,imag:m},backend:r});r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m);let h=st({inputs:{x:d},backend:r,attrs:{shape:e.shape}});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(d),h}function Qmt(e){let{inputs:t,backend:r}=e,{input:n}=t;return VS(n,!1,r)}var R5={kernelName:$m,backendName:"webgl",kernelFunc:Qmt};var WS=class{constructor(t,r){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Tl(e){let{backend:t,attrs:r}=e,{shape:n,value:o}=r,{dtype:s}=r;if(s=s||w.inferDtype(o),s==="string"){let i=w.getArrayFromDType(s,w.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new WS(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var $5={kernelName:Om,backendName:"webgl",kernelFunc:Tl};var GS=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let r=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${r} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${r}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var O5={kernelName:Fm,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:r}=e,n=t,o=new GS(r.shape);return n.runWebGLProgram(o,[r],r.dtype)}};var F5="return floor(x);",Zmt=vt({opSnippet:F5,packedOpSnippet:F5,cpuKernelImpl:cU}),P5={kernelName:Sa,backendName:"webgl",kernelFunc:Zmt};var Jmt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,tdt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,edt=re({opSnippet:Jmt,packedOpSnippet:tdt,dtype:"int32"}),L5={kernelName:ka,backendName:"webgl",kernelFunc:edt};var US=class{constructor(t){this.variableNames=["A"];let r=Le(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${r.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var HS=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let r=Le(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${r.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${r.output} = result;
      }
    `}};var M5={kernelName:Jg,backendName:"webgl",kernelFunc:rdt},Ih,bA=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function rdt(e){let{inputs:t,backend:r,attrs:n}=e,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[l,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[u,l],p=[u,l,s];if(a||i){let h=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Ih==null||h!==bA)&&(bA=h,Ih=document.createElement("canvas").getContext("2d",{willReadFrequently:bA})),Ih.canvas.width=l,Ih.canvas.height=u,Ih.drawImage(o,0,0,l,u),o=Ih.canvas}let f=r.makeTensorInfo(c,"int32");r.texData.get(f.dataId).usage=nn.PIXELS,r.gpgpu.uploadPixelDataToTexture(r.getTexture(f.dataId),o);let m=B().getBool("WEBGL_PACK")?new HS(p):new US(p),d=r.runWebGLProgram(m,[f],"int32");return r.disposeData(f.dataId),d}function ndt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:d}=n,h=T.convertConv2DDataFormat(c),x=T.computeConv2DInfo(o.shape,s.shape,l,p,u,f,!1,h),g,y=[],b=i!=null,v=a!=null,C=m==="leakyrelu",S=()=>{let I=[o,s],D=(R,M)=>{if(M==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let U=st({inputs:{x:R},backend:r,attrs:{shape:[R.shape[0],1,1]}});return y.push(U),U}return R};if(b&&I.push(D(i,c)),v&&I.push(D(a,c)),C){let R=r.makeTensorInfo([],"float32",w.createScalarValue(d,"float32"));I.push(R),y.push(R)}return I};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))g=IS({x:o,filter:s,convInfo:x,backend:r,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:d});else if(x.strideWidth<=2&&h==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let I=m?Sl(m,!0):null,D=new kh(x,b,I,v,C),R=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],M=S();g=r.runWebGLProgram(D,M,"float32",R)}else if(B().getBool("WEBGL_CONV_IM2COL"))g=ES({x:o,filter:s,convInfo:x,backend:r,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:d});else{let I=m?Sl(m,!1):null,D=new Sh(x,b,I,v,C),R=S();g=r.runWebGLProgram(D,R,"float32")}let k=st({inputs:{x:g},backend:r,attrs:{shape:x.outShape}});return y.push(g),y.forEach(I=>r.disposeIntermediateTensorInfo(I)),k}var z5={kernelName:pp,backendName:"webgl",kernelFunc:ndt};function odt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=n,d=[],h=c;h==null&&(h=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(l,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);let x=T.computeConv2DInfo(o.shape,s.shape,l,h,u,p,!0),g=B().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,y=f?Sl(f,g):null,b=[o,s],v=i!=null,C=a!=null,S=f==="leakyrelu";if(v&&b.push(i),C&&b.push(a),S){let R=r.makeTensorInfo([],"float32",w.createScalarValue(m,"float32"));b.push(R),d.push(R)}let k;g?k=new Nh(x,v,y,C,S):k=new Th(x,v,y,C,S);let I=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],D=r.runWebGLProgram(k,b,"float32",I);return d.forEach(R=>r.disposeIntermediateTensorInfo(R)),D}var B5={kernelName:fp,backendName:"webgl",kernelFunc:odt};var qS=class{constructor(t,r,n,o){this.sliceDim=t,this.strides=r,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=n;let s=zt(n.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function sdt(e){let{inputs:t,backend:r}=e,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=w.sizeFromShape(n.shape),[l,u,c,p]=T.prepareAndValidate(n,o),f=st({inputs:{x:o},backend:r,attrs:{shape:[u,i]}}),m=st({inputs:{x:n},backend:r,attrs:{shape:[w.sizeFromShape(n.shape)/c,c]}});if(r.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let g=r.readSync(o.dataId),y=r.bufferSync(n),b=pU(g,y,n.dtype,u,i,c,p,n.shape,a);return r.makeTensorInfo(l,n.dtype,b.values)}let d=new qS(i,p,[u,c],n.shape),h=r.runWebGLProgram(d,[m,f],m.dtype),x=st({inputs:{x:h},backend:r,attrs:{shape:l}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(h),x}var V5={kernelName:ow,backendName:"webgl",kernelFunc:sdt};var jS=class{constructor(t,r){this.variableNames=["A","indices"],this.outputShape=r,this.rank=r.length;let n=zt(this.rank),o=idt(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function idt(e,t){let r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<e.length;o++)o===2?n.push("index"):n.push(`${r[o]}`);return n.join()}function vA(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,l=w.parseAxisParam(i,o.shape)[0];if(B().get("DEBUG")){let y=r.readSync(s.dataId),b=o.shape[l];for(let v=0;v<y.length;++v){let C=y[v];w.assert(C<=b-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${b-1}]`)}}let u=T.segment_util.collectGatherOpShapeInfo(o,s,l,a),c=w.sizeFromShape(s.shape),p=[],f=st({inputs:{x:o},backend:r,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=st({inputs:{x:s},backend:r,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(f),p.push(m);let d=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(r.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let y=r.bufferSync(m),b=r.bufferSync(f),v=fU(b,y,d);return p.forEach(C=>r.disposeIntermediateTensorInfo(C)),r.makeTensorInfo(u.outputShape,v.dtype,v.values)}let h=new jS(f.shape,d),x=r.runWebGLProgram(h,[f,m],f.dtype);p.push(x);let g=st({inputs:{x},backend:r,attrs:{shape:u.outputShape}});return p.forEach(y=>r.disposeIntermediateTensorInfo(y)),g}var W5={kernelName:bu,backendName:"webgl",kernelFunc:vA};var adt="return float(a > b);",ldt=`
  return vec4(greaterThan(a, b));
`,udt=re({opSnippet:adt,packedOpSnippet:ldt,cpuKernelImpl:mU,dtype:"bool"}),G5={kernelName:np,backendName:"webgl",kernelFunc:udt};var cdt="return float(a >= b);",pdt=`
  return vec4(greaterThanEqual(a, b));
`,fdt=re({opSnippet:cdt,packedOpSnippet:pdt,dtype:"bool",cpuKernelImpl:dU}),U5={kernelName:Ta,backendName:"webgl",kernelFunc:fdt};function mdt(e){let{inputs:t,backend:r}=e,{input:n}=t;return VS(n,!0,r)}var H5={kernelName:Pm,backendName:"webgl",kernelFunc:mdt};var ddt="return float(!isnan(x) && !isinf(x));",hdt=vt({opSnippet:ddt,dtype:"bool"}),q5={kernelName:Na,backendName:"webgl",kernelFunc:hdt};var gdt="return float(isinf(x));",xdt=vt({opSnippet:gdt,dtype:"bool"}),j5={kernelName:Ia,backendName:"webgl",kernelFunc:xdt};var ydt="return float(isnan(x));",bdt=vt({opSnippet:ydt,dtype:"bool"}),K5={kernelName:Ea,backendName:"webgl",kernelFunc:bdt};var vdt="return float(a < b);",wdt=`
  return vec4(lessThan(a, b));
`,Cdt=re({opSnippet:vdt,packedOpSnippet:wdt,cpuKernelImpl:hU,dtype:"bool"}),X5={kernelName:op,backendName:"webgl",kernelFunc:Cdt};var Sdt="return float(a <= b);",kdt=`
  return vec4(lessThanEqual(a, b));
`,Tdt=re({opSnippet:Sdt,packedOpSnippet:kdt,cpuKernelImpl:gU,dtype:"bool"}),Y5={kernelName:sp,backendName:"webgl",kernelFunc:Tdt};function Ndt(e){let{backend:t,attrs:r}=e,{start:n,stop:o,num:s}=r,i=xU(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var Q5={kernelName:sw,backendName:"webgl",kernelFunc:Ndt};var Idt=vs+`
  return x < 0.0 ? 0./0. : log(x);
`,Edt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,_dt=vt({opSnippet:Idt,packedOpSnippet:Edt,cpuKernelImpl:yU}),Z5={kernelName:_a,backendName:"webgl",kernelFunc:_dt};var Adt=vs+`
  return log(1.0 + x);
`,Ddt=vt({opSnippet:Adt}),J5={kernelName:Aa,backendName:"webgl",kernelFunc:Ddt};var Rdt="return float(a >= 1.0 && b >= 1.0);",$dt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Odt=re({opSnippet:Rdt,packedOpSnippet:$dt,dtype:"bool"}),t6={kernelName:ip,backendName:"webgl",kernelFunc:Odt};var Fdt="return float(!(x >= 1.0));",Pdt=vt({opSnippet:Fdt}),e6={kernelName:ap,backendName:"webgl",kernelFunc:Pdt};var Ldt="return float(a >= 1.0 || b >= 1.0);",Mdt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,zdt=re({opSnippet:Ldt,packedOpSnippet:Mdt,dtype:"bool"}),r6={kernelName:lp,backendName:"webgl",kernelFunc:zdt};var KS=class{constructor(t,r,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=r,a=t[3]-1;this.outputShape=t;let l,u=`float(${n}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var XS=class{constructor(t,r,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=r,a=t[3]-1;this.outputShape=t;let l,u=`float(${n}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var Bdt=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=n,u=B().getBool("WEBGL_PACK_NORMALIZATION")?new XS(o.shape,s,i,a,l):new KS(o.shape,s,i,a,l);return r.runWebGLProgram(u,[o],o.dtype)},n6={kernelName:wu,backendName:"webgl",kernelFunc:Bdt};var YS=class{constructor(t,r,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=r,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${r})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${r} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Vdt=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=n,p=new YS(o.shape,a,l,u,c);return r.runWebGLProgram(p,[o,s,i],o.dtype)},o6={kernelName:Mm,backendName:"webgl",kernelFunc:Vdt};function s6(e,t,r,n){let o=w.sizeFromShape(t),i=w.sizeFromShape(e.shape)/o,a=st({inputs:{x:e},attrs:{shape:[i,o]},backend:n}),l=yo(a,e.dtype,"max",n),u=st({inputs:{x:l},attrs:{shape:r},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}function wA(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,l=w.parseAxisParam(s,o.shape),u=l,c=T.getAxesPermutation(u,a),p=c!=null,f=r.shouldExecuteOnCPU([o]),m=o;if(p){if(f){let b=r.texData.get(m.dataId).values,v=new Array(a);for(let k=0;k<v.length;k++)v[k]=o.shape[c[k]];let C=sf(b,o.shape,o.dtype,c,v);m=r.makeTensorInfo(v,o.dtype);let S=r.texData.get(m.dataId);S.values=C}else m=gc(o,c,r);u=T.getInnerMostAxes(u.length,a)}T.assertAxesAreInnerMostDims("max",u,a);let[d,h]=T.computeOutAndReduceShapes(m.shape,u),x=d;i&&(x=T.expandShapeToKeepDim(d,l));let g;if(f){let b=r.texData.get(m.dataId).values,v=bU(b,w.sizeFromShape(h),x,o.dtype);g=r.makeTensorInfo(x,o.dtype);let C=r.texData.get(g.dataId);C.values=v}else g=s6(m,h,x,r);return p&&r.disposeIntermediateTensorInfo(m),g}var i6={kernelName:Cu,backendName:"webgl",kernelFunc:wA};var Wdt=vh+`
  return max(a, b);
`,Gdt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+zi+`
  return result;
`,Udt=re({opSnippet:Wdt,packedOpSnippet:Gdt,cpuKernelImpl:vU}),a6={kernelName:Da,backendName:"webgl",kernelFunc:Udt};function Hdt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t;Li(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=n,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=T.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return Xe({inputs:{x:o},backend:r});let p=new Xs(c,"max",!1);return r.runWebGLProgram(p,[o],o.dtype)}var l6={kernelName:Su,backendName:"webgl",kernelFunc:Hdt};function qdt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=n,c=[1,1,1],p=T.computePool3DInfo(o.shape,s,i,c,a,u,l),f=new xc(p,"max",!1);return r.runWebGLProgram(f,[o],o.dtype)}var u6={kernelName:ku,backendName:"webgl",kernelFunc:qdt};var QS=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let r=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,l=i-1-t.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},ZS=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let r=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=l-1-t.padInfo.front,f=u-1-t.padInfo.top,m=c-1-t.padInfo.left,d=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function jdt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=n,p=[1,1,1],f=T.computePool3DInfo(i.shape,a,l,p,u,c),m=new xc(f,"max",!0),d=r.runWebGLProgram(m,[i],i.dtype),h=new ZS(f),x=r.runWebGLProgram(h,[o,d],i.dtype);return r.disposeIntermediateTensorInfo(d),x}var c6={kernelName:Bm,backendName:"webgl",kernelFunc:jdt};function Kdt(e){let{inputs:t,backend:r,attrs:n}=e,{dy:o,input:s,output:i}=t,a=s;Li([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=n,f=T.computePool2DInfo(a.shape,l,u,1,c,p),m=!0,d=new Xs(f,"max",m),h=r.runWebGLProgram(d,[a],a.dtype),x=new QS(f),g=r.runWebGLProgram(x,[o,h],a.dtype);return r.disposeIntermediateTensorInfo(h),g}var p6={kernelName:zm,backendName:"webgl",kernelFunc:Kdt};function f6(e,t,r,n){let o=new Xs(r,"max",!1),s=n.runWebGLProgram(o,[e],"float32");o=new Xs(r,"max",!0,!0,t);let i=n.runWebGLProgram(o,[e],"float32");return[s,i]}var m6={kernelName:iw,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,l=r;w.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=T.computePool2DInfo(n.shape,o,s,u,i),[p,f]=f6(n,a,c,l);return[p,f]}};function d6(e,t,r,n){let o=w.sizeFromShape(t),i=w.sizeFromShape(e.shape)/o,a=st({inputs:{x:e},attrs:{shape:[i,o]},backend:n}),l=yo(a,"float32","mean",n),u=st({inputs:{x:l},attrs:{shape:r},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}var h6={kernelName:Tu,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{keepDims:o,axis:s}=t,i=r,a=n.shape.length,l=w.parseAxisParam(s,n.shape),u=l,c=T.getAxesPermutation(u,a),p=c!=null,f=i.shouldExecuteOnCPU([n]),m=[],d=n;if(p){if(f){let v=i.texData.get(d.dataId).values,C=new Array(a);for(let I=0;I<C.length;I++)C[I]=n.shape[c[I]];let S=sf(v,n.shape,n.dtype,c,C);d=i.makeTensorInfo(C,n.dtype);let k=i.texData.get(d.dataId);k.values=S}else d=gc(n,c,i);m.push(d),u=T.getInnerMostAxes(u.length,a)}T.assertAxesAreInnerMostDims("sum",u,a);let[h,x]=T.computeOutAndReduceShapes(d.shape,u),g=h;o&&(g=T.expandShapeToKeepDim(h,l));let y=d6(d,x,g,i);for(let b of m)i.disposeIntermediateTensorInfo(b);return y}};function Xdt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,l=w.parseAxisParam(s,o.shape),u=l,c=T.getAxesPermutation(u,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:r,attrs:{perm:c}}),u=T.getInnerMostAxes(u.length,o.shape.length)),T.assertAxesAreInnerMostDims("min",u,a);let[f,m]=T.computeOutAndReduceShapes(p.shape,u),d=w.sizeFromShape(m),h=st({inputs:{x:p},backend:r,attrs:{shape:[-1,d]}}),x=yo(h,h.dtype,"min",r),g;if(i){let y=T.expandShapeToKeepDim(f,l);g=st({inputs:{x},backend:r,attrs:{shape:y}})}else g=st({inputs:{x},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),c!=null&&r.disposeIntermediateTensorInfo(p),g}var g6={kernelName:Nu,backendName:"webgl",kernelFunc:Xdt};var Ydt=vh+`
  return min(a, b);
`,Qdt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+zi+`
  return result;
`,Zdt=re({opSnippet:Ydt,packedOpSnippet:Qdt,cpuKernelImpl:wU}),x6={kernelName:Ra,backendName:"webgl",kernelFunc:Zdt};var JS=class{constructor(t,r,n){this.variableNames=["x"],this.outputShape=r.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=zt(o),i=r.map(c=>c[0]).join(","),a=r.map((c,p)=>c[0]+t[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),u=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var tk=class{constructor(t,r,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r.map((d,h)=>d[0]+t[h]+d[1]);let o=t.length,s=zt(o),i=r.map(d=>d[0]).join(","),a=r.map((d,h)=>d[0]+t[h]).join(","),l=Ke("rc",o),u=Ke("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=n==="reflect"?0:1,m="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}};var Jdt=({inputs:e,backend:t,attrs:r})=>{let{x:n}=e,{paddings:o,mode:s}=r,i=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tk(n.shape,o,s):new JS(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},y6={kernelName:Iu,backendName:"webgl",kernelFunc:Jdt};var tht=`if (b == 0.0) return NAN;
  return mod(a, b);`,eht=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+zi+`
  return result;
`,rht=re({opSnippet:tht,packedOpSnippet:eht}),b6={kernelName:$a,backendName:"webgl",kernelFunc:rht};var ek=class{constructor(t,r,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${r-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${r-1}));
      }
    `}};var nht=`
if (a == b) {
  return 1.0;
};
return a / b;`,oht=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,CA=re({opSnippet:nht,packedOpSnippet:oht,checkOutOfBounds:!0}),v6={kernelName:ya,backendName:"webgl",kernelFunc:CA};var w6="return a - b;",SA=re({opSnippet:w6,packedOpSnippet:w6,supportsComplex:!0,cpuKernelImpl:VU}),C6={kernelName:Xa,backendName:"webgl",kernelFunc:SA};function kA(e){let{inputs:t,backend:r,attrs:n}=e,{logits:o}=t,{dim:s}=n,i=w.parseAxisParam([s],o.shape),a=wA({inputs:{x:o},backend:r,attrs:{reductionIndices:i,keepDims:!1}}),l=T.expandShapeToKeepDim(a.shape,i),u=st({inputs:{x:a},backend:r,attrs:{shape:l}}),c=SA({inputs:{a:o,b:u},backend:r}),p=yA({inputs:{x:c},backend:r}),f=lf({inputs:{x:p},backend:r,attrs:{axis:i,keepDims:!1}}),m=st({inputs:{x:f},backend:r,attrs:{shape:l}}),d=CA({inputs:{a:p,b:m},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),d}var S6={kernelName:Uu,backendName:"webgl",kernelFunc:kA};function sht(e){let{inputs:t,backend:r,attrs:n}=e,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,l=a?o:kA({inputs:{logits:o},backend:r,attrs:{dim:o.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new ek(u,c,s),f=[[i]],m=r.runWebGLProgram(p,[l],"int32",f);return a||r.disposeIntermediateTensorInfo(l),m}var k6={kernelName:aw,backendName:"webgl",kernelFunc:sht};var iht=xr+`
  return -x;
`,aht=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function lht(e){let{inputs:t,backend:r}=e,{x:n}=t;if(r.shouldExecuteOnCPU([n])){let s=r.texData.get(n.dataId),[i,a]=SU(s.values,n.shape,n.dtype);return r.makeTensorInfo(a,n.dtype,i)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new qn(n.shape,aht):o=new Gr(n.shape,iht),r.runWebGLProgram(o,[n],n.dtype)}var T6={kernelName:Eu,backendName:"webgl",kernelFunc:lht};var uht=tn.nonMaxSuppressionV3Impl;function cht(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=n,u=r.readSync(o.dataId),c=r.readSync(s.dataId),{selectedIndices:p}=uht(u,c,i,a,l);return r.makeTensorInfo([p.length],"int32",new Int32Array(p))}var N6={kernelName:Vm,backendName:"webgl",kernelFunc:cht};var pht=tn.nonMaxSuppressionV4Impl;function fht(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=n,c=r.readSync(o.dataId),p=r.readSync(s.dataId),{selectedIndices:f,validOutputs:m}=pht(c,p,i,a,l,u);return[r.makeTensorInfo([f.length],"int32",new Int32Array(f)),r.makeTensorInfo([],"int32",new Int32Array([m]))]}var I6={kernelName:Wm,backendName:"webgl",kernelFunc:fht};var mht=tn.nonMaxSuppressionV5Impl;function dht(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=n,c=r.readSync(o.dataId),p=r.readSync(s.dataId),f=i,m=a,d=l,h=u,{selectedIndices:x,selectedScores:g}=mht(c,p,f,m,d,h);return[r.makeTensorInfo([x.length],"int32",new Int32Array(x)),r.makeTensorInfo([g.length],"float32",new Float32Array(g))]}var E6={kernelName:Gm,backendName:"webgl",kernelFunc:dht};var rk=class{constructor(t,r,n,o){this.variableNames=["indices"],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var hht=e=>{let{inputs:t,backend:r,attrs:n}=e,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:l}=n,u=w.sizeFromShape(o.shape),c=new rk(u,i,a,l),p=st({inputs:{x:o},backend:r,attrs:{shape:[u]}}),f=r.runWebGLProgram(c,[p],s);r.disposeIntermediateTensorInfo(p);let m=[...o.shape,i],d=st({inputs:{x:f},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(f),d},_6={kernelName:Au,backendName:"webgl",kernelFunc:hht};function Eb(e){let{inputs:t,backend:r}=e,{x:n}=t;if(n.dtype==="complex64"){let o=kl({inputs:{input:n},backend:r}),s=Eb({inputs:{x:o},backend:r}),i=cf({inputs:{input:n},backend:r}),a=Eb({inputs:{x:i},backend:r}),l=jn({inputs:{real:s,imag:a},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),l}else return Tl({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:r})}var A6={kernelName:ju,backendName:"webgl",kernelFunc:Eb};function D6(e){let{inputs:t,backend:r}=e,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=kl({inputs:{input:n},backend:r}),s=D6({inputs:{x:o},backend:r}),i=cf({inputs:{input:n},backend:r}),a=Eb({inputs:{x:i},backend:r}),l=jn({inputs:{real:s,imag:a},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),l}else return Tl({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:r})}var R6={kernelName:_u,backendName:"webgl",kernelFunc:D6};function ght(e){let{inputs:t,backend:r,attrs:n}=e,{axis:o}=n;if(t.length===1)return BS({inputs:{input:t[0]},backend:r,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=BS({inputs:{input:c},backend:r,attrs:{dim:o}});return a.push(p),p}),u=xA({inputs:l,backend:r,attrs:{axis:o}});return a.forEach(c=>r.disposeIntermediateTensorInfo(c)),u}var $6={kernelName:Du,backendName:"webgl",kernelFunc:ght};var nk=class{constructor(t,r,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=r.map((u,c)=>u[0]+t[c]+u[1]);let o=t.length,s=zt(o),i=r.map(u=>u[0]).join(","),a=r.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var ok=class{constructor(t,r,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=r.map((h,x)=>h[0]+t[x]+h[1]);let o=t.length,s=zt(o),i=r.map(h=>h[0]).join(","),a=r.map((h,x)=>h[0]+t[x]).join(","),l=Ke("rc",o),u=Ke("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${c}) {`],m=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,x=o===1?2:4;h<x;h++)d+=`
        ${f[h]}
        if (${m}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${u.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var TA=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{paddings:s,constantValue:i}=n;if(w.sizeFromShape(o.shape)===0){let u=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return Tl({backend:r,attrs:{shape:u,value:i,dtype:o.dtype}})}let a=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ok(o.shape,s,i):new nk(o.shape,s,i),l=[[i]];return r.runWebGLProgram(a,[o],o.dtype,l)},O6={kernelName:Ru,backendName:"webgl",kernelFunc:TA};var xht=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,yht=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+zi+`
  return result;
`,bht=re({opSnippet:xht,packedOpSnippet:yht}),F6={kernelName:Fa,backendName:"webgl",kernelFunc:bht};function vht(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,l=[],u=w.parseAxisParam(s,o.shape),c=u,p=T.getAxesPermutation(c,a),f=o;p!=null&&(f=Ae({inputs:{x:o},backend:r,attrs:{perm:p}}),c=T.getInnerMostAxes(c.length,a),l.push(f)),T.assertAxesAreInnerMostDims("prod",c,a);let m;if(r.shouldExecuteOnCPU([f])){let d=r.texData.get(f.dataId).values,{outVals:h,outShape:x,outDtype:g}=TU(f.shape,f.dtype,d,c);m=r.makeTensorInfo(x,g,h)}else{let[d,h]=T.computeOutAndReduceShapes(f.shape,c),x=w.sizeFromShape(h),g=st({inputs:{x:f},backend:r,attrs:{shape:[-1,x]}}),y=yp(o.dtype),b=yo(g,y,"prod",r);m=st({inputs:{x:b},backend:r,attrs:{shape:d}}),l.push(g),l.push(b)}if(i){l.push(m);let d=T.expandShapeToKeepDim(m.shape,u);m=st({inputs:{x:m},backend:r,attrs:{shape:d}})}return l.forEach(d=>r.disposeIntermediateTensorInfo(d)),m}var P6={kernelName:Ou,backendName:"webgl",kernelFunc:vht};function wht(e){let{inputs:t,backend:r,attrs:n}=e,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=n,l=o.map(g=>r.readSync(g.dataId)),u=o.map(g=>g.shape),c=r.readSync(s.dataId),p=r.readSync(i.dataId),[f,m,d]=NU(l,u,c,s.shape,s.dtype,p,i.shape,a),h=f.map(g=>r.makeTensorInfo([g.length],"int32",g)),x=r.makeTensorInfo(d,s.dtype,m);return h.concat([x])}var L6={kernelName:lw,backendName:"webgl",kernelFunc:wht};function Cht(e){let{inputs:t,backend:r}=e,{starts:n,limits:o,deltas:s}=t,i=r.readSync(n.dataId),a=r.readSync(o.dataId),l=r.readSync(s.dataId),[u,c]=IU(i,n.shape,n.dtype,a,o.shape,l,s.shape),p=r.makeTensorInfo([u.length],"int32",u),f=r.makeTensorInfo([c.length],n.dtype,c);return[p,f]}var M6={kernelName:uw,backendName:"webgl",kernelFunc:Cht};function Sht(e){let{inputs:t,backend:r,attrs:n}=e,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=n,u=r.readSync(o.dataId),c=r.readSync(s.dataId),p=r.readSync(i.dataId),f=a.map(x=>r.readSync(x.dataId)),m=a.map(x=>x.shape),[d,h]=EU(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,m,l);return r.makeTensorInfo(d,s.dtype,h)}var z6={kernelName:cw,backendName:"webgl",kernelFunc:Sht};var NA=e=>{let{backend:t,attrs:r}=e,{start:n,stop:o,step:s,dtype:i}=r,a=_U(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},B6={kernelName:Um,backendName:"webgl",kernelFunc:NA};var kht="return 1.0 / x;",Tht=vt({opSnippet:kht}),V6={kernelName:Pa,backendName:"webgl",kernelFunc:Tht};var Nht=xr+`
  return (x < 0.0) ? 0.0 : x;
`,Iht=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Eht=vt({opSnippet:Nht,packedOpSnippet:Iht}),W6={kernelName:La,backendName:"webgl",kernelFunc:Eht};var _ht=xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Aht=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dht=vt({opSnippet:_ht,packedOpSnippet:Aht}),G6={kernelName:Ma,backendName:"webgl",kernelFunc:Dht};var sk=class{constructor(t,r,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,r,n,u];let c=[o&&r>1?a-1:a,o&&n>1?l-1:l],p=[o&&r>1?r-1:r,o&&n>1?n-1:n],f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var ik=class{constructor(t,r,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,r,n,u];let c=[o&&r>1?a-1:a,o&&n>1?l-1:l],p=[o&&r>1?r-1:r,o&&n>1?n-1:n],f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Rht(e){let{inputs:t,backend:r,attrs:n}=e,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[l,u]=a,c=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ik(o.shape,l,u,s,i):new sk(o.shape,l,u,s,i);return r.runWebGLProgram(c,[o],"float32")}var U6={kernelName:Lu,backendName:"webgl",kernelFunc:Rht};var ak=class{constructor(t,r,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=r;let[,o,s]=r,[,i,a]=t,l=[n&&i>1?o-1:o,n&&a>1?s-1:s],u=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,m=1/p,d=Math.ceil(f)*2+2,h=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function $ht(e){let{inputs:t,backend:r,attrs:n}=e,{images:o,dy:s}=t,{alignCorners:i}=n,a=new ak(s.shape,o.shape,i);return r.runWebGLProgram(a,[s],s.dtype)}var H6={kernelName:jm,backendName:"webgl",kernelFunc:$ht};var lk=class{constructor(t,r,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,r,n,u];let c=[o&&r>1?a-1:a,o&&n>1?l-1:l],p=[o&&r>1?r-1:r,o&&n>1?n-1:n],f=o?"0.5":"0.0",m;s?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var uk=class{constructor(t,r,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,r,n,u];let c=[o&&r>1?a-1:a,o&&n>1?l-1:l],p=[o&&r>1?r-1:r,o&&n>1?n-1:n],f=o?"0.5":"0.0",m;s?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Oht(e){let{inputs:t,backend:r,attrs:n}=e,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[l,u]=a,c=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new uk(o.shape,l,u,s,i):new lk(o.shape,l,u,s,i);return r.runWebGLProgram(c,[o],o.dtype)}var q6={kernelName:Pu,backendName:"webgl",kernelFunc:Oht};var ck=class{constructor(t,r,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=r;let[,o,s]=r,[,i,a]=t,l=[n&&i>1?o-1:o,n&&a>1?s-1:s],u=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,m=1/p,d=Math.ceil(f)*2+2,h=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Fht(e){let{inputs:t,backend:r,attrs:n}=e,{images:o,dy:s}=t,{alignCorners:i}=n,a=new ck(s.shape,o.shape,i);return r.runWebGLProgram(a,[s],s.dtype)}var j6={kernelName:qm,backendName:"webgl",kernelFunc:Fht};var pk=class{constructor(t,r){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>r.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,l)=>o(l)).join(","),i=zt(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var fk=class{constructor(t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=Ke("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=zt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${s}){
            result.g = ${u(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(d){return f(d)}function u(d){return d[n-1]="("+d[n-1]+" + 1)",f(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",f(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",f(d)}function f(d){let h=t.map((y,b)=>m(b,d)),x=h.join(","),g=h.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${g}))`}function m(d,h){return r.indexOf(d)!==-1&&t[d]!==1?`${t[d]} - ${h[d]} - 1`:`${h[d]}`}}};function Pht(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{dims:s}=n,i=o.shape.length,a=w.parseAxisParam(s,o.shape);if(i===0)return Xe({inputs:{x:o},backend:r});let l=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fk(o.shape,a):new pk(o.shape,a);return r.runWebGLProgram(l,[o],o.dtype)}var K6={kernelName:Mu,backendName:"webgl",kernelFunc:Pht};var mk=class{constructor(t,r){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof r=="number"?s=`float outputValue = ${r.toFixed(2)};`:s=`
        vec3 fill = vec3(${r.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var X6={kernelName:Jm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:o,fillValue:s,center:i}=t,a=r,l=new mk(n.shape,s),[u,c]=T.getImageCenter(i,n.shape[1],n.shape[2]),p=[[u,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(l,[n],n.dtype,p)}};var Lht=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Mht=vt({opSnippet:Lht}),Y6={kernelName:za,backendName:"webgl",kernelFunc:Mht};var zht="return inversesqrt(x);",Bht=vt({opSnippet:zht,cpuKernelImpl:AU}),Q6={kernelName:Ba,backendName:"webgl",kernelFunc:Bht};var Eh=class{constructor(t,r,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=zt(s.length),u=zt(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,d=r>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${r}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Vht(e){let{inputs:t,backend:r,attrs:n}=e,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=T.calculateShapes(s,o,i),f=[p/u,u];if(p===0)return r.makeTensorInfo(i,o.dtype);let m=st({inputs:{x:o},backend:r,attrs:{shape:[l,a]}}),d=st({inputs:{x:s},backend:r,attrs:{shape:[l,u]}}),h=r.makeTensorInfo([],"float32",new Float32Array([0])),x=new Eh(l,a,m.shape.length,d.shape.length,c,f),g=r.runWebGLProgram(x,[d,m,h],d.dtype),y=st({inputs:{x:g},backend:r,attrs:{shape:i}});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(h),y}var Z6={kernelName:pw,backendName:"webgl",kernelFunc:Vht};var dk=class{constructor(t,r,n,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(r+1))}; ++i) { if (left >= right) break;`,a=B().getNumber("WEBGL_VERSION")===2?s:i,l=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Wht(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:o,values:s}=t,{side:i}=n,a=new dk(o.shape[0],o.shape[1],s.shape[1],i),l=[[o.shape[1]]];return r.runWebGLProgram(a,[o,s],"int32",l)}var J6={kernelName:fw,backendName:"webgl",kernelFunc:Wht};var hk=class{constructor(t,r,n){this.variableNames=["c","a","b"],this.outputShape=r;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<r.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);o=l.join(),s=u.join()}let i=zt(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Ght(e){let{inputs:t,backend:r}=e,{condition:n,t:o,e:s}=t,i=new hk(n.shape.length,o.shape,o.shape.length);return r.runWebGLProgram(i,[n,o,s],or(o.dtype,s.dtype))}var tq={kernelName:zu,backendName:"webgl",kernelFunc:Ght};var Uht=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${T.SELU_SCALEALPHA};
  float scale = ${T.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Hht=vt({opSnippet:Uht}),eq={kernelName:Va,backendName:"webgl",kernelFunc:Hht};var qht=vs+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,jht=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Kht=vt({opSnippet:qht,packedOpSnippet:jht,cpuKernelImpl:RU}),rq={kernelName:Ha,backendName:"webgl",kernelFunc:Kht};var Xht=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Yht=vt({opSnippet:Xht}),nq={kernelName:Ua,backendName:"webgl",kernelFunc:Yht};var Qht=vs+`
  return sin(x);
`,Zht=vt({opSnippet:Qht}),oq={kernelName:Wa,backendName:"webgl",kernelFunc:Zht};var Jht=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,tgt=vt({opSnippet:Jht}),sq={kernelName:Ga,backendName:"webgl",kernelFunc:tgt};var egt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,rgt=vt({opSnippet:egt}),iq={kernelName:qa,backendName:"webgl",kernelFunc:rgt};var ngt=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{blockShape:s,paddings:i}=n;w.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((g,y)=>g*y),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<o.shape.length;++g)l.push([0,0]);let u=[],c=TA({inputs:{x:o},backend:r,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(c.shape,s,a,!1),f=T.getPermuted(p.length,s.length,!1),m=T.getReshapedPermuted(c.shape,s,a,!1),d=st({inputs:{x:c},backend:r,attrs:{shape:p}}),h=Ae({inputs:{x:d},backend:r,attrs:{perm:f}}),x=st({inputs:{x:h},backend:r,attrs:{shape:m}});return u.push(c),u.push(d),u.push(h),u.forEach(g=>r.disposeIntermediateTensorInfo(g)),x},aq={kernelName:Wu,backendName:"webgl",kernelFunc:ngt};function ogt(e){let{inputs:t,backend:r}=e,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=r.readSync(n.dataId),l=r.readSync(o.dataId),u=r.readSync(s.dataId),c=r.readSync(i.dataId)[0],[p,f,m,d,h]=OU(a,n.shape,n.dtype,l,o.dtype,u,c);return[r.makeTensorInfo(f,n.dtype,p),r.makeTensorInfo([f[0]],o.dtype,m),r.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(x=>Number(x)))),r.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var lq={kernelName:mw,backendName:"webgl",kernelFunc:ogt};function sgt(e){let{inputs:t,backend:r}=e,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(r.readSync(o.dataId)),a=r.readSync(n.dataId),l=Array.from(r.readSync(s.dataId)),[u,c,p]=FU(a,n.shape,n.dtype,i,l);return[r.makeTensorInfo(c,n.dtype,u),r.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var uq={kernelName:dw,backendName:"webgl",kernelFunc:sgt};function igt(e){let{inputs:t,backend:r}=e,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=r.readSync(n.dataId),a=r.readSync(o.dataId),l=r.readSync(s.dataId),[u,c]=ZC(i,n.shape,n.dtype,a,l,!0);return r.makeTensorInfo(c,n.dtype,u)}var cq={kernelName:hw,backendName:"webgl",kernelFunc:igt};function agt(e){let{inputs:t,backend:r}=e,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=r.readSync(n.dataId),a=r.readSync(o.dataId),l=r.readSync(s.dataId),[u,c]=ZC(i,n.shape,n.dtype,a,l);return r.makeTensorInfo(c,n.dtype,u)}var pq={kernelName:gw,backendName:"webgl",kernelFunc:agt};function lgt(e){let{inputs:t,backend:r,attrs:n}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=T.calculateShapes(s,o,a),m=!1;if(s.dtype==="string"){let g=r.bufferSync(o),y=r.bufferSync(s),b=w.decodeString(r.readSync(i.dataId)[0]),v=DU(g,y,a,f,c,u,l,p,b,m);return r.makeTensorInfo(a,v.dtype,v.values)}let d=new Eh(u,l,o.shape.length,s.shape.length,p,[f,1],m),h=r.runWebGLProgram(d,[s,o,i],s.dtype),x=st({inputs:{x:h},backend:r,attrs:{shape:a}});return r.disposeIntermediateTensorInfo(h),x}var fq={kernelName:xw,backendName:"webgl",kernelFunc:lgt};function ugt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=w.parseAxisParam(i,o.shape)[0],l=T.prepareSplitSize(o,s,a),u=o.shape.length,c=new Array(u).fill(0),p=o.shape.slice();return l.map(f=>{let m=[...p];m[a]=f;let d=Ys({inputs:{x:o},backend:r,attrs:{begin:c,size:m}});return c[a]+=f,d})}var mq={kernelName:Gu,backendName:"webgl",kernelFunc:ugt};var dq="return sqrt(x);",cgt=vt({opSnippet:dq,packedOpSnippet:dq,cpuKernelImpl:PU}),hq={kernelName:ja,backendName:"webgl",kernelFunc:cgt};var pgt="return x * x;",fgt=vt({opSnippet:pgt}),gq={kernelName:Km,backendName:"webgl",kernelFunc:fgt};var xq="return (a - b) * (a - b);",mgt=re({opSnippet:xq,packedOpSnippet:xq}),yq={kernelName:Ka,backendName:"webgl",kernelFunc:mgt};function dgt({inputs:e,attrs:t,backend:r}){let{x:n}=e,o=xr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Gr(n.shape,o);return r.runWebGLProgram(s,[n],n.dtype)}var bq={kernelName:Za,backendName:"webgl",kernelFunc:dgt};var gk=class{constructor(t,r,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=zt(n.length),i=zt(n.length),a="";if(o===1)a="coords * strides + begin";else{let l=0;a=n.map((u,c)=>(l++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${r});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function hgt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=n,{finalShapeSparse:m,finalShape:d,isIdentity:h,sliceDim0:x,isSimpleSlice:g,begin:y,end:b,strides:v}=Er.sliceInfo(o.shape,s,i,a,l,u,c,p,f),C;if(h)C=st({inputs:{x:o},backend:r,attrs:{shape:d}});else if(x||g){w.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let k=Er.computeOutShape(y,b,v),I=Ys({inputs:{x:o},backend:r,attrs:{begin:y,size:k}});C=st({inputs:{x:I},backend:r,attrs:{shape:d}}),r.disposeIntermediateTensorInfo(I)}else if(r.shouldExecuteOnCPU([o])){let I=r.readSync(o.dataId),D=Ct(o.shape,o.dtype,I),R=LU(m,D,v,y);C=r.makeTensorInfo(d,o.dtype,R.values)}else{let I=new gk(y,v,m);C=r.runWebGLProgram(I,[o],o.dtype)}let S=st({inputs:{x:C},backend:r,attrs:{shape:d}});return r.disposeIntermediateTensorInfo(C),S}var vq={kernelName:Xm,backendName:"webgl",kernelFunc:hgt};function ggt(e){let{inputs:t,backend:r,attrs:n}=e,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=n,{data:c,dataSplits:p}=t,f=r.readSync(c.dataId),m=r.readSync(p.dataId),[d,h]=MU(f,m,o,s,i,a,l,u);return[r.makeTensorInfo([d.length],"string",d),r.makeTensorInfo(p.shape,"int32",h)]}var wq={kernelName:yw,backendName:"webgl",kernelFunc:ggt};function xgt(e){let{inputs:t,backend:r,attrs:n}=e,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=r.readSync(s.dataId),l=r.readSync(i.dataId)[0],[u,c,p]=zU(a,l,o),f=c.length;return[r.makeTensorInfo([f,2],"int32",u),r.makeTensorInfo([f],"string",c),r.makeTensorInfo([2],"int32",new Int32Array(p))]}var Cq={kernelName:bw,backendName:"webgl",kernelFunc:xgt};function ygt(e){let{inputs:t,backend:r,attrs:n}=e,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=r.readSync(s.dataId),a=BU(i,o);return r.makeTensorInfo(s.shape,"int32",a)}var Sq={kernelName:vw,backendName:"webgl",kernelFunc:ygt};var bgt="return tan(x);",vgt=vt({opSnippet:bgt}),kq={kernelName:Ya,backendName:"webgl",kernelFunc:vgt};var wgt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Cgt=vt({opSnippet:wgt}),Tq={kernelName:Qa,backendName:"webgl",kernelFunc:Cgt};var xk=class{constructor(t,r){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*r[i];this.outputShape=n,this.rank=n.length;let o=zt(this.rank),s=Sgt(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Sgt(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<e.length;o++)n.push(`imod(${r[o]}, ${e[o]})`);return n.join()}function IA(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let l=r.readSync(o.dataId),u=o.dtype==="string"?l.map(f=>w.decodeString(f)):l,c=Ct(o.shape,o.dtype,u),p=WU(c,s);return r.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new xk(o.shape,s);return r.runWebGLProgram(i,[o],o.dtype)}var Nq={kernelName:bi,backendName:"webgl",kernelFunc:IA};var yk=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},bk=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function ff(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function Iq(e){let t=1;for(;t<e;)t*=2;return t}function kgt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o}=t,{k:s,sorted:i}=n,a=B().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=B().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=o.shape,c=u[u.length-1];if(r.shouldExecuteOnCPU([o])||c<a||s>l){let R=r.readSync(o.dataId),[M,U]=GU(R,u,o.dtype,s,i);return[r.makeTensorInfo(M.shape,M.dtype,M.values),r.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return u[u.length-1]=0,[r.makeTensorInfo(u,o.dtype,[]),r.makeTensorInfo(u,"int32",[])];if(c===1)return[o,Tl({attrs:{shape:u,dtype:"int32",value:0},backend:r})];let p=r.texData.get(o.dataId),f=p!==null&&p.isPacked,m=f?r.unpackTensor(o):o,h=w.sizeFromShape(u)/c,x=st({inputs:{x:m},attrs:{shape:[h,c]},backend:r});f&&ff(r,m);let g=Iq(s),y=Iq(c),b=null,v=()=>b===null?[x,x]:[x,b],C=(R,M,U)=>{let j=v(),K=new yk(U),q=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[R],[M]],X=b;b=r.runWebGLProgram(K,j,"int32",q),ff(r,X)};for(let R=1;R<g;R*=2){let M=R*2;for(let U=R;U>=1;U/=2)C(M,U,[h,y])}for(let R=y;R>g;R/=2){let M=v(),U=new bk([h,R/2]),K=[[c],[b===null?1:0],[g]],W=b;b=r.runWebGLProgram(U,M,"int32",K),ff(r,W);let q=g/2,X=q*2;for(let Q=q;Q>=1;Q/=2)C(X,Q,b.shape)}let S=b;b=Ys({inputs:{x:b},backend:r,attrs:{begin:0,size:[h,s]}}),ff(r,S);let k=vA({inputs:{x,indices:b},backend:r,attrs:{axis:1,batchDims:1}});ff(r,x);let I=u.slice(0,-1);I.push(s),S=b,b=st({inputs:{x:b},attrs:{shape:I},backend:r}),ff(r,S);let D=k;return k=st({inputs:{x:k},attrs:{shape:I},backend:r}),ff(r,D),[k,b]}var Eq={kernelName:Ym,backendName:"webgl",kernelFunc:kgt};var vk=class{constructor(t,r,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${r}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${r}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Tgt(e){let{inputs:t,backend:r,attrs:n}=e,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=n,[c,p,f,m]=o.shape,[d,h]=u!=null?u:[p,f],x=[c,d,h,m],g=new vk(p,f,i,a,l,x);return r.runWebGLProgram(g,[o,s],"float32")}var _q={kernelName:Qm,backendName:"webgl",kernelFunc:Tgt};function Ngt(e){let{inputs:t,attrs:r,backend:n}=e,{axis:o}=r,{x:s}=t;Li(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:l,indices:u}=UU(i,o,s.shape,s.dtype);return[n.makeTensorInfo(l,s.dtype,a),n.makeTensorInfo([u.length],"int32",u)]}var Aq={kernelName:Zm,backendName:"webgl",kernelFunc:Ngt};function Igt(e){let{inputs:t,backend:r,attrs:n}=e,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,l=o.shape[s],u=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(u[c++]=i.shape[h]);let p=[],f=new Array(a).fill(0),m=i.shape.slice();m[s]=1;let d=new Array(l);for(let h=0;h<d.length;h++){f[s]=h;let x=Ys({inputs:{x:i},backend:r,attrs:{begin:f,size:m}}),g=st({inputs:{x},backend:r,attrs:{shape:u}});d[h]=g,p.push(x)}return p.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}var Dq={kernelName:Hu,backendName:"webgl",kernelFunc:Igt};var wk=class{constructor(t,r){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let l="0.0",u="sumValue",c=Math.floor(n/4)*4,p=n%4,f=`
        sumValue += dot(values, segFilter);
    `,m="";s%n>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function Egt(e){let{inputs:t,backend:r,attrs:n}=e,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,l=[],u=0,c=T.getAxesPermutation([u],a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:r,attrs:{perm:c}}),l.push(p),u=T.getInnerMostAxes(1,a)[0]);let f=T.segment_util.computeOutShape(p.shape,u,i),m=w.sizeFromShape([p.shape[u]]),d=st({inputs:{x:p},backend:r,attrs:{shape:[-1,m]}});l.push(d);let h=yp(o.dtype),x=(v,C,S,k,I)=>{let D=v.shape[0],R=v.shape[1],M=T.segment_util.segOpComputeOptimalWindowSize(R,I),U={windowSize:M,inSize:R,batchSize:D,numSegments:I},j=new wk(U,C),K=r.compileAndRun(j,[v,S],k);if(l.push(K),K.shape[1]===I)return K;let W=NA({backend:r,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),q=IA({inputs:{x:W},backend:r,attrs:{reps:[R/M]}});return l.push(W),l.push(q),x(K,C,q,k,I)},g=x(d,"unsortedSegmentSum",s,h,i),y=st({inputs:{x:g},backend:r,attrs:{shape:f}}),b=y;if(c!=null){l.push(y);let v=T.getUndoAxesPermutation(c);b=Ae({inputs:{x:b},backend:r,attrs:{perm:v}})}return l.forEach(v=>r.disposeIntermediateTensorInfo(v)),b}var Rq={kernelName:qu,backendName:"webgl",kernelFunc:Egt};var _gt=[xH,bH,vH,wH,SH,kH,TH,NH,_H,AH,DH,RH,$H,OH,FH,PH,LH,MH,zH,BH,VH,GH,UH,HH,XH,QH,ZH,aH,t5,r5,n5,o5,s5,i5,a5,l5,u5,c5,p5,d5,h5,g5,x5,y5,b5,v5,w5,C5,S5,k5,T5,N5,I5,E5,_5,D5,R5,$5,O5,P5,L5,M5,z5,B5,V5,W5,G5,U5,iH,H5,e5,q5,j5,K5,lH,X5,Y5,Q5,Z5,J5,t6,e6,r6,n6,o6,i6,a6,l6,u6,c6,p6,m6,h6,g6,x6,y6,b6,k6,pH,T6,N6,I6,E6,qH,_6,R6,$6,O6,F6,uH,P6,L6,M6,z6,B6,jH,v6,V6,W6,G6,mH,U6,H6,q6,j6,K6,X6,Y6,Q6,Z6,J6,tq,eq,rq,nq,oq,sq,WH,S6,iq,aq,lq,uq,cq,pq,fq,mq,hq,gq,yq,bq,vq,wq,Cq,Sq,C6,hH,kq,Tq,Nq,Eq,_q,gH,Aq,Dq,Rq,A6];for(let e of _gt)Cw(e);var Fq=Yt(EA());var _h=Yt(oe());function _A({coloredAttention:e,style:t={},isSelected:r=!1}){let n=(0,_h.useRef)(null);return(0,_h.useEffect)(()=>{let o=n.current;cx.toPixels(e.toInt(),o)},[e]),_h.default.createElement("canvas",{ref:n,style:ae({imageRendering:"pixelated",borderColor:r?"rgba(0,0,200,0.5)":"#DDD",borderStyle:"solid",borderWidth:1,boxShadow:r?"0px 0px 3px 3px rgba(0,0,200,0.4)":void 0,width:200},t)})}var $q=Yt(EA()),Sk=Yt(oe());function Agt(e,t,r,n){let o=t,s=t,i=0,a=t;return typeof n=="number"&&r==="DESTINATION_TO_SOURCE"?(o=n,s=n,i=t,a=t):typeof n=="number"&&r==="SOURCE_TO_DESTINATION"&&(o=t,s=t,i=n,a=n),e.slice([o,i],[s+1-o,a+1-i])}function Dgt({focusedToken:e,onClickToken:t,onMouseEnterToken:r,onMouseLeaveToken:n,maxAttentionAcrossHeads:o,text:s,tokenIndex:i,tokensView:a}){let l=e!==null&&e===i,c=Agt(o,i,a,e).mean(0).mean(0),[p,f,m]=c.arraySync(),d=(0,$q.default)({r:p,g:f,b:m}),h=d.getBrightness()<180?"white":"black";return Sk.default.createElement("button",{style:{backgroundColor:d.toRgbString(),borderColor:"#DDD",borderStyle:"solid",borderWidth:0,borderRightWidth:1,color:h,display:"inline-block",marginBottom:3,padding:"3px 0px",boxShadow:l?"0px 0px 3px 3px rgba(0,0,200,0.4)":void 0},onClick:()=>t(i),onMouseEnter:()=>r(i),onMouseLeave:n,dangerouslySetInnerHTML:{__html:s.replace(" ","&nbsp;")}})}function Oq({coloredAttention:e,focusedHead:t,focusedToken:r,onClickToken:n,onMouseEnterToken:o,onMouseLeaveToken:s,tokens:i,tokensView:a}){let l=typeof t=="number"?e.slice([t],[1]):e,u=xx("hdsc -> dsch",l).min(3);return Sk.default.createElement("div",null,i.map((c,p)=>Sk.default.createElement(Dgt,{focusedToken:r,onClickToken:n,onMouseEnterToken:o,onMouseLeaveToken:s,key:p,maxAttentionAcrossHeads:u,text:c,tokenIndex:p,tokensView:a})))}function Rgt(e){let r=sr(e).arraySync(),n=r.map((o,s)=>o.map(i=>i.map(a=>{let l=(0,Fq.default)({h:s/r.length*360,s:.8,l:1-.75*a}),{r:u,g:c,b:p}=l.toRgb();return[u,c,p]})));return sr(n)}function Pq({tokens:e,attention:t,headLabels:r}){let[n,o]=(0,Ye.useState)("DESTINATION_TO_SOURCE"),{focused:s,onClick:i,onMouseEnter:a,onMouseLeave:l}=Qc(),{focused:u,onClick:c,onMouseEnter:p,onMouseLeave:f}=Qc(),m=(0,Ye.useMemo)(()=>Rgt(t),[t]),d=m.unstack(0),h=xx("hdsc -> dsch",m).min(3),x=s===null?h:d[s];return Ye.default.createElement("div",null,Ye.default.createElement("div",{style:{display:"flex"}},Ye.default.createElement("div",null,Ye.default.createElement("h4",null,"Attention Patterns"),Ye.default.createElement(_A,{coloredAttention:x})),Ye.default.createElement("div",{style:{marginLeft:15}},Ye.default.createElement("h4",null,"Head selector",Ye.default.createElement("span",{style:{fontWeight:"normal"}}," ","(hover to focus, click to lock)")),Ye.default.createElement("div",{style:{display:"flex",flexWrap:"wrap"}},d.map((g,y)=>{var b;return Ye.default.createElement("figure",{key:y,style:{margin:0,marginRight:15},onClick:()=>i(y),onMouseEnter:()=>a(y),onMouseLeave:l},Ye.default.createElement(_A,{coloredAttention:g,style:{width:80},isSelected:y===s}),Ye.default.createElement("figcaption",null,(b=r==null?void 0:r[y])!=null?b:`Head ${y}`))})))),Ye.default.createElement("div",{className:"tokens"},Ye.default.createElement("h4",{style:{display:"inline-block",marginRight:15}},"Tokens",Ye.default.createElement("span",{style:{fontWeight:"normal"}}," (click to focus)")),Ye.default.createElement("select",{value:n,onChange:g=>o(g.target.value)},Ye.default.createElement("option",{value:"DESTINATION_TO_SOURCE"},"Source \u2190 Destination"),Ye.default.createElement("option",{value:"SOURCE_TO_DESTINATION"},"Destination \u2190 Source")),Ye.default.createElement("div",null,Ye.default.createElement(Oq,{coloredAttention:m,focusedHead:s,focusedToken:u,onClickToken:c,onMouseEnterToken:p,onMouseLeaveToken:f,tokens:e,tokensView:n}))))}var l$=Yt(oe());var zl=Yt(oe());function AA(e,t){if(e==null)return{};var r={},n=Object.keys(e),o,s;for(s=0;s<n.length;s++)o=n[s],!(t.indexOf(o)>=0)&&(r[o]=e[o]);return r}function Qs(){return Qs=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},Qs.apply(this,arguments)}var De=Yt(oe());var kk=Yt(oe());var DA=function(t){return t.reduce(function(r,n){var o=n[0],s=n[1];return r[o]=s,r},{})},RA=typeof window!="undefined"&&window.document&&window.document.createElement?kk.useLayoutEffect:kk.useEffect;var Vc=Yt(oe()),NX=Yt(qR());var br="top",qr="bottom",Or="right",Tr="left",UT="auto",zc=[br,qr,Or,Tr],Pl="start",Ef="end",nX="clippingParents",HT="viewport",sg="popper",oX="reference",jR=zc.reduce(function(e,t){return e.concat([t+"-"+Pl,t+"-"+Ef])},[]),qT=[].concat(zc,[UT]).reduce(function(e,t){return e.concat([t,t+"-"+Pl,t+"-"+Ef])},[]),Oyt="beforeRead",Fyt="read",Pyt="afterRead",Lyt="beforeMain",Myt="main",zyt="afterMain",Byt="beforeWrite",Vyt="write",Wyt="afterWrite",sX=[Oyt,Fyt,Pyt,Lyt,Myt,zyt,Byt,Vyt,Wyt];function an(e){return e?(e.nodeName||"").toLowerCase():null}function pr(e){if(e==null)return window;if(e.toString()!=="[object Window]"){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function Es(e){var t=pr(e).Element;return e instanceof t||e instanceof Element}function jr(e){var t=pr(e).HTMLElement;return e instanceof t||e instanceof HTMLElement}function ig(e){if(typeof ShadowRoot=="undefined")return!1;var t=pr(e).ShadowRoot;return e instanceof t||e instanceof ShadowRoot}function Gyt(e){var t=e.state;Object.keys(t.elements).forEach(function(r){var n=t.styles[r]||{},o=t.attributes[r]||{},s=t.elements[r];!jr(s)||!an(s)||(Object.assign(s.style,n),Object.keys(o).forEach(function(i){var a=o[i];a===!1?s.removeAttribute(i):s.setAttribute(i,a===!0?"":a)}))})}function Uyt(e){var t=e.state,r={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,r.popper),t.styles=r,t.elements.arrow&&Object.assign(t.elements.arrow.style,r.arrow),function(){Object.keys(t.elements).forEach(function(n){var o=t.elements[n],s=t.attributes[n]||{},i=Object.keys(t.styles.hasOwnProperty(n)?t.styles[n]:r[n]),a=i.reduce(function(l,u){return l[u]="",l},{});!jr(o)||!an(o)||(Object.assign(o.style,a),Object.keys(s).forEach(function(l){o.removeAttribute(l)}))})}}var iX={name:"applyStyles",enabled:!0,phase:"write",fn:Gyt,effect:Uyt,requires:["computeStyles"]};function ln(e){return e.split("-")[0]}var ii=Math.max,_f=Math.min,Ll=Math.round;function ag(){var e=navigator.userAgentData;return e!=null&&e.brands?e.brands.map(function(t){return t.brand+"/"+t.version}).join(" "):navigator.userAgent}function v0(){return!/^((?!chrome|android).)*safari/i.test(ag())}function _s(e,t,r){t===void 0&&(t=!1),r===void 0&&(r=!1);var n=e.getBoundingClientRect(),o=1,s=1;t&&jr(e)&&(o=e.offsetWidth>0&&Ll(n.width)/e.offsetWidth||1,s=e.offsetHeight>0&&Ll(n.height)/e.offsetHeight||1);var i=Es(e)?pr(e):window,a=i.visualViewport,l=!v0()&&r,u=(n.left+(l&&a?a.offsetLeft:0))/o,c=(n.top+(l&&a?a.offsetTop:0))/s,p=n.width/o,f=n.height/s;return{width:p,height:f,top:c,right:u+p,bottom:c+f,left:u,x:u,y:c}}function Af(e){var t=_s(e),r=e.offsetWidth,n=e.offsetHeight;return Math.abs(t.width-r)<=1&&(r=t.width),Math.abs(t.height-n)<=1&&(n=t.height),{x:e.offsetLeft,y:e.offsetTop,width:r,height:n}}function w0(e,t){var r=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(r&&ig(r)){var n=t;do{if(n&&e.isSameNode(n))return!0;n=n.parentNode||n.host}while(n)}return!1}function Qn(e){return pr(e).getComputedStyle(e)}function KR(e){return["table","td","th"].indexOf(an(e))>=0}function bn(e){return((Es(e)?e.ownerDocument:e.document)||window.document).documentElement}function Ml(e){return an(e)==="html"?e:e.assignedSlot||e.parentNode||(ig(e)?e.host:null)||bn(e)}function aX(e){return!jr(e)||Qn(e).position==="fixed"?null:e.offsetParent}function Hyt(e){var t=/firefox/i.test(ag()),r=/Trident/i.test(ag());if(r&&jr(e)){var n=Qn(e);if(n.position==="fixed")return null}var o=Ml(e);for(ig(o)&&(o=o.host);jr(o)&&["html","body"].indexOf(an(o))<0;){var s=Qn(o);if(s.transform!=="none"||s.perspective!=="none"||s.contain==="paint"||["transform","perspective"].indexOf(s.willChange)!==-1||t&&s.willChange==="filter"||t&&s.filter&&s.filter!=="none")return o;o=o.parentNode}return null}function ai(e){for(var t=pr(e),r=aX(e);r&&KR(r)&&Qn(r).position==="static";)r=aX(r);return r&&(an(r)==="html"||an(r)==="body"&&Qn(r).position==="static")?t:r||Hyt(e)||t}function Df(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function Rf(e,t,r){return ii(e,_f(t,r))}function lX(e,t,r){var n=Rf(e,t,r);return n>r?r:n}function C0(){return{top:0,right:0,bottom:0,left:0}}function S0(e){return Object.assign({},C0(),e)}function k0(e,t){return t.reduce(function(r,n){return r[n]=e,r},{})}var qyt=function(t,r){return t=typeof t=="function"?t(Object.assign({},r.rects,{placement:r.placement})):t,S0(typeof t!="number"?t:k0(t,zc))};function jyt(e){var t,r=e.state,n=e.name,o=e.options,s=r.elements.arrow,i=r.modifiersData.popperOffsets,a=ln(r.placement),l=Df(a),u=[Tr,Or].indexOf(a)>=0,c=u?"height":"width";if(!(!s||!i)){var p=qyt(o.padding,r),f=Af(s),m=l==="y"?br:Tr,d=l==="y"?qr:Or,h=r.rects.reference[c]+r.rects.reference[l]-i[l]-r.rects.popper[c],x=i[l]-r.rects.reference[l],g=ai(s),y=g?l==="y"?g.clientHeight||0:g.clientWidth||0:0,b=h/2-x/2,v=p[m],C=y-f[c]-p[d],S=y/2-f[c]/2+b,k=Rf(v,S,C),I=l;r.modifiersData[n]=(t={},t[I]=k,t.centerOffset=k-S,t)}}function Kyt(e){var t=e.state,r=e.options,n=r.element,o=n===void 0?"[data-popper-arrow]":n;o!=null&&(typeof o=="string"&&(o=t.elements.popper.querySelector(o),!o)||!w0(t.elements.popper,o)||(t.elements.arrow=o))}var uX={name:"arrow",enabled:!0,phase:"main",fn:jyt,effect:Kyt,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function As(e){return e.split("-")[1]}var Xyt={top:"auto",right:"auto",bottom:"auto",left:"auto"};function Yyt(e){var t=e.x,r=e.y,n=window,o=n.devicePixelRatio||1;return{x:Ll(t*o)/o||0,y:Ll(r*o)/o||0}}function cX(e){var t,r=e.popper,n=e.popperRect,o=e.placement,s=e.variation,i=e.offsets,a=e.position,l=e.gpuAcceleration,u=e.adaptive,c=e.roundOffsets,p=e.isFixed,f=i.x,m=f===void 0?0:f,d=i.y,h=d===void 0?0:d,x=typeof c=="function"?c({x:m,y:h}):{x:m,y:h};m=x.x,h=x.y;var g=i.hasOwnProperty("x"),y=i.hasOwnProperty("y"),b=Tr,v=br,C=window;if(u){var S=ai(r),k="clientHeight",I="clientWidth";if(S===pr(r)&&(S=bn(r),Qn(S).position!=="static"&&a==="absolute"&&(k="scrollHeight",I="scrollWidth")),S=S,o===br||(o===Tr||o===Or)&&s===Ef){v=qr;var D=p&&S===C&&C.visualViewport?C.visualViewport.height:S[k];h-=D-n.height,h*=l?1:-1}if(o===Tr||(o===br||o===qr)&&s===Ef){b=Or;var R=p&&S===C&&C.visualViewport?C.visualViewport.width:S[I];m-=R-n.width,m*=l?1:-1}}var M=Object.assign({position:a},u&&Xyt),U=c===!0?Yyt({x:m,y:h}):{x:m,y:h};if(m=U.x,h=U.y,l){var j;return Object.assign({},M,(j={},j[v]=y?"0":"",j[b]=g?"0":"",j.transform=(C.devicePixelRatio||1)<=1?"translate("+m+"px, "+h+"px)":"translate3d("+m+"px, "+h+"px, 0)",j))}return Object.assign({},M,(t={},t[v]=y?h+"px":"",t[b]=g?m+"px":"",t.transform="",t))}function Qyt(e){var t=e.state,r=e.options,n=r.gpuAcceleration,o=n===void 0?!0:n,s=r.adaptive,i=s===void 0?!0:s,a=r.roundOffsets,l=a===void 0?!0:a;if(!1)var u;var c={placement:ln(t.placement),variation:As(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:o,isFixed:t.options.strategy==="fixed"};t.modifiersData.popperOffsets!=null&&(t.styles.popper=Object.assign({},t.styles.popper,cX(Object.assign({},c,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:i,roundOffsets:l})))),t.modifiersData.arrow!=null&&(t.styles.arrow=Object.assign({},t.styles.arrow,cX(Object.assign({},c,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})}var pX={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:Qyt,data:{}};var jT={passive:!0};function Zyt(e){var t=e.state,r=e.instance,n=e.options,o=n.scroll,s=o===void 0?!0:o,i=n.resize,a=i===void 0?!0:i,l=pr(t.elements.popper),u=[].concat(t.scrollParents.reference,t.scrollParents.popper);return s&&u.forEach(function(c){c.addEventListener("scroll",r.update,jT)}),a&&l.addEventListener("resize",r.update,jT),function(){s&&u.forEach(function(c){c.removeEventListener("scroll",r.update,jT)}),a&&l.removeEventListener("resize",r.update,jT)}}var fX={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:Zyt,data:{}};var Jyt={left:"right",right:"left",bottom:"top",top:"bottom"};function lg(e){return e.replace(/left|right|bottom|top/g,function(t){return Jyt[t]})}var tbt={start:"end",end:"start"};function KT(e){return e.replace(/start|end/g,function(t){return tbt[t]})}function $f(e){var t=pr(e),r=t.pageXOffset,n=t.pageYOffset;return{scrollLeft:r,scrollTop:n}}function Of(e){return _s(bn(e)).left+$f(e).scrollLeft}function XR(e,t){var r=pr(e),n=bn(e),o=r.visualViewport,s=n.clientWidth,i=n.clientHeight,a=0,l=0;if(o){s=o.width,i=o.height;var u=v0();(u||!u&&t==="fixed")&&(a=o.offsetLeft,l=o.offsetTop)}return{width:s,height:i,x:a+Of(e),y:l}}function YR(e){var t,r=bn(e),n=$f(e),o=(t=e.ownerDocument)==null?void 0:t.body,s=ii(r.scrollWidth,r.clientWidth,o?o.scrollWidth:0,o?o.clientWidth:0),i=ii(r.scrollHeight,r.clientHeight,o?o.scrollHeight:0,o?o.clientHeight:0),a=-n.scrollLeft+Of(e),l=-n.scrollTop;return Qn(o||r).direction==="rtl"&&(a+=ii(r.clientWidth,o?o.clientWidth:0)-s),{width:s,height:i,x:a,y:l}}function Ff(e){var t=Qn(e),r=t.overflow,n=t.overflowX,o=t.overflowY;return/auto|scroll|overlay|hidden/.test(r+o+n)}function XT(e){return["html","body","#document"].indexOf(an(e))>=0?e.ownerDocument.body:jr(e)&&Ff(e)?e:XT(Ml(e))}function Bc(e,t){var r;t===void 0&&(t=[]);var n=XT(e),o=n===((r=e.ownerDocument)==null?void 0:r.body),s=pr(n),i=o?[s].concat(s.visualViewport||[],Ff(n)?n:[]):n,a=t.concat(i);return o?a:a.concat(Bc(Ml(i)))}function ug(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function ebt(e,t){var r=_s(e,!1,t==="fixed");return r.top=r.top+e.clientTop,r.left=r.left+e.clientLeft,r.bottom=r.top+e.clientHeight,r.right=r.left+e.clientWidth,r.width=e.clientWidth,r.height=e.clientHeight,r.x=r.left,r.y=r.top,r}function mX(e,t,r){return t===HT?ug(XR(e,r)):Es(t)?ebt(t,r):ug(YR(bn(e)))}function rbt(e){var t=Bc(Ml(e)),r=["absolute","fixed"].indexOf(Qn(e).position)>=0,n=r&&jr(e)?ai(e):e;return Es(n)?t.filter(function(o){return Es(o)&&w0(o,n)&&an(o)!=="body"}):[]}function QR(e,t,r,n){var o=t==="clippingParents"?rbt(e):[].concat(t),s=[].concat(o,[r]),i=s[0],a=s.reduce(function(l,u){var c=mX(e,u,n);return l.top=ii(c.top,l.top),l.right=_f(c.right,l.right),l.bottom=_f(c.bottom,l.bottom),l.left=ii(c.left,l.left),l},mX(e,i,n));return a.width=a.right-a.left,a.height=a.bottom-a.top,a.x=a.left,a.y=a.top,a}function T0(e){var t=e.reference,r=e.element,n=e.placement,o=n?ln(n):null,s=n?As(n):null,i=t.x+t.width/2-r.width/2,a=t.y+t.height/2-r.height/2,l;switch(o){case br:l={x:i,y:t.y-r.height};break;case qr:l={x:i,y:t.y+t.height};break;case Or:l={x:t.x+t.width,y:a};break;case Tr:l={x:t.x-r.width,y:a};break;default:l={x:t.x,y:t.y}}var u=o?Df(o):null;if(u!=null){var c=u==="y"?"height":"width";switch(s){case Pl:l[u]=l[u]-(t[c]/2-r[c]/2);break;case Ef:l[u]=l[u]+(t[c]/2-r[c]/2);break;default:}}return l}function li(e,t){t===void 0&&(t={});var r=t,n=r.placement,o=n===void 0?e.placement:n,s=r.strategy,i=s===void 0?e.strategy:s,a=r.boundary,l=a===void 0?nX:a,u=r.rootBoundary,c=u===void 0?HT:u,p=r.elementContext,f=p===void 0?sg:p,m=r.altBoundary,d=m===void 0?!1:m,h=r.padding,x=h===void 0?0:h,g=S0(typeof x!="number"?x:k0(x,zc)),y=f===sg?oX:sg,b=e.rects.popper,v=e.elements[d?y:f],C=QR(Es(v)?v:v.contextElement||bn(e.elements.popper),l,c,i),S=_s(e.elements.reference),k=T0({reference:S,element:b,strategy:"absolute",placement:o}),I=ug(Object.assign({},b,k)),D=f===sg?I:S,R={top:C.top-D.top+g.top,bottom:D.bottom-C.bottom+g.bottom,left:C.left-D.left+g.left,right:D.right-C.right+g.right},M=e.modifiersData.offset;if(f===sg&&M){var U=M[o];Object.keys(R).forEach(function(j){var K=[Or,qr].indexOf(j)>=0?1:-1,W=[br,qr].indexOf(j)>=0?"y":"x";R[j]+=U[W]*K})}return R}function ZR(e,t){t===void 0&&(t={});var r=t,n=r.placement,o=r.boundary,s=r.rootBoundary,i=r.padding,a=r.flipVariations,l=r.allowedAutoPlacements,u=l===void 0?qT:l,c=As(n),p=c?a?jR:jR.filter(function(d){return As(d)===c}):zc,f=p.filter(function(d){return u.indexOf(d)>=0});f.length===0&&(f=p);var m=f.reduce(function(d,h){return d[h]=li(e,{placement:h,boundary:o,rootBoundary:s,padding:i})[ln(h)],d},{});return Object.keys(m).sort(function(d,h){return m[d]-m[h]})}function nbt(e){if(ln(e)===UT)return[];var t=lg(e);return[KT(e),t,KT(t)]}function obt(e){var t=e.state,r=e.options,n=e.name;if(!t.modifiersData[n]._skip){for(var o=r.mainAxis,s=o===void 0?!0:o,i=r.altAxis,a=i===void 0?!0:i,l=r.fallbackPlacements,u=r.padding,c=r.boundary,p=r.rootBoundary,f=r.altBoundary,m=r.flipVariations,d=m===void 0?!0:m,h=r.allowedAutoPlacements,x=t.options.placement,g=ln(x),y=g===x,b=l||(y||!d?[lg(x)]:nbt(x)),v=[x].concat(b).reduce(function(ut,it){return ut.concat(ln(it)===UT?ZR(t,{placement:it,boundary:c,rootBoundary:p,padding:u,flipVariations:d,allowedAutoPlacements:h}):it)},[]),C=t.rects.reference,S=t.rects.popper,k=new Map,I=!0,D=v[0],R=0;R<v.length;R++){var M=v[R],U=ln(M),j=As(M)===Pl,K=[br,qr].indexOf(U)>=0,W=K?"width":"height",q=li(t,{placement:M,boundary:c,rootBoundary:p,altBoundary:f,padding:u}),X=K?j?Or:Tr:j?qr:br;C[W]>S[W]&&(X=lg(X));var Q=lg(X),Y=[];if(s&&Y.push(q[U]<=0),a&&Y.push(q[X]<=0,q[Q]<=0),Y.every(function(ut){return ut})){D=M,I=!1;break}k.set(M,Y)}if(I)for(var nt=d?3:1,rt=function(it){var dt=v.find(function(wt){var bt=k.get(wt);if(bt)return bt.slice(0,it).every(function(St){return St})});if(dt)return D=dt,"break"},at=nt;at>0;at--){var lt=rt(at);if(lt==="break")break}t.placement!==D&&(t.modifiersData[n]._skip=!0,t.placement=D,t.reset=!0)}}var dX={name:"flip",enabled:!0,phase:"main",fn:obt,requiresIfExists:["offset"],data:{_skip:!1}};function hX(e,t,r){return r===void 0&&(r={x:0,y:0}),{top:e.top-t.height-r.y,right:e.right-t.width+r.x,bottom:e.bottom-t.height+r.y,left:e.left-t.width-r.x}}function gX(e){return[br,Or,qr,Tr].some(function(t){return e[t]>=0})}function sbt(e){var t=e.state,r=e.name,n=t.rects.reference,o=t.rects.popper,s=t.modifiersData.preventOverflow,i=li(t,{elementContext:"reference"}),a=li(t,{altBoundary:!0}),l=hX(i,n),u=hX(a,o,s),c=gX(l),p=gX(u);t.modifiersData[r]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:p},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":p})}var xX={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:sbt};function ibt(e,t,r){var n=ln(e),o=[Tr,br].indexOf(n)>=0?-1:1,s=typeof r=="function"?r(Object.assign({},t,{placement:e})):r,i=s[0],a=s[1];return i=i||0,a=(a||0)*o,[Tr,Or].indexOf(n)>=0?{x:a,y:i}:{x:i,y:a}}function abt(e){var t=e.state,r=e.options,n=e.name,o=r.offset,s=o===void 0?[0,0]:o,i=qT.reduce(function(c,p){return c[p]=ibt(p,t.rects,s),c},{}),a=i[t.placement],l=a.x,u=a.y;t.modifiersData.popperOffsets!=null&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=u),t.modifiersData[n]=i}var yX={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:abt};function lbt(e){var t=e.state,r=e.name;t.modifiersData[r]=T0({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})}var bX={name:"popperOffsets",enabled:!0,phase:"read",fn:lbt,data:{}};function JR(e){return e==="x"?"y":"x"}function ubt(e){var t=e.state,r=e.options,n=e.name,o=r.mainAxis,s=o===void 0?!0:o,i=r.altAxis,a=i===void 0?!1:i,l=r.boundary,u=r.rootBoundary,c=r.altBoundary,p=r.padding,f=r.tether,m=f===void 0?!0:f,d=r.tetherOffset,h=d===void 0?0:d,x=li(t,{boundary:l,rootBoundary:u,padding:p,altBoundary:c}),g=ln(t.placement),y=As(t.placement),b=!y,v=Df(g),C=JR(v),S=t.modifiersData.popperOffsets,k=t.rects.reference,I=t.rects.popper,D=typeof h=="function"?h(Object.assign({},t.rects,{placement:t.placement})):h,R=typeof D=="number"?{mainAxis:D,altAxis:D}:Object.assign({mainAxis:0,altAxis:0},D),M=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,U={x:0,y:0};if(!!S){if(s){var j,K=v==="y"?br:Tr,W=v==="y"?qr:Or,q=v==="y"?"height":"width",X=S[v],Q=X+x[K],Y=X-x[W],nt=m?-I[q]/2:0,rt=y===Pl?k[q]:I[q],at=y===Pl?-I[q]:-k[q],lt=t.elements.arrow,ut=m&&lt?Af(lt):{width:0,height:0},it=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:C0(),dt=it[K],wt=it[W],bt=Rf(0,k[q],ut[q]),St=b?k[q]/2-nt-bt-dt-R.mainAxis:rt-bt-dt-R.mainAxis,Wt=b?-k[q]/2+nt+bt+wt+R.mainAxis:at+bt+wt+R.mainAxis,Ht=t.elements.arrow&&ai(t.elements.arrow),$=Ht?v==="y"?Ht.clientTop||0:Ht.clientLeft||0:0,G=(j=M==null?void 0:M[v])!=null?j:0,P=X+St-G-$,ot=X+Wt-G,ct=Rf(m?_f(Q,P):Q,X,m?ii(Y,ot):Y);S[v]=ct,U[v]=ct-X}if(a){var pt,Ft=v==="x"?br:Tr,ne=v==="x"?qr:Or,Bt=S[C],Me=C==="y"?"height":"width",fr=Bt+x[Ft],mr=Bt-x[ne],Ln=[br,Tr].indexOf(g)!==-1,Uo=(pt=M==null?void 0:M[C])!=null?pt:0,Ds=Ln?fr:Bt-k[Me]-I[Me]-Uo+R.altAxis,Rs=Ln?Bt+k[Me]+I[Me]-Uo-R.altAxis:mr,$s=m&&Ln?lX(Ds,Bt,Rs):Rf(m?Ds:fr,Bt,m?Rs:mr);S[C]=$s,U[C]=$s-Bt}t.modifiersData[n]=U}}var vX={name:"preventOverflow",enabled:!0,phase:"main",fn:ubt,requiresIfExists:["offset"]};function t$(e){return{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}}function e$(e){return e===pr(e)||!jr(e)?$f(e):t$(e)}function cbt(e){var t=e.getBoundingClientRect(),r=Ll(t.width)/e.offsetWidth||1,n=Ll(t.height)/e.offsetHeight||1;return r!==1||n!==1}function r$(e,t,r){r===void 0&&(r=!1);var n=jr(t),o=jr(t)&&cbt(t),s=bn(t),i=_s(e,o,r),a={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(n||!n&&!r)&&((an(t)!=="body"||Ff(s))&&(a=e$(t)),jr(t)?(l=_s(t,!0),l.x+=t.clientLeft,l.y+=t.clientTop):s&&(l.x=Of(s))),{x:i.left+a.scrollLeft-l.x,y:i.top+a.scrollTop-l.y,width:i.width,height:i.height}}function pbt(e){var t=new Map,r=new Set,n=[];e.forEach(function(s){t.set(s.name,s)});function o(s){r.add(s.name);var i=[].concat(s.requires||[],s.requiresIfExists||[]);i.forEach(function(a){if(!r.has(a)){var l=t.get(a);l&&o(l)}}),n.push(s)}return e.forEach(function(s){r.has(s.name)||o(s)}),n}function n$(e){var t=pbt(e);return sX.reduce(function(r,n){return r.concat(t.filter(function(o){return o.phase===n}))},[])}function o$(e){var t;return function(){return t||(t=new Promise(function(r){Promise.resolve().then(function(){t=void 0,r(e())})})),t}}function s$(e){var t=e.reduce(function(r,n){var o=r[n.name];return r[n.name]=o?Object.assign({},o,n,{options:Object.assign({},o.options,n.options),data:Object.assign({},o.data,n.data)}):n,r},{});return Object.keys(t).map(function(r){return t[r]})}var wX={placement:"bottom",modifiers:[],strategy:"absolute"};function CX(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return!t.some(function(n){return!(n&&typeof n.getBoundingClientRect=="function")})}function SX(e){e===void 0&&(e={});var t=e,r=t.defaultModifiers,n=r===void 0?[]:r,o=t.defaultOptions,s=o===void 0?wX:o;return function(a,l,u){u===void 0&&(u=s);var c={placement:"bottom",orderedModifiers:[],options:Object.assign({},wX,s),modifiersData:{},elements:{reference:a,popper:l},attributes:{},styles:{}},p=[],f=!1,m={state:c,setOptions:function(g){var y=typeof g=="function"?g(c.options):g;h(),c.options=Object.assign({},s,c.options,y),c.scrollParents={reference:Es(a)?Bc(a):a.contextElement?Bc(a.contextElement):[],popper:Bc(l)};var b=n$(s$([].concat(n,c.options.modifiers)));if(c.orderedModifiers=b.filter(function(M){return M.enabled}),!1){var v;if(getBasePlacement(c.options.placement)===auto)var C;var S,k,I,D,R}return d(),m.update()},forceUpdate:function(){if(!f){var g=c.elements,y=g.reference,b=g.popper;if(!!CX(y,b)){c.rects={reference:r$(y,ai(b),c.options.strategy==="fixed"),popper:Af(b)},c.reset=!1,c.placement=c.options.placement,c.orderedModifiers.forEach(function(M){return c.modifiersData[M.name]=Object.assign({},M.data)});for(var v=0,C=0;C<c.orderedModifiers.length;C++){if(c.reset===!0){c.reset=!1,C=-1;continue}var S=c.orderedModifiers[C],k=S.fn,I=S.options,D=I===void 0?{}:I,R=S.name;typeof k=="function"&&(c=k({state:c,options:D,name:R,instance:m})||c)}}}},update:o$(function(){return new Promise(function(x){m.forceUpdate(),x(c)})}),destroy:function(){h(),f=!0}};if(!CX(a,l))return m;m.setOptions(u).then(function(x){!f&&u.onFirstUpdate&&u.onFirstUpdate(x)});function d(){c.orderedModifiers.forEach(function(x){var g=x.name,y=x.options,b=y===void 0?{}:y,v=x.effect;if(typeof v=="function"){var C=v({state:c,name:g,instance:m,options:b}),S=function(){};p.push(C||S)}})}function h(){p.forEach(function(x){return x()}),p=[]}return m}}var fbt=[fX,bX,pX,iX,yX,dX,vX,uX,xX],i$=SX({defaultModifiers:fbt});var IX=Yt(TX());var xbt=[],a$=function(t,r,n){n===void 0&&(n={});var o=Vc.useRef(null),s={onFirstUpdate:n.onFirstUpdate,placement:n.placement||"bottom",strategy:n.strategy||"absolute",modifiers:n.modifiers||xbt},i=Vc.useState({styles:{popper:{position:s.strategy,left:"0",top:"0"},arrow:{position:"absolute"}},attributes:{}}),a=i[0],l=i[1],u=Vc.useMemo(function(){return{name:"updateState",enabled:!0,phase:"write",fn:function(m){var d=m.state,h=Object.keys(d.elements);NX.flushSync(function(){l({styles:DA(h.map(function(x){return[x,d.styles[x]||{}]})),attributes:DA(h.map(function(x){return[x,d.attributes[x]]}))})})},requires:["computeStyles"]}},[]),c=Vc.useMemo(function(){var f={onFirstUpdate:s.onFirstUpdate,placement:s.placement,strategy:s.strategy,modifiers:[].concat(s.modifiers,[u,{name:"applyStyles",enabled:!1}])};return(0,IX.default)(o.current,f)?o.current||f:(o.current=f,f)},[s.onFirstUpdate,s.placement,s.strategy,s.modifiers,u]),p=Vc.useRef();return RA(function(){p.current&&p.current.setOptions(c)},[c]),RA(function(){if(!(t==null||r==null)){var f=n.createPopper||i$,m=f(t,r,c);return p.current=m,function(){m.destroy(),p.current=null}}},[t,r,n.createPopper]),{state:p.current?p.current.state:null,styles:a.styles,attributes:a.attributes,update:p.current?p.current.update:null,forceUpdate:p.current?p.current.forceUpdate:null}};function AX(e){var t=De.useRef(e);return t.current=e,De.useCallback(function(){return t.current},[])}var ybt=function(){};function bbt(e){var t=e.initial,r=e.value,n=e.onChange,o=n===void 0?ybt:n;if(t===void 0&&r===void 0)throw new TypeError('Either "value" or "initial" variable must be set. Now both are undefined');var s=De.useState(t),i=s[0],a=s[1],l=AX(i),u=De.useCallback(function(p){var f=l(),m=typeof p=="function"?p(f):p;typeof m.persist=="function"&&m.persist(),a(m),typeof o=="function"&&o(m)},[l,o]),c=r!==void 0;return[c?r:i,c?o:u]}function DX(e,t){return e===void 0&&(e=0),t===void 0&&(t=0),function(){return{width:0,height:0,top:t,right:e,bottom:t,left:e,x:0,y:0,toJSON:function(){return null}}}}var vbt=["styles","attributes"],EX={getBoundingClientRect:DX()},_X={closeOnOutsideClick:!0,closeOnTriggerHidden:!1,defaultVisible:!1,delayHide:0,delayShow:0,followCursor:!1,interactive:!1,mutationObserverOptions:{attributes:!0,childList:!0,subtree:!0},offset:[0,6],trigger:"hover"};function cg(e,t){var r,n,o;e===void 0&&(e={}),t===void 0&&(t={});var s=Object.keys(_X).reduce(function(W,q){var X;return Qs({},W,(X={},X[q]=W[q]!==void 0?W[q]:_X[q],X))},e),i=De.useMemo(function(){return[{name:"offset",options:{offset:s.offset}}]},Array.isArray(s.offset)?s.offset:[]),a=Qs({},t,{placement:t.placement||s.placement,modifiers:t.modifiers||i}),l=De.useState(null),u=l[0],c=l[1],p=De.useState(null),f=p[0],m=p[1],d=bbt({initial:s.defaultVisible,value:s.visible,onChange:s.onVisibleChange}),h=d[0],x=d[1],g=De.useRef();De.useEffect(function(){return function(){return clearTimeout(g.current)}},[]);var y=a$(s.followCursor?EX:u,f,a),b=y.styles,v=y.attributes,C=AA(y,vbt),S=C.update,k=AX({visible:h,triggerRef:u,tooltipRef:f,finalConfig:s}),I=De.useCallback(function(W){return Array.isArray(s.trigger)?s.trigger.includes(W):s.trigger===W},Array.isArray(s.trigger)?s.trigger:[s.trigger]),D=De.useCallback(function(){clearTimeout(g.current),g.current=window.setTimeout(function(){return x(!1)},s.delayHide)},[s.delayHide,x]),R=De.useCallback(function(){clearTimeout(g.current),g.current=window.setTimeout(function(){return x(!0)},s.delayShow)},[s.delayShow,x]),M=De.useCallback(function(){k().visible?D():R()},[k,D,R]);De.useEffect(function(){if(!!k().finalConfig.closeOnOutsideClick){var W=function(X){var Q,Y=k(),nt=Y.tooltipRef,rt=Y.triggerRef,at=(X.composedPath==null||(Q=X.composedPath())==null?void 0:Q[0])||X.target;at instanceof Node&&nt!=null&&rt!=null&&!nt.contains(at)&&!rt.contains(at)&&D()};return document.addEventListener("mousedown",W),function(){return document.removeEventListener("mousedown",W)}}},[k,D]),De.useEffect(function(){if(!(u==null||!I("click")))return u.addEventListener("click",M),function(){return u.removeEventListener("click",M)}},[u,I,M]),De.useEffect(function(){if(!(u==null||!I("double-click")))return u.addEventListener("dblclick",M),function(){return u.removeEventListener("dblclick",M)}},[u,I,M]),De.useEffect(function(){if(!(u==null||!I("right-click"))){var W=function(X){X.preventDefault(),M()};return u.addEventListener("contextmenu",W),function(){return u.removeEventListener("contextmenu",W)}}},[u,I,M]),De.useEffect(function(){if(!(u==null||!I("focus")))return u.addEventListener("focus",R),u.addEventListener("blur",D),function(){u.removeEventListener("focus",R),u.removeEventListener("blur",D)}},[u,I,R,D]),De.useEffect(function(){if(!(u==null||!I("hover")))return u.addEventListener("mouseenter",R),u.addEventListener("mouseleave",D),function(){u.removeEventListener("mouseenter",R),u.removeEventListener("mouseleave",D)}},[u,I,R,D]),De.useEffect(function(){if(!(f==null||!I("hover")||!k().finalConfig.interactive))return f.addEventListener("mouseenter",R),f.addEventListener("mouseleave",D),function(){f.removeEventListener("mouseenter",R),f.removeEventListener("mouseleave",D)}},[f,I,R,D,k]);var U=C==null||(r=C.state)==null||(n=r.modifiersData)==null||(o=n.hide)==null?void 0:o.isReferenceHidden;De.useEffect(function(){s.closeOnTriggerHidden&&U&&D()},[s.closeOnTriggerHidden,D,U]),De.useEffect(function(){if(!s.followCursor||u==null)return;function W(q){var X=q.clientX,Q=q.clientY;EX.getBoundingClientRect=DX(X,Q),S==null||S()}return u.addEventListener("mousemove",W),function(){return u.removeEventListener("mousemove",W)}},[s.followCursor,u,S]),De.useEffect(function(){if(!(f==null||S==null||s.mutationObserverOptions==null)){var W=new MutationObserver(S);return W.observe(f,s.mutationObserverOptions),function(){return W.disconnect()}}},[s.mutationObserverOptions,f,S]);var j=function(q){return q===void 0&&(q={}),Qs({},q,{style:Qs({},q.style,b.popper)},v.popper,{"data-popper-interactive":s.interactive})},K=function(q){return q===void 0&&(q={}),Qs({},q,v.arrow,{style:Qs({},q.style,b.arrow),"data-popper-arrow":!0})};return Qs({getArrowProps:K,getTooltipProps:j,setTooltipRef:m,setTriggerRef:c,tooltipRef:f,triggerRef:u,visible:h},C)}function N0(e){return e.replace(/\s/g,"&nbsp;").replace(/\n/g,"\xB6")}function RX({token:e,value:t,min:r,max:n,negativeColor:o,positiveColor:s}){let{getTooltipProps:i,setTooltipRef:a,setTriggerRef:l,visible:u}=cg({followCursor:!0}),c=Jl(t,r,n,o,s).toRgbString(),p=He(c).brightness()<.6?"white":"black",f={display:"inline-block",backgroundColor:c,color:p,lineHeight:"1em",padding:"3px 0",marginLeft:-1,marginBottom:1,borderWidth:1,borderStyle:"solid",borderColor:"#eee"},m=N0(e),d=e.match(/\n/g);return zl.default.createElement(zl.default.Fragment,null,zl.default.createElement("span",{ref:l},zl.default.createElement("span",{style:f,dangerouslySetInnerHTML:{__html:m}}),d==null?void 0:d.map((h,x)=>zl.default.createElement("br",{key:x}))),u&&zl.default.createElement("div",ae({ref:a},i({style:{background:"#333",color:"white",textAlign:"center",padding:10,borderRadius:5,boxShadow:"5px 5px rgba(0, 0, 0, 0.03)",marginTop:15,zIndex:1}})),zl.default.createElement("strong",null,e),zl.default.createElement("br",null),t))}function I0({maxValue:e,minValue:t,negativeColor:r,positiveColor:n,tokens:o,values:s,paddingBottom:i}){let a=t!=null?t:Math.min(...s),l=e!=null?e:Math.max(...s);return l$.default.createElement("div",{className:"colored-tokens",style:{paddingBottom:i}},o.map((u,c)=>l$.default.createElement(RX,{key:c,token:u,value:s[c],min:a,max:l,negativeColor:r,positiveColor:n})))}var Re=Yt(oe());var u$=Yt(oe());var Bl=Yt(oe());function QT({token:e,value:t,min:r,max:n,negativeColor:o,positiveColor:s,tooltip:i=Bl.default.createElement(Bl.default.Fragment,null,"Intentionally Left Blank")}){let{getTooltipProps:a,setTooltipRef:l,setTriggerRef:u,visible:c}=cg({followCursor:!0}),p=Jl(t,r,n,o,s).toRgbString(),f=He(p).brightness()<.6?"white":"black",m={display:"inline-block",backgroundColor:p,color:f,lineHeight:"1em",padding:"3px 0",marginLeft:-1,marginBottom:1,borderWidth:1,borderStyle:"solid",borderColor:"#eee"},d=N0(e),h=e.match(/\n/g);return Bl.default.createElement(Bl.default.Fragment,null,Bl.default.createElement("span",{ref:u},Bl.default.createElement("span",{style:m,dangerouslySetInnerHTML:{__html:d}}),h==null?void 0:h.map((x,g)=>Bl.default.createElement("br",{key:g}))),c&&Bl.default.createElement("div",ae({ref:l},a({style:{background:"#eee",color:"black",textAlign:"center",padding:10,borderRadius:5,boxShadow:"5px 5px rgba(0, 0, 0, 0.03)",marginTop:15}})),i))}function $X({maxValue:e,minValue:t,negativeColor:r,positiveColor:n,tokens:o,values:s,tooltips:i}){let a=t!=null?t:Math.min(...s),l=e!=null?e:Math.max(...s);return u$.default.createElement("div",{className:"colored-tokens",style:{paddingBottom:30}},o.map((u,c)=>u$.default.createElement(QT,{key:c,token:u,value:s[c],min:a,max:l,negativeColor:r,positiveColor:n,tooltip:i[c]})))}var c$=6;function wbt({values:e,labels:t,selectedValue:r,setSelectedValue:n}){let o=e.shape[1],{focused:s,onClick:i,onMouseEnter:a,onMouseLeave:l}=Qc();(0,Re.useEffect)(()=>{s!==null&&n(s)},[s,n]);let u=[];for(let c=0;c<o;c++){let p=c===r,f=t[c];u.push(Re.default.createElement("div",{key:c,style:{display:"inline-block",padding:"0 5px",backgroundColor:p?"black":"white",color:p?"white":"black",cursor:"pointer"},onClick:()=>i(c),onMouseEnter:()=>a(c),onMouseLeave:l},f))}return Re.default.createElement("div",null,u)}function OX({value:e,setValue:t,defaultValue:r,label:n}){return Re.default.createElement("div",null,Re.default.createElement("label",{htmlFor:n},n,":")," ",Re.default.createElement("input",{type:"text",id:"number",value:e,onChange:i=>{t(parseFloat(i.target.value))}}),r&&Re.default.createElement("button",{type:"button",onClick:()=>{t(r)}},"Reset"))}function Cbt({title:e,labels:t,values:r,tokenIndex:n,currentValueIndex:o}){let s=r.shape[1],i=[];for(let a=0;a<s;a++)i.push(Re.default.createElement("tr",{key:a},Re.default.createElement("td",{style:{fontWeight:"bold"}},t[a]),Re.default.createElement("td",{style:{textAlign:"right",fontWeight:o===a?"bold":"normal"}},r.bufferSync().get(n,a).toFixed(c$))));return Re.default.createElement(Re.default.Fragment,null,Re.default.createElement("div",{style:{fontWeight:"bold",fontSize:16,backgroundColor:"white"}},e),Re.default.createElement("table",null,Re.default.createElement("tbody",null,i)))}function FX({tokens:e,values:t,labels:r,positiveBounds:n,negativeBounds:o}){let s=sr(t),i=s.shape[1],a=n?sr(n):s.max(0).maximum(1e-7),l=o?sr(o):s.min(0).minimum(-1e-7),u=r||Array.from(Array(i).keys()).map((b,v)=>`${v}`),[c,p]=(0,Re.useState)(0),f=Number(a.arraySync()[c].toFixed(c$)),m=Number(l.arraySync()[c].toFixed(c$)),[d,h]=(0,Re.useState)(Number(f)),[x,g]=(0,Re.useState)(Number(m)),y=s.slice([0,c],[-1,1]).squeeze([1]);return Re.default.createElement("div",{style:{paddingBottom:20*i}},Re.default.createElement(wbt,{values:s,labels:u,selectedValue:c,setSelectedValue:p}),Re.default.createElement(OX,{value:d,setValue:h,defaultValue:f,label:"Positive Bound"}),Re.default.createElement(OX,{value:x,setValue:g,defaultValue:m,label:"Negative Bound"}),Re.default.createElement("br",null),Re.default.createElement($X,{tokens:e,values:y.arraySync(),maxValue:d,minValue:x,tooltips:y.arraySync().map((b,v)=>Re.default.createElement(Cbt,{key:v,title:e[v],labels:u,values:s,tokenIndex:v,currentValueIndex:c}))}))}var PX=Yt(oe());function LX({name:e}){return PX.default.createElement("p",null,"Hello, ",e,"!")}var BX=Yt(oe()),VX=Yt(zX());function WX(e,t,r={}){let n=document.querySelector(`#${e}`),o=VX.default.createRoot(n),s=BX.default.createElement(t,r);o.render(s)}var ve=Yt(oe()),vn=Yt(Uc());var Wc=Yt(oe()),pg=Yt(Uc());function ZT({activationsList:e,tokensList:t,minValue:r,maxValue:n}){let o={border:"1px solid black",borderRadius:5,padding:10,marginTop:10,marginBottom:10,backgroundColor:"#f5f5f5"};return Wc.default.createElement("div",null,e&&t&&e.length>1&&e.map((s,i)=>Wc.default.createElement(pg.Row,{key:i},Wc.default.createElement(pg.Col,{style:o},Wc.default.createElement(I0,{minValue:r,maxValue:n,tokens:t[i],values:s,paddingBottom:0})))),e&&t&&e.length===1&&Wc.default.createElement(pg.Row,{key:0},Wc.default.createElement(pg.Col,null,Wc.default.createElement(I0,{tokens:t[0],values:e[0]}))))}var f$=Yt(oe());function Sbt(e){return e.length<3?e.join("-"):`${e[0]}-${e[e.length-1]}`}function kbt(e){let t=e.split("-");if(t.length===1)return[parseInt(t[0],10)];let r=parseInt(t[0],10),n=parseInt(t[t.length-1],10);return Array.from({length:n-r+1},(o,s)=>r+s)}function fg({smallestNumber:e=0,largestNumber:t,currentRangeArr:r,setCurrentValue:n,numValsInRange:o,id:s}){let i=Sbt(r),a=[];for(let l=e;l<=t;l+=o){let u=l,c=Math.min(l+o-1,t);u===c?a.push(`${u}`):a.push(`${u}-${c}`)}return f$.default.createElement("select",{value:i,onChange:l=>n(kbt(l.target.value)),id:s},a.map(l=>f$.default.createElement("option",{key:l},l)))}var m$=Yt(oe());function Go({smallestNumber:e=0,largestNumber:t,currentValue:r,setCurrentValue:n,id:o,labels:s}){let i=[...Array(t-e+1).keys()].map(l=>l+e),a=s&&s.length===i.length?s:i.map(l=>l.toString());return m$.default.createElement("select",{value:r,onChange:l=>n(Number(l.target.value)),id:o},i.map((l,u)=>m$.default.createElement("option",{key:l,value:l},a[u])))}function E0(e,t){return e.slice(t[0][0],t[0][1]).map(r=>r.slice(t[1][0],t[1][1]))}function _0(e){if(e.length===0)return[0,1];let t=Number.MAX_VALUE,r=Number.MIN_VALUE;for(let n=0;n<e.length;n+=1)if(Array.isArray(e[n])){let[o,s]=_0(e[n]);t=Math.min(t,o),r=Math.max(r,s)}else t=Math.min(t,e[n]),r=Math.max(r,e[n]);return[t,r]}function Tbt(e,t,r){return e.slice([0,t,r],[-1,1,1]).squeeze([1,2]).arraySync()}function GX({tokens:e,activations:t,firstDimensionName:r="Layer",secondDimensionName:n="Neuron",firstDimensionLabels:o,secondDimensionLabels:s}){let i=typeof e[0]=="string"?[e]:e,a=typeof t[0][0][0]=="number"?[t]:t,[l,u]=_0(a),c=a.map(D=>sr(D)),p=c[0].shape[1],f=c[0].shape[2],m=c.length,[d,h]=(0,ve.useState)(Math.min(5,m)),[x,g]=(0,ve.useState)([...Array(d).keys()]),[y,b]=(0,ve.useState)(0),[v,C]=(0,ve.useState)(0);(0,ve.useEffect)(()=>{g([...Array(d).keys()])},[d]);let S=x.map(D=>Tbt(c[D],y,v)),k=x.map(D=>i[D]),I={paddingTop:5,paddingBottom:5};return ve.default.createElement(vn.Container,{fluid:!0},ve.default.createElement(vn.Row,null,ve.default.createElement(vn.Col,null,ve.default.createElement(vn.Row,{style:I},ve.default.createElement(vn.Col,null,ve.default.createElement("label",{htmlFor:"layer-selector",style:{marginRight:15}},r,":"),ve.default.createElement(Go,{id:"layer-selector",largestNumber:p-1,currentValue:y,setCurrentValue:b,labels:o}))),ve.default.createElement(vn.Row,{style:I},ve.default.createElement(vn.Col,null,ve.default.createElement("label",{htmlFor:"neuron-selector",style:{marginRight:15}},n,":"),ve.default.createElement(Go,{id:"neuron-selector",largestNumber:f-1,currentValue:v,setCurrentValue:C,labels:s}))),m>1&&ve.default.createElement(vn.Row,{style:I},ve.default.createElement(vn.Col,null,ve.default.createElement("label",{htmlFor:"sample-selector",style:{marginRight:15}},"Samples:"),ve.default.createElement(fg,{id:"sample-selector",largestNumber:m-1,currentRangeArr:x,setCurrentValue:g,numValsInRange:d})))),ve.default.createElement(vn.Col,null,m>1&&ve.default.createElement(vn.Row,{style:I},ve.default.createElement(vn.Col,null,ve.default.createElement("label",{htmlFor:"samples-per-page-selector",style:{marginRight:15}},"Samples per page:"),ve.default.createElement(Go,{id:"samples-per-page-selector",smallestNumber:1,largestNumber:m,currentValue:d,setCurrentValue:h}))))),ve.default.createElement(vn.Row,null,ve.default.createElement(vn.Col,null,ve.default.createElement(ZT,{activationsList:S,tokensList:k,minValue:l,maxValue:u}))))}var nr=Yt(oe());Kv([Xv,Yv]);var d$=5;function UX(e,t="blue",r=-d$){return He(t).mix(He("grey"),Math.min(-e/-r,1))}function h$({token:e}){return nr.default.createElement("span",{style:{borderColor:"green",borderWidth:1,borderStyle:"solid"},dangerouslySetInnerHTML:{__html:N0(e)}})}function HX({token:e,logProb:t,rank:r,isCorrectToken:n}){let o={color:"orange",backgroundColor:UX(t).toRgbString(),fontWeight:"bold"},s={color:"white",backgroundColor:UX(t).toRgbString()};return nr.default.createElement("tr",{style:n?o:s},nr.default.createElement("td",null,"#",r),nr.default.createElement("td",null,(Math.exp(t)*100).toFixed(2),"%"),nr.default.createElement("td",null,t.toFixed(3)),nr.default.createElement("td",null,nr.default.createElement(h$,{token:e})))}function Nbt({currentCorrectToken:e,currentCorrectTokenRank:t,currentCorrectTokenLogProb:r,currentTopKLogProbs:n,currentTopKTokens:o,prevToken:s}){return nr.default.createElement("div",null,nr.default.createElement("div",{style:{fontSize:20,fontWeight:"bold",backgroundColor:"white",color:"black"}},nr.default.createElement(h$,{token:s})," -",">"," ",nr.default.createElement(h$,{token:e})),nr.default.createElement("table",null,nr.default.createElement("tr",null,nr.default.createElement("th",null,"Rank"),nr.default.createElement("th",null,"Prob"),nr.default.createElement("th",null,"Log Prob"),nr.default.createElement("th",null,"String")),nr.default.createElement(HX,{token:e,logProb:r,rank:t,isCorrectToken:!0}),nr.default.createElement("hr",null),o.map((i,a)=>nr.default.createElement(HX,{key:a,token:o[a],logProb:n[a],rank:a,isCorrectToken:t===a}))))}function qX({prompt:e,topKLogProbs:t,topKTokens:r,correctTokenRank:n,correctTokenLogProb:o}){return nr.default.createElement("div",{style:{paddingBottom:350}},e.slice(1).map((s,i)=>nr.default.createElement(QT,{key:i,token:s,value:Math.max(d$+o[i],0),min:-.1,max:d$,positiveColor:"red",tooltip:nr.default.createElement(Nbt,{currentCorrectToken:s,currentCorrectTokenRank:n[i],currentCorrectTokenLogProb:o[i],currentTopKLogProbs:t[i],currentTopKTokens:r[i],prevToken:e[i]})})))}var we=Yt(oe()),wn=Yt(Uc());function jX({tokens:e,activations:t,zerothDimensionName:r="Layer",firstDimensionName:n="Neuron",zerothDimensionLabels:o,firstDimensionLabels:s}){let i=t.length,a=t[0].length,l=t[0][0].length,[u,c]=(0,we.useState)(Math.min(5,l)),[p,f]=(0,we.useState)([...Array(u).keys()]),[m,d]=(0,we.useState)(0),[h,x]=(0,we.useState)(0);(0,we.useEffect)(()=>{f([...Array(u).keys()])},[u]);let g=p.map(S=>t[m][h][S]),y=p.map(S=>e[m][h][S]),[b,v]=_0(t[m][h]),C={paddingTop:5,paddingBottom:5};return we.default.createElement(wn.Container,{fluid:!0},we.default.createElement(wn.Row,null,we.default.createElement(wn.Col,null,we.default.createElement(wn.Row,{style:C},we.default.createElement(wn.Col,null,we.default.createElement("label",{htmlFor:"layer-selector",style:{marginRight:15}},r,":"),we.default.createElement(Go,{id:"layer-selector",largestNumber:i-1,currentValue:m,setCurrentValue:d,labels:o}))),we.default.createElement(wn.Row,{style:C},we.default.createElement(wn.Col,null,we.default.createElement("label",{htmlFor:"neuron-selector",style:{marginRight:15}},n,":"),we.default.createElement(Go,{id:"neuron-selector",largestNumber:a-1,currentValue:h,setCurrentValue:x,labels:s}))),l>1&&we.default.createElement(wn.Row,{style:C},we.default.createElement(wn.Col,null,we.default.createElement("label",{htmlFor:"sample-selector",style:{marginRight:15}},"Samples (descending):"),we.default.createElement(fg,{id:"sample-selector",largestNumber:l-1,currentRangeArr:p,setCurrentValue:f,numValsInRange:u})))),we.default.createElement(wn.Col,null,l>1&&we.default.createElement(wn.Row,{style:C},we.default.createElement(wn.Col,null,we.default.createElement("label",{htmlFor:"samples-per-page-selector",style:{marginRight:15}},"Samples per page:"),we.default.createElement(Go,{id:"samples-per-page-selector",smallestNumber:1,largestNumber:l,currentValue:u,setCurrentValue:c}))))),we.default.createElement(wn.Row,null,we.default.createElement(wn.Col,null,we.default.createElement(ZT,{activationsList:g,tokensList:y,minValue:b,maxValue:v}))))}var Nt=Yt(oe()),Kr=Yt(Uc());function KX({tdKey:e,token:t,value:r,minValue:n,maxValue:o,negativeColor:s,positiveColor:i}){let{getTooltipProps:a,setTooltipRef:l,setTriggerRef:u,visible:c}=cg({followCursor:!0}),p=Jl(r,n,o,s,i).toRgbString(),f=He(p).brightness()<.6?"white":"black",d=t.replace(/\s/g,"&nbsp;").replace(/\n/g,"\xB6");return Nt.default.createElement("td",{key:e,style:{backgroundColor:p,borderWidth:1,borderStyle:"solid",borderColor:"black"}},Nt.default.createElement("span",{ref:u,style:{display:"block",color:f},dangerouslySetInnerHTML:{__html:d}}),c&&Nt.default.createElement("div",ae({ref:l},a({style:{background:"#333",color:"white",textAlign:"center",padding:10,borderRadius:5,boxShadow:"5px 5px rgba(0, 0, 0, 0.03)",marginTop:15,zIndex:1}})),Nt.default.createElement("strong",null,t),Nt.default.createElement("br",null),r))}function Ibt({topkActivations:e,bottomkActivations:t,topkTokens:r,bottomkTokens:n,neuronNumbers:o,filter:s,colLabel:i}){return Nt.default.createElement("table",{style:{marginTop:15,marginLeft:15}},Nt.default.createElement("thead",null,Nt.default.createElement("tr",null,Nt.default.createElement("th",{colSpan:o.length+1,style:{textAlign:"center",paddingLeft:"9ch"}},i)),Nt.default.createElement("tr",null,Nt.default.createElement("th",{key:"default",style:{textAlign:"center"}}),o.map(a=>Nt.default.createElement("th",{key:a,style:{textAlign:"center"}},a)))),Nt.default.createElement("tbody",null,s.includes("topk")&&e.map((a,l)=>Nt.default.createElement("tr",{key:l},l===0&&Nt.default.createElement("td",{key:"default",style:{textAlign:"center",fontWeight:"bold"},rowSpan:e.length},"Topk \u2193"),a.map((u,c)=>Nt.default.createElement(KX,{key:c,tdKey:c,token:r[l][c],value:u,minValue:0,maxValue:1})))),s==="topk+bottomk"&&Nt.default.createElement("tr",null,Nt.default.createElement("td",{key:"default",style:{textAlign:"center"}}),Array(e[0].length).fill(0).map((a,l)=>Nt.default.createElement("td",{key:l},Nt.default.createElement("div",{style:{textAlign:"center"}},"...")))),s.includes("bottomk")&&t.map((a,l)=>Nt.default.createElement("tr",{key:l},l===0&&Nt.default.createElement("td",{key:"default",style:{textAlign:"center",fontWeight:"bold"},rowSpan:t.length},"Bottomk \u2193"),a.map((u,c)=>Nt.default.createElement(KX,{key:c,tdKey:c,token:n[l][c],value:u,minValue:0,maxValue:1}))))))}function XX({tokens:e,topkVals:t,topkIdxs:r,bottomkVals:n,bottomkIdxs:o,firstDimensionName:s="Layer",thirdDimensionName:i="Neuron",sampleLabels:a,firstDimensionLabels:l}){let u=t.length,c=t[0].length,p=t[0][0].length,f=t[0][0][0].length,[m,d]=(0,Nt.useState)(0),[h,x]=(0,Nt.useState)(0),[g,y]=(0,Nt.useState)(5),[b,v]=(0,Nt.useState)(p),[C,S]=(0,Nt.useState)([...Array(g).keys()]),[k,I]=(0,Nt.useState)("topk+bottomk");(0,Nt.useEffect)(()=>{S(u>1?[...Array(g).keys()]:[0])},[g,u]);let D=e[m],R=[[0,b],[C[0],C[C.length-1]+1]],M=E0(t[m][h],R),U=E0(r[m][h],R),j=E0(n[m][h],R),K=E0(o[m][h],R),W=U.map(Q=>Q.map(Y=>D[Y])),q=K.map(Q=>Q.map(Y=>D[Y])),X={paddingTop:5,paddingBottom:5};return Nt.default.createElement("div",null,Nt.default.createElement(Kr.Container,{fluid:!0},Nt.default.createElement(Kr.Row,null,Nt.default.createElement(Kr.Col,null,Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"sample-selector",style:{marginRight:15}},"Sample:"),Nt.default.createElement(Go,{id:"sample-selector",smallestNumber:0,largestNumber:u-1,currentValue:m,setCurrentValue:d,labels:a}))),Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"layer-selector",style:{marginRight:15}},s,":"),Nt.default.createElement(Go,{id:"layer-selector",largestNumber:c-1,currentValue:h,setCurrentValue:x,labels:l}))),Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"neuron-selector",style:{marginRight:15}},i,":"),Nt.default.createElement(fg,{id:"neuron-selector",largestNumber:f-1,currentRangeArr:C,setCurrentValue:S,numValsInRange:g})))),Nt.default.createElement(Kr.Col,null,Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"filter-select",style:{marginRight:15}},"Filter:"),Nt.default.createElement("select",{value:k,onChange:Q=>I(Q.target.value),id:"filter-select"},Nt.default.createElement("option",{value:void 0},"topk+bottomk"),Nt.default.createElement("option",{value:"topk"},"topk"),Nt.default.createElement("option",{value:"bottomk"},"bottomk")))),Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"visibleCols-selector",style:{marginRight:15}},i,"s to show:"),Nt.default.createElement(Go,{id:"visible-cols-selector",smallestNumber:1,largestNumber:f,currentValue:g,setCurrentValue:y}))),Nt.default.createElement(Kr.Row,{style:X},Nt.default.createElement(Kr.Col,null,Nt.default.createElement("label",{htmlFor:"k-selector",style:{marginRight:15}},"k:"),Nt.default.createElement(Go,{id:"k-selector",smallestNumber:1,largestNumber:p,currentValue:b,setCurrentValue:v})))))),Nt.default.createElement(Ibt,{topkActivations:M,bottomkActivations:j,topkTokens:W,bottomkTokens:q,neuronNumbers:C,filter:k,colLabel:i}))}return s9(Ebt);})();
//# sourceMappingURL=iife.js.map
